/******************************************************************************
 *
 * Copyright 2010, Dream Chip Technologies GmbH. All rights reserved.
 *
 ****************************************************************************
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2020 VeriSilicon Holdings Co., Ltd.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 *
 *****************************************************************************
 *
 * The GPL License (GPL)
 *
 * Copyright (c) 2020 VeriSilicon Holdings Co., Ltd.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program;
 *
 *****************************************************************************
 *
 * Note: This software is released under dual MIT and GPL licenses. A
 * recipient may use this file under the terms of either the MIT license or
 * GPL License. If you wish to use only one license not the other, you can
 * indicate your decision by deleting one of the above license notices in your
 * version of this file.
 *
 *****************************************************************************/

#ifndef __MRV_ALL_BITS_H__
#define __MRV_ALL_BITS_H__

/*****************************************************************************/
/* this includes the registermap generated by SIG-flow                       */
/*****************************************************************************/
#ifndef __KERNEL__
#include <stdint.h>
#else
#include <linux/types.h>
#endif
#include "mrv_all_regs.h"

/*****************************************************************************/
/* this includes the hw version information                                  */
/*****************************************************************************/
#include "isp_version.h"

/*****************************************************************************/
/* Marvin Main Control Registers                                             */
/*****************************************************************************/

/*****************************************************************************/
/**
 * register: vi_ccl: Data path control register (0x0000)
 *
 *****************************************************************************/
/* Slice: vi_ccl_dis:*/
/* Clock Control Logic disable */
/* 0: processing/cfg-clocks for all marvin sub modules enabled */
/* 1: processing/cfg-clocks for all marvin sub modules disabled w/o access to ID and VI_CCL register */
#ifdef MRV_VI_CCL_DIS
#define MRV_VI_CCL_ENABLE_CLOCKS    0
#define MRV_VI_CCL_DISABLE_CLOCKS   1
#endif /* MRV_VI_CCL_DIS */

/*****************************************************************************/
/**
 * register: vi_id: Revision identification register (0x0008)
 *
 *****************************************************************************/
/* Slice: rev_id:*/
/* MARVIN5 revision IDs */
#ifdef MRV_REV_ID
#endif /* MRV_REV_ID */

/*****************************************************************************/
/**
 * register: vi_iccl: Internal clock  control register (0x0010)
 *
 *****************************************************************************/
 /* Slice: vi_mipi_clk_enable: */
 /* MIPI interface clock enable */
 /* 1: processing mode */
 /* 0: power safe */
#ifdef MRV_VI_MIPI_CLK_ENABLE
#endif /* MRV_VI_MIPI_CLK_ENABLE */

/* Slice: vi_smia_clk_enable:*/
/* SMIA interface clock enable */
/* 1: processing mode */
/* 0: power safe */
#ifdef MRV_VI_SMIA_CLK_ENABLE
#endif /* MRV_VI_SMIA_CLK_ENABLE */

/* Slice: vi_simp_clk_enable:*/
/* Superimpose clock enable */
/* 1: processing mode */
/* 0: power safe */
#ifdef MRV_VI_SIMP_CLK_ENABLE
#endif /* MRV_VI_SIMP_CLK_ENABLE */

/* Slice: vi_ie_clk_enable:*/
/* Image effect clock enable */
/* 1: processing mode */
/* 0: power safe */
#ifdef MRV_VI_IE_CLK_ENABLE
#endif /* MRV_VI_IE_CLK_ENABLE */

/* Slice: vi_mi_clk_enable:*/
/* memory interface clock enable */
/* 1: processing mode */
/* 0: power safe */
#ifdef MRV_VI_MI_CLK_ENABLE
#endif /* MRV_VI_MI_CLK_ENABLE */

/* Slice: vi_jpeg_clk_enable:*/
/* JPEG encoder clock enable */
/* 1: processing mode */
/* 0: power safe */
#ifdef MRV_VI_JPEG_CLK_ENABLE
#endif /* MRV_VI_JPEG_CLK_ENABLE */

/* Slice: vi_srsz_clk_enable:*/
/* main resize clock enable */
/* 1: processing mode */
/* 0: power safe */
#ifdef MRV_VI_SRSZ_CLK_ENABLE
#endif /* MRV_VI_SRSZ_CLK_ENABLE */

/* Slice: vi_mrsz_clk_enable:*/
/* main resize clock enable */
/* 1: processing mode */
/* 0: power safe */
#ifdef MRV_VI_MRSZ_CLK_ENABLE
#endif /* MRV_VI_MRSZ_CLK_ENABLE */

/* Slice: vi_cp_clk_enable:*/
/* color processing clock enable */
/* 1: processing mode */
/* 0: power safe */
#ifdef MRV_VI_CP_CLK_ENABLE
#endif /* MRV_VI_CP_CLK_ENABLE */

/* Slice: vi_isp_clk_enable:*/
/* isp processing clock enable */
/* 1: processing mode */
/* 0: power safe */
#ifdef MRV_VI_ISP_CLK_ENABLE
#endif /* MRV_VI_ISP_CLK_ENABLE */

/*****************************************************************************/
/**
 * register: vi_ircl: Internal reset control register (0x0014)
 *
 *****************************************************************************/
/* Slice: vi_mipi_soft_rst:*/
/* MIPI Interface software reset */
/* 0: processing mode */
/* 1: reset state */
#ifdef MRV_VI_MIPI_SOFT_RST
#endif /* MRV_VI_MIPI_SOFT_RST */

/* Slice: vi_smia_soft_rst:*/
/* SMIA Interface software reset */
/* 0: processing mode */
/* 1: reset state */
#ifdef MRV_VI_SMIA_SOFT_RST
#endif /* MRV_VI_SMIA_SOFT_RST */

/* Slice: vi_simp_soft_rst:*/
/* Superimpose software reset */
/* 0: processing mode */
/* 1: reset state */
#ifdef MRV_VI_SIMP_SOFT_RST
#endif /* MRV_VI_SIMP_SOFT_RST */

/* Slice: vi_ie_soft_rst:*/
/* Image effect software reset */
/* 0: processing mode */
/* 1: reset state */
#ifdef MRV_VI_IE_SOFT_RST
#endif /* MRV_VI_IE_SOFT_RST */

/* Slice: vi_marvin_rst:*/
/* Soft reset of entire marvin */
/* 0: processing mode */
/* 1: reset state */
#ifdef MRV_VI_MARVIN_RST
#endif /* MRV_VI_MARVIN_RST */

/* Slice: vi_mi_soft_rst:*/
/* memory interface software reset */
/* 0: processing mode */
/* 1: reset state */
#ifdef MRV_VI_MI_SOFT_RST
#endif /* MRV_VI_MI_SOFT_RST */

/* Slice: vi_jpeg_soft_rst:*/
/* JPEG encoder software reset */
/* 0: processing mode */
/* 1: reset state */
#ifdef MRV_VI_JPEG_SOFT_RST
#endif /* MRV_VI_JPEG_SOFT_RST */

/* Slice: vi_srsz_soft_rst:*/
/* Self-picture resize software reset */
/* 0: processing mode */
/* 1: reset state */
#ifdef MRV_VI_SRSZ_SOFT_RST
#endif /* MRV_VI_SRSZ_SOFT_RST */

/* Slice: vi_mrsz_soft_rst:*/
/* Main-picture resize software reset */
/* 0: processing mode */
/* 1: reset state */
#ifdef MRV_VI_MRSZ_SOFT_RST
#endif /* MRV_VI_MRSZ_SOFT_RST */

/* Slice: vi_ycs_soft_rst:*/
/* y/c splitter software reset */
/* 0: processing mode */
/* 1: reset state */
#ifdef MRV_VI_YCS_SOFT_RST
#endif /* MRV_VI_YCS_SOFT_RST */

/* Slice: vi_cp_soft_rst:*/
/* color processing software reset */
/* 0: processing mode */
/* 1: reset state */
#ifdef MRV_VI_CP_SOFT_RST
#endif /* MRV_VI_CP_SOFT_RST */

/* Slice: vi_isp_soft_rst:*/
/* isp software reset */
/* 0: processing mode */
/* 1: reset state */
#ifdef MRV_VI_ISP_SOFT_RST
#endif /* MRV_VI_ISP_SOFT_RST */

/*****************************************************************************/
/**
 * register: vi_dpcl: Data path control register (0x0018)
 *
 *****************************************************************************/
/* Slice: vi_dma_spmux:*/
/* 0: data from camera interface to self resize */
/* 1: data from DMA read port to self resize */
#ifdef MRV_VI_DMA_SPMUX
#define MRV_VI_DMA_SPMUX_CAM                    0	/* 0: data from camera interface to self resize */
#define MRV_VI_DMA_SPMUX_DMA                    1	/* 1: data from DMA read port to self resize */
#endif /* MRV_VI_DMA_SPMUX */

/* Slice: vi_dma_iemux:*/
/* 0: data from camera interface to image effects */
/* 1: data from DMA read port to image effects */
#ifdef MRV_VI_DMA_IEMUX
#define MRV_VI_DMA_IEMUX_CAM                    0	/* 0: data from camera interface to image effects */
#define MRV_VI_DMA_IEMUX_DMA                    1	/* 1: data from DMA read port to image effects */
#endif /* MRV_VI_DMA_IEMUX */

/* Slice: if_select:*/
/* selects input interface */
/* 0: parallel interface */
/* 1: SMIA-interface */
/* 2: MIPI-interface */
#ifdef MRV_IF_SELECT
#define MRV_IF_SELECT_PAR                       0	/* 0: parallel interface */
#define MRV_IF_SELECT_SMIA                      1	/* 1: SMIA-interface */
#define MRV_IF_SELECT_MIPI                      2	/* 2: MIPI-interface */
#define MRV_IF_SELECT_HDR                       3	/* 2: HDR-interface */
#endif /* MRV_IF_SELECT */

/* Slice: vi_dma_switch:*/
/* DMA read data path selector */
/* 0: path to SPMUX */
/* 1: path to Superimpose */
/* 2: path to Image Effects */
/* 3: reserved (for path to JPEG)*/
/* 4..7: reserved */
#ifdef MRV_VI_DMA_SWITCH
#define MRV_VI_DMA_SWITCH_SELF                  0	/* 0: path to SPMUX */
#define MRV_VI_DMA_SWITCH_SIMP                  1	/* 1: path to Superimpose */
#define MRV_VI_DMA_SWITCH_IE                    2	/* 2: path to Image Effects */
#define MRV_VI_DMA_SWITCH_JPG                   3	/* 3: path to JPEG */
#define MRV_VI_DMA_SWITCH_ISP                   4	/* 4: path to ISP */
#endif /* MRV_VI_DMA_SWITCH */

/* Slice: vi_chan_mode:*/
/* Y/C splitter channel mode */
/* 0: disabled */
/* 1: main path and raw data mode */
/* 2: self path mode */
/* 3: main and self path mode */
#ifdef MRV_VI_CHAN_MODE
#define MRV_VI_CHAN_MODE_OFF                    0x00	/* 0: disabled */
#define MRV_VI_CHAN_MODE_Y                      0xFF	/* not supported */
#define MRV_VI_CHAN_MODE_MP_RAW                 0x01	/* 1: main path and raw data mode */
#define MRV_VI_CHAN_MODE_MP                     0x01	/* 1: main path and raw data mode */
#define MRV_VI_CHAN_MODE_SP                     0x02	/* 2: self path mode */
#define MRV_VI_CHAN_MODE_MP_SP                  0x03	/* 3: main and self path mode */
#define MRV_VI_CHAN_MODE_SP2                    0x04	/* 4: self2 path mode */
#define MRV_VI_CHAN_MODE_MP_SP2                 0x05	/* 5: main and self2 path mode */
#define MRV_VI_CHAN_MODE_SP_SP2                 0x06	/* 6: self and self2 path mode */
#define MRV_VI_CHAN_MODE_MP_SP_SP2              0x07	/* 7: main self and self2 path mode */

#endif /* MRV_VI_CHAN_MODE */

/* Slice: vi_mp_mux:*/
/* data path selector for main path */
/* 00: reserved (future: data from DMA read port to JPEG encoder)*/
/* 01: data from main resize to MI, uncompressed */
/* 10: data from main resize to JPEG encoder */
/* 11: reserved */
#ifdef MRV_VI_MP_MUX
#define MRV_VI_MP_MUX_JPGDIRECT                 0x00	/* 00: reserved (future: data from DMA read port to JPEG encoder) */
#define MRV_VI_MP_MUX_MP                        0x01	/* 01: data from main resize to MI, uncompressed */
#define MRV_VI_MP_MUX_RAW                       0x01	/*     (now also used for RAW data bypass) */
#define MRV_VI_MP_MUX_JPEG                      0x02	/* 10: data from main resize to JPEG encoder */
#endif /* MRV_VI_MP_MUX */

/*****************************************************************************/
/* Image Effects Registers                                                   */
/*****************************************************************************/

/*****************************************************************************/
/**
 * register: img_eff_ctrl: Global control register (0x0000)
 *
 *****************************************************************************/
/* Slice: full_range:*/
/* write 0: pixel value range according to BT.601 */
/* write 1: YCbCr full range 0...255 */
#ifdef MRV_IMGEFF_FULL_RANGE
#define MRV_IMGEFF_FULL_RANGE_FULL      1	/* 1: YCbCr full range 0...255 */
#define MRV_IMGEFF_FULL_RANGE_BT601     0	/* 0: pixel value range according to BT.601 */
#endif /* MRV_IMGEFF_FULL_RANGE */

/* Slice: cfg_upd:*/
/* write 0: nothing happens */
/* write 1: update shadow registers */
/* read: always 0 */
#ifdef MRV_IMGEFF_CFG_UPD
#define MRV_IMGEFF_CFG_UPD_NOTHING      0	/* 0: nothing happens */
#define MRV_IMGEFF_CFG_UPD_UPDATE       1	/* 1: update shadow registers */
#endif /* MRV_IMGEFF_CFG_UPD */

/* Slice: effect_mode:*/
/* effect mode */
/* 000: black & white effect (grayscale)*/
/* 001: negative effect */
/* 010: sepia effect */
/* 011: color selection effect */
/* 100: emboss effect */
/* 101: sketch effect */
/* 110: sharpen effect */
/* 111: reserved */
#ifdef MRV_IMGEFF_EFFECT_MODE
#define MRV_IMGEFF_EFFECT_MODE_GRAY      0	/* 000: black & white effect (grayscale) */
#define MRV_IMGEFF_EFFECT_MODE_NEGATIVE  1	/* 001: negative effect */
#define MRV_IMGEFF_EFFECT_MODE_SEPIA     2	/* 010: sepia effect */
#define MRV_IMGEFF_EFFECT_MODE_COLOR_SEL 3	/* 011: color selection effect */
#define MRV_IMGEFF_EFFECT_MODE_EMBOSS    4	/* 100: emboss effect */
#define MRV_IMGEFF_EFFECT_MODE_SKETCH    5	/* 101: sketch effect */
#define MRV_IMGEFF_EFFECT_MODE_SHARPEN   6	/* 110: sharpen effect */
#endif /* MRV_IMGEFF_EFFECT_MODE */

/* Slice: bypass_mode:*/
/* bypass mode */
/* 1: processing is activated */
/* 0: processing is deactivated, bypass mode is selected */
#ifdef MRV_IMGEFF_BYPASS_MODE
#define MRV_IMGEFF_BYPASS_MODE_PROCESS  1	/* 1: processing is activated */
#define MRV_IMGEFF_BYPASS_MODE_BYPASS   0	/* 0: processing is deactivated, bypass mode is selected */
#endif /* MRV_IMGEFF_BYPASS_MODE */

/*****************************************************************************/
/**
 * register: img_eff_color_sel: Color selection register (for
 *           color selection effect) (0x0004)
 *
 *****************************************************************************/
/* Slice: color_threshold:*/
/* Threshold value of the RGB colors for the color selection effect.*/
#ifdef MRV_IMGEFF_COLOR_THRESHOLD
#endif /* MRV_IMGEFF_COLOR_THRESHOLD */

/* Slice: color_selection:*/
/* Defining the maintained color:*/
/* 000: red green and blue */
/* 001: blue */
/* 010: green */
/* 011: green and blue */
/* 100: red */
/* 101: red and blue */
/* 110: red and green */
/* 111: red green and blue */
#ifdef MRV_IMGEFF_COLOR_SELECTION
#define MRV_IMGEFF_COLOR_SELECTION_RGB  0	/* 000: red green and blue */
#define MRV_IMGEFF_COLOR_SELECTION_B    1	/* 001: blue */
#define MRV_IMGEFF_COLOR_SELECTION_G    2	/* 010: green */
#define MRV_IMGEFF_COLOR_SELECTION_BG   3	/* 011: green and blue */
#define MRV_IMGEFF_COLOR_SELECTION_R    4	/* 100: red */
#define MRV_IMGEFF_COLOR_SELECTION_RB   5	/* 101: red and blue */
#define MRV_IMGEFF_COLOR_SELECTION_RG   6	/* 110: red and green */
#define MRV_IMGEFF_COLOR_SELECTION_BGR  7	/* 111: red green and blue */
#endif /* MRV_IMGEFF_COLOR_SELECTION */

/* Slice: emb_coef_21_en:*/
/* 0: entry not used (coefficient is zero)*/
/* 1: entry used */
#ifdef MRV_IMGEFF_EMB_COEF_21_EN
#endif /* MRV_IMGEFF_EMB_COEF_21_EN */

/* Slice: emb_coef_21:*/
/* second line, left entry of 3x3 emboss effect matrix, 2 bit for coefficient, one sign bit.*/
/* coefficients:*/
/* 000 (1), 001(2), 010(4), 011(8)*/
/* 100 (-1), 101(-2), 110(-4), 111(-8)*/
#ifdef MRV_IMGEFF_EMB_COEF_21
#define MRV_IMGEFF_EMB_COEF_21_ONE          0	/* 000 (1) */
#define MRV_IMGEFF_EMB_COEF_21_TWO          1	/* 001 (2) */
#define MRV_IMGEFF_EMB_COEF_21_FOUR         2	/* 010 (4) */
#define MRV_IMGEFF_EMB_COEF_21_EIGHT        3	/* 011 (8) */
#define MRV_IMGEFF_EMB_COEF_21_MIN_ONE      4	/* 100 (-1) */
#define MRV_IMGEFF_EMB_COEF_21_MIN_TWO      5	/* 101 (-2) */
#define MRV_IMGEFF_EMB_COEF_21_MIN_FOUR     6	/* 110 (-4) */
#define MRV_IMGEFF_EMB_COEF_21_MIN_EIGHT    8	/* 111 (-8) */
#endif /* MRV_IMGEFF_EMB_COEF_21 */

/* combination of value and enable bit */
#define MRV_IMGEFF_EMB_COEF_21_4
#define MRV_IMGEFF_EMB_COEF_21_4_MASK       0x0000F000
#define MRV_IMGEFF_EMB_COEF_21_4_SHIFT      12

/* Slice: emb_coef_13_en:*/
/* 0: entry not used (coefficient is zero)*/
/* 1: entry used */
#ifdef MRV_IMGEFF_EMB_COEF_13_EN
#endif /* MRV_IMGEFF_EMB_COEF_13_EN */

/* Slice: emb_coef_13:*/
/* first line, right entry of 3x3 emboss effect matrix, 2 bit for coefficient, one sign bit.*/
/* coefficients:*/
/* 000 (1), 001(2), 010(4), 011(8)*/
/* 100 (-1), 101(-2), 110(-4), 111(-8)*/
#ifdef MRV_IMGEFF_EMB_COEF_13
#define MRV_IMGEFF_EMB_COEF_13_ONE          0	/* 000 (1) */
#define MRV_IMGEFF_EMB_COEF_13_TWO          1	/* 001 (2) */
#define MRV_IMGEFF_EMB_COEF_13_FOUR         2	/* 010 (4) */
#define MRV_IMGEFF_EMB_COEF_13_EIGHT        3	/* 011 (8) */
#define MRV_IMGEFF_EMB_COEF_13_MIN_ONE      4	/* 100 (-1) */
#define MRV_IMGEFF_EMB_COEF_13_MIN_TWO      5	/* 101 (-2) */
#define MRV_IMGEFF_EMB_COEF_13_MIN_FOUR     6	/* 110 (-4) */
#define MRV_IMGEFF_EMB_COEF_13_MIN_EIGHT    8	/* 111 (-8) */
#endif /* MRV_IMGEFF_EMB_COEF_13 */

/* combination of value and enable bit */
#define MRV_IMGEFF_EMB_COEF_13_4
#define MRV_IMGEFF_EMB_COEF_13_4_MASK       0x00000F00
#define MRV_IMGEFF_EMB_COEF_13_4_SHIFT      8

/* Slice: emb_coef_12_en:*/
/* 0: entry not used (coefficient is zero)*/
/* 1: entry used */
#ifdef MRV_IMGEFF_EMB_COEF_12_EN
#endif /* MRV_IMGEFF_EMB_COEF_12_EN */

/* Slice: emb_coef_12:*/
/* first line, middle entry of 3x3 emboss effect matrix, 2 bit for coefficient, one sign bit.*/
/* coefficients:*/
/* 000 (1), 001(2), 010(4), 011(8)*/
/* 100 (-1), 101(-2), 110(-4), 111(-8)*/
#ifdef MRV_IMGEFF_EMB_COEF_12
#define MRV_IMGEFF_EMB_COEF_12_ONE          0	/* 000 (1) */
#define MRV_IMGEFF_EMB_COEF_12_TWO          1	/* 001 (2) */
#define MRV_IMGEFF_EMB_COEF_12_FOUR         2	/* 010 (4) */
#define MRV_IMGEFF_EMB_COEF_12_EIGHT        3	/* 011 (8) */
#define MRV_IMGEFF_EMB_COEF_12_MIN_ONE      4	/* 100 (-1) */
#define MRV_IMGEFF_EMB_COEF_12_MIN_TWO      5	/* 101 (-2) */
#define MRV_IMGEFF_EMB_COEF_12_MIN_FOUR     6	/* 110 (-4) */
#define MRV_IMGEFF_EMB_COEF_12_MIN_EIGHT    8	/* 111 (-8) */
#endif /* MRV_IMGEFF_EMB_COEF_12 */

/* combination of value and enable bit */
#define MRV_IMGEFF_EMB_COEF_12_4
#define MRV_IMGEFF_EMB_COEF_12_4_MASK       0x000000F0
#define MRV_IMGEFF_EMB_COEF_12_4_SHIFT      4

/* Slice: emb_coef_11_en:*/
/* 0: entry not used (coefficient is zero)*/
/* 1: entry used */
#ifdef MRV_IMGEFF_EMB_COEF_11_EN
#define MRV_IMGEFF_EMB_COEF_11_EN_ON        1
#define MRV_IMGEFF_EMB_COEF_11_EN_OFF       0
#endif /* MRV_IMGEFF_EMB_COEF_11_EN */

/* Slice: emb_coef_11:*/
/* first line, left entry of 3x3 emboss effect matrix, 2 bit for coefficient, one sign bit.*/
/* coefficients:*/
/* 000 (1), 001(2), 010(4), 011(8)*/
/* 100 (-1), 101(-2), 110(-4), 111(-8)*/
#ifdef MRV_IMGEFF_EMB_COEF_11
#define MRV_IMGEFF_EMB_COEF_11_ONE          0	/* 000 (1) */
#define MRV_IMGEFF_EMB_COEF_11_TWO          1	/* 001 (2) */
#define MRV_IMGEFF_EMB_COEF_11_FOUR         2	/* 010 (4) */
#define MRV_IMGEFF_EMB_COEF_11_EIGHT        3	/* 011 (8) */
#define MRV_IMGEFF_EMB_COEF_11_MIN_ONE      4	/* 100 (-1) */
#define MRV_IMGEFF_EMB_COEF_11_MIN_TWO      5	/* 101 (-2) */
#define MRV_IMGEFF_EMB_COEF_11_MIN_FOUR     6	/* 110 (-4) */
#define MRV_IMGEFF_EMB_COEF_11_MIN_EIGHT    8	/* 111 (-8) */
#endif /* MRV_IMGEFF_EMB_COEF_11 */

/* combination of value and enable bit */
#define MRV_IMGEFF_EMB_COEF_11_4
#define MRV_IMGEFF_EMB_COEF_11_4_MASK       0x0000000F
#define MRV_IMGEFF_EMB_COEF_11_4_SHIFT      0

/* Slice: emb_coef_32_en:*/
/* 0: entry not used (coefficient is zero)*/
/* 1: entry used */
#ifdef MRV_IMGEFF_EMB_COEF_32_EN
#endif /* MRV_IMGEFF_EMB_COEF_32_EN */

/* Slice: emb_coef_32:*/
/* first line, left entry of 3x3 emboss effect matrix, 2 bit for coefficient, one sign bit.*/
/* coefficients:*/
/* 000 (1), 001(2), 010(4), 011(8)*/
/* 100 (-1), 101(-2), 110(-4), 111(-8)*/
#ifdef MRV_IMGEFF_EMB_COEF_32
#define MRV_IMGEFF_EMB_COEF_32_ONE          0	/* 000 (1) */
#define MRV_IMGEFF_EMB_COEF_32_TWO          1	/* 001 (2) */
#define MRV_IMGEFF_EMB_COEF_32_FOUR         2	/* 010 (4) */
#define MRV_IMGEFF_EMB_COEF_32_EIGHT        3	/* 011 (8) */
#define MRV_IMGEFF_EMB_COEF_32_MIN_ONE      4	/* 100 (-1) */
#define MRV_IMGEFF_EMB_COEF_32_MIN_TWO      5	/* 101 (-2) */
#define MRV_IMGEFF_EMB_COEF_32_MIN_FOUR     6	/* 110 (-4) */
#define MRV_IMGEFF_EMB_COEF_32_MIN_EIGHT    8	/* 111 (-8) */
#endif /* MRV_IMGEFF_EMB_COEF_32 */

/* combination of value and enable bit */
#define MRV_IMGEFF_EMB_COEF_32_4
#define MRV_IMGEFF_EMB_COEF_32_4_MASK       0x0000F000
#define MRV_IMGEFF_EMB_COEF_32_4_SHIFT      12

/* Slice: emb_coef_31_en:*/
/* 0: entry not used (coefficient is zero)*/
/* 1: entry used */
#ifdef MRV_IMGEFF_EMB_COEF_31_EN
#endif /* MRV_IMGEFF_EMB_COEF_31_EN */

/* Slice: emb_coef_31:*/
/* first line, left entry of 3x3 emboss effect matrix, 2 bit for coefficient, one sign bit.*/
/* coefficients:*/
/* 000 (1), 001(2), 010(4), 011(8)*/
/* 100 (-1), 101(-2), 110(-4), 111(-8)*/
#ifdef MRV_IMGEFF_EMB_COEF_31
#define MRV_IMGEFF_EMB_COEF_31_ONE          0	/* 000 (1) */
#define MRV_IMGEFF_EMB_COEF_31_TWO          1	/* 001 (2) */
#define MRV_IMGEFF_EMB_COEF_31_FOUR         2	/* 010 (4) */
#define MRV_IMGEFF_EMB_COEF_31_EIGHT        3	/* 011 (8) */
#define MRV_IMGEFF_EMB_COEF_31_MIN_ONE      4	/* 100 (-1) */
#define MRV_IMGEFF_EMB_COEF_31_MIN_TWO      5	/* 101 (-2) */
#define MRV_IMGEFF_EMB_COEF_31_MIN_FOUR     6	/* 110 (-4) */
#define MRV_IMGEFF_EMB_COEF_31_MIN_EIGHT    8	/* 111 (-8) */
#endif /* MRV_IMGEFF_EMB_COEF_31 */

/* combination of value and enable bit */
#define MRV_IMGEFF_EMB_COEF_31_4
#define MRV_IMGEFF_EMB_COEF_31_4_MASK       0x00000F00
#define MRV_IMGEFF_EMB_COEF_31_4_SHIFT      8

/* Slice: emb_coef_23_en:*/
/* 0: entry not used (coefficient is zero)*/
/* 1: entry used */
#ifdef MRV_IMGEFF_EMB_COEF_23_EN
#endif /* MRV_IMGEFF_EMB_COEF_23_EN */

/* Slice: emb_coef_23:*/
/* first line, left entry of 3x3 emboss effect matrix, 2 bit for coefficient, one sign bit.*/
/* coefficients:*/
/* 000 (1), 001(2), 010(4), 011(8)*/
/* 100 (-1), 101(-2), 110(-4), 111(-8)*/
#ifdef MRV_IMGEFF_EMB_COEF_23
#define MRV_IMGEFF_EMB_COEF_23_ONE          0	/* 000 (1) */
#define MRV_IMGEFF_EMB_COEF_23_TWO          1	/* 001 (2) */
#define MRV_IMGEFF_EMB_COEF_23_FOUR         2	/* 010 (4) */
#define MRV_IMGEFF_EMB_COEF_23_EIGHT        3	/* 011 (8) */
#define MRV_IMGEFF_EMB_COEF_23_MIN_ONE      4	/* 100 (-1) */
#define MRV_IMGEFF_EMB_COEF_23_MIN_TWO      5	/* 101 (-2) */
#define MRV_IMGEFF_EMB_COEF_23_MIN_FOUR     6	/* 110 (-4) */
#define MRV_IMGEFF_EMB_COEF_23_MIN_EIGHT    8	/* 111 (-8) */
#endif /* MRV_IMGEFF_EMB_COEF_23 */

/* combination of value and enable bit */
#define MRV_IMGEFF_EMB_COEF_23_4
#define MRV_IMGEFF_EMB_COEF_23_4_MASK       0x000000F0
#define MRV_IMGEFF_EMB_COEF_23_4_SHIFT      4

/* Slice: emb_coef_22_en:*/
/* 0: entry not used (coefficient is zero)*/
/* 1: entry used */
#ifdef MRV_IMGEFF_EMB_COEF_22_EN
#endif /* MRV_IMGEFF_EMB_COEF_22_EN */

/* Slice: emb_coef_22:*/
/* first line, left entry of 3x3 emboss effect matrix, 2 bit for coefficient, one sign bit.*/
/* coefficients:*/
/* 000 (1), 001(2), 010(4), 011(8)*/
/* 100 (-1), 101(-2), 110(-4), 111(-8)*/
#ifdef MRV_IMGEFF_EMB_COEF_22
#define MRV_IMGEFF_EMB_COEF_22_ONE          0	/* 000 (1) */
#define MRV_IMGEFF_EMB_COEF_22_TWO          1	/* 001 (2) */
#define MRV_IMGEFF_EMB_COEF_22_FOUR         2	/* 010 (4) */
#define MRV_IMGEFF_EMB_COEF_22_EIGHT        3	/* 011 (8) */
#define MRV_IMGEFF_EMB_COEF_22_MIN_ONE      4	/* 100 (-1) */
#define MRV_IMGEFF_EMB_COEF_22_MIN_TWO      5	/* 101 (-2) */
#define MRV_IMGEFF_EMB_COEF_22_MIN_FOUR     6	/* 110 (-4) */
#define MRV_IMGEFF_EMB_COEF_22_MIN_EIGHT    8	/* 111 (-8) */
#endif /* MRV_IMGEFF_EMB_COEF_22 */

/* combination of value and enable bit */
#define MRV_IMGEFF_EMB_COEF_22_4
#define MRV_IMGEFF_EMB_COEF_22_4_MASK       0x0000000F
#define MRV_IMGEFF_EMB_COEF_22_4_SHIFT      0

/*****************************************************************************/
/**
 * register: img_eff_mat_3: 3x3 matrix coefficients for emboss(3) effect /
 *           sketch(1) effect (0x0010)
 *
 *****************************************************************************/
/* Slice: sket_coef_13_en:*/
/* 0: entry not used (coefficient is zero)*/
/* 1: entry used */
#ifdef MRV_IMGEFF_SKET_COEF_13_EN
#endif /* MRV_IMGEFF_SKET_COEF_13_EN */

/* Slice: sket_coef_13:*/
/* first line, right entry of 3x3 sketch effect matrix, 2 bit for coefficient, one sign bit.*/
/* coefficients:*/
/* 000 (1), 001(2), 010(4), 011(8)*/
/* 100 (-1), 101(-2), 110(-4), 111(-8)*/
#ifdef MRV_IMGEFF_SKET_COEF_13
#define MRV_IMGEFF_SKET_COEF_13_ONE         0	/* 000 (1) */
#define MRV_IMGEFF_SKET_COEF_13_TWO         1	/* 001 (2) */
#define MRV_IMGEFF_SKET_COEF_13_FOUR        2	/* 010 (4) */
#define MRV_IMGEFF_SKET_COEF_13_EIGHT       3	/* 011 (8) */
#define MRV_IMGEFF_SKET_COEF_13_MIN_ONE     4	/* 100 (-1) */
#define MRV_IMGEFF_SKET_COEF_13_MIN_TWO     5	/* 101 (-2) */
#define MRV_IMGEFF_SKET_COEF_13_MIN_FOUR    6	/* 110 (-4) */
#define MRV_IMGEFF_SKET_COEF_13_MIN_EIGHT   8	/* 111 (-8) */
#endif /* MRV_IMGEFF_SKET_COEF_13 */

/* combination of value and enable bit */
#define MRV_IMGEFF_SKET_COEF_13_4
#define MRV_IMGEFF_SKET_COEF_13_4_MASK      0x0000F000
#define MRV_IMGEFF_SKET_COEF_13_4_SHIFT     12

/* Slice: sket_coef_12_en:*/
/* 0: entry not used (coefficient is zero)*/
/* 1: entry used */
#ifdef MRV_IMGEFF_SKET_COEF_12_EN
#endif /* MRV_IMGEFF_SKET_COEF_13_EN */

/* Slice: sket_coef_12:*/
/* first line, middle entry of 3x3 sketch effect matrix, 2 bit for coefficient, one sign bit.*/
/* coefficients:*/
/* 000 (1), 001(2), 010(4), 011(8)*/
/* 100 (-1), 101(-2), 110(-4), 111(-8)*/
#ifdef MRV_IMGEFF_SKET_COEF_12
#define MRV_IMGEFF_SKET_COEF_12_ONE         0	/* 000 (1) */
#define MRV_IMGEFF_SKET_COEF_12_TWO         1	/* 001 (2) */
#define MRV_IMGEFF_SKET_COEF_12_FOUR        2	/* 010 (4) */
#define MRV_IMGEFF_SKET_COEF_12_EIGHT       3	/* 011 (8) */
#define MRV_IMGEFF_SKET_COEF_12_MIN_ONE     4	/* 100 (-1) */
#define MRV_IMGEFF_SKET_COEF_12_MIN_TWO     5	/* 101 (-2) */
#define MRV_IMGEFF_SKET_COEF_12_MIN_FOUR    6	/* 110 (-4) */
#define MRV_IMGEFF_SKET_COEF_12_MIN_EIGHT   8	/* 111 (-8) */
#endif /* MRV_IMGEFF_SKET_COEF_12 */

/* combination of value and enable bit */
#define MRV_IMGEFF_SKET_COEF_12_4
#define MRV_IMGEFF_SKET_COEF_12_4_MASK      0x00000F00
#define MRV_IMGEFF_SKET_COEF_12_4_SHIFT     8

/* Slice: sket_coef_11_en:*/
/* 0: entry not used (coefficient is zero)*/
/* 1: entry used */
#ifdef MRV_IMGEFF_SKET_COEF_11_EN
#endif /* MRV_IMGEFF_SKET_COEF_13_EN */

/* Slice: sket_coef_11:*/
/* first line, middle entry of 3x3 sketch effect matrix, 2 bit for coefficient, one sign bit.*/
/* coefficients:*/
/* 000 (1), 001(2), 010(4), 011(8)*/
/* 100 (-1), 101(-2), 110(-4), 111(-8)*/
#ifdef MRV_IMGEFF_SKET_COEF_11
#define MRV_IMGEFF_SKET_COEF_11_ONE         0	/* 000 (1) */
#define MRV_IMGEFF_SKET_COEF_11_TWO         1	/* 001 (2) */
#define MRV_IMGEFF_SKET_COEF_11_FOUR        2	/* 010 (4) */
#define MRV_IMGEFF_SKET_COEF_11_EIGHT       3	/* 011 (8) */
#define MRV_IMGEFF_SKET_COEF_11_MIN_ONE     4	/* 100 (-1) */
#define MRV_IMGEFF_SKET_COEF_11_MIN_TWO     5	/* 101 (-2) */
#define MRV_IMGEFF_SKET_COEF_11_MIN_FOUR    6	/* 110 (-4) */
#define MRV_IMGEFF_SKET_COEF_11_MIN_EIGHT   8	/* 111 (-8) */
#endif /* MRV_IMGEFF_SKET_COEF_11 */

/* combination of value and enable bit */
#define MRV_IMGEFF_SKET_COEF_11_4
#define MRV_IMGEFF_SKET_COEF_11_4_MASK      0x000000F0
#define MRV_IMGEFF_SKET_COEF_11_4_SHIFT     4

/* Slice: emb_coef_33_en:*/
/* 0: entry not used (coefficient is zero)*/
/* 1: entry used */
#ifdef MRV_IMGEFF_EMB_COEF_33_EN
#endif /* MRV_IMGEFF_EMB_COEF_33_EN */

/* Slice: emb_coef_33:*/
/* first line, left entry of 3x3 emboss effect matrix, 2 bit for coefficient, one sign bit.*/
/* coefficients:*/
/* 000 (1), 001(2), 010(4), 011(8)*/
/* 100 (-1), 101(-2), 110(-4), 111(-8)*/
#ifdef MRV_IMGEFF_EMB_COEF_3
#define MRV_IMGEFF_EMB_COEF_33_ONE          0	/* 000 (1) */
#define MRV_IMGEFF_EMB_COEF_33_TWO          1	/* 001 (2) */
#define MRV_IMGEFF_EMB_COEF_33_FOUR         2	/* 010 (4) */
#define MRV_IMGEFF_EMB_COEF_33_EIGHT        3	/* 011 (8) */
#define MRV_IMGEFF_EMB_COEF_33_MIN_ONE      4	/* 100 (-1) */
#define MRV_IMGEFF_EMB_COEF_33_MIN_TWO      5	/* 101 (-2) */
#define MRV_IMGEFF_EMB_COEF_33_MIN_FOUR     6	/* 110 (-4) */
#define MRV_IMGEFF_EMB_COEF_33_MIN_EIGHT    8	/* 111 (-8) */
#endif /* MRV_IMGEFF_EMB_COEF_33 */

/* combination of value and enable bit */
#define MRV_IMGEFF_EMB_COEF_33_4
#define MRV_IMGEFF_EMB_COEF_33_4_MASK       0x0000000F
#define MRV_IMGEFF_EMB_COEF_33_4_SHIFT      0

/*****************************************************************************/
/**
 * register: img_eff_mat_4: 3x3 matrix coefficients for sketch effect (2)
 *           (0x0014)
 *
 *****************************************************************************/
/* Slice: sket_coef_31_en:*/
/* 0: entry not used (coefficient is zero)*/
/* 1: entry used */
#ifdef MRV_IMGEFF_SKET_COEF_31_EN
#endif /* MRV_IMGEFF_SKET_COEF_31_EN */

/* Slice: sket_coef_31:*/
/* first line, middle entry of 3x3 sketch effect matrix, 2 bit for coefficient, one sign bit.*/
/* coefficients:*/
/* 000 (1), 001(2), 010(4), 011(8)*/
/* 100 (-1), 101(-2), 110(-4), 111(-8)*/
#ifdef MRV_IMGEFF_SKET_COEF_31
#define MRV_IMGEFF_SKET_COEF_31_ONE         0	/* 000 (1) */
#define MRV_IMGEFF_SKET_COEF_31_TWO         1	/* 001 (2) */
#define MRV_IMGEFF_SKET_COEF_31_FOUR        2	/* 010 (4) */
#define MRV_IMGEFF_SKET_COEF_31_EIGHT       3	/* 011 (8) */
#define MRV_IMGEFF_SKET_COEF_31_MIN_ONE     4	/* 100 (-1) */
#define MRV_IMGEFF_SKET_COEF_31_MIN_TWO     5	/* 101 (-2) */
#define MRV_IMGEFF_SKET_COEF_31_MIN_FOUR    6	/* 110 (-4) */
#define MRV_IMGEFF_SKET_COEF_31_MIN_EIGHT   8	/* 111 (-8) */
#endif /* MRV_IMGEFF_SKET_COEF_31 */

/* combination of value and enable bit */
#define MRV_IMGEFF_SKET_COEF_31_4
#define MRV_IMGEFF_SKET_COEF_31_4_MASK      0x0000F000
#define MRV_IMGEFF_SKET_COEF_31_4_SHIFT     12

/* Slice: sket_coef_23_en:*/
/* 0: entry not used (coefficient is zero)*/
/* 1: entry used */
#ifdef MRV_IMGEFF_SKET_COEF_23_EN
#endif /* MRV_IMGEFF_SKET_COEF_23_EN */

/* Slice: sket_coef_23:*/
/* first line, middle entry of 3x3 sketch effect matrix, 2 bit for coefficient, one sign bit.*/
/* coefficients:*/
/* 000 (1), 001(2), 010(4), 011(8)*/
/* 100 (-1), 101(-2), 110(-4), 111(-8)*/
#ifdef MRV_IMGEFF_SKET_COEF_23
#define MRV_IMGEFF_SKET_COEF_23_ONE         0	/* 000 (1) */
#define MRV_IMGEFF_SKET_COEF_23_TWO         1	/* 001 (2) */
#define MRV_IMGEFF_SKET_COEF_23_FOUR        2	/* 010 (4) */
#define MRV_IMGEFF_SKET_COEF_23_EIGHT       3	/* 011 (8) */
#define MRV_IMGEFF_SKET_COEF_23_MIN_ONE     4	/* 100 (-1) */
#define MRV_IMGEFF_SKET_COEF_23_MIN_TWO     5	/* 101 (-2) */
#define MRV_IMGEFF_SKET_COEF_23_MIN_FOUR    6	/* 110 (-4) */
#define MRV_IMGEFF_SKET_COEF_23_MIN_EIGHT   8	/* 111 (-8) */
#endif /* MRV_IMGEFF_SKET_COEF_23 */

/* combination of value and enable bit */
#define MRV_IMGEFF_SKET_COEF_23_4
#define MRV_IMGEFF_SKET_COEF_23_4_MASK      0x00000F00
#define MRV_IMGEFF_SKET_COEF_23_4_SHIFT     8

/* Slice: sket_coef_22_en:*/
/* 0: entry not used (coefficient is zero)*/
/* 1: entry used */
#ifdef MRV_IMGEFF_SKET_COEF_22_EN
#endif /* MRV_IMGEFF_SKET_COEF_22_EN */

/* Slice: sket_coef_22:*/
/* first line, middle entry of 3x3 sketch effect matrix, 2 bit for coefficient, one sign bit.*/
/* coefficients:*/
/* 000 (1), 001(2), 010(4), 011(8)*/
/* 100 (-1), 101(-2), 110(-4), 111(-8)*/
#ifdef MRV_IMGEFF_SKET_COEF_22
#define MRV_IMGEFF_SKET_COEF_22_ONE         0	/* 000 (1) */
#define MRV_IMGEFF_SKET_COEF_22_TWO         1	/* 001 (2) */
#define MRV_IMGEFF_SKET_COEF_22_FOUR        2	/* 010 (4) */
#define MRV_IMGEFF_SKET_COEF_22_EIGHT       3	/* 011 (8) */
#define MRV_IMGEFF_SKET_COEF_22_MIN_ONE     4	/* 100 (-1) */
#define MRV_IMGEFF_SKET_COEF_22_MIN_TWO     5	/* 101 (-2) */
#define MRV_IMGEFF_SKET_COEF_22_MIN_FOUR    6	/* 110 (-4) */
#define MRV_IMGEFF_SKET_COEF_22_MIN_EIGHT   8	/* 111 (-8) */
#endif /* MRV_IMGEFF_SKET_COEF_22 */

/* combination of value and enable bit */
#define MRV_IMGEFF_SKET_COEF_22_4
#define MRV_IMGEFF_SKET_COEF_22_4_MASK      0x000000F0
#define MRV_IMGEFF_SKET_COEF_22_4_SHIFT     4

/* Slice: sket_coef_21_en:*/
/* 0: entry not used (coefficient is zero)*/
/* 1: entry used */
#ifdef MRV_IMGEFF_SKET_COEF_21_EN
#endif /* MRV_IMGEFF_SKET_COEF_21_EN */

/* Slice: sket_coef_21:*/
/* first line, middle entry of 3x3 sketch effect matrix, 2 bit for coefficient, one sign bit.*/
/* coefficients:*/
/* 000 (1), 001(2), 010(4), 011(8)*/
/* 100 (-1), 101(-2), 110(-4), 111(-8)*/
#ifdef MRV_IMGEFF_SKET_COEF_21
#define MRV_IMGEFF_SKET_COEF_21_ONE         0	/* 000 (1) */
#define MRV_IMGEFF_SKET_COEF_21_TWO         1	/* 001 (2) */
#define MRV_IMGEFF_SKET_COEF_21_FOUR        2	/* 010 (4) */
#define MRV_IMGEFF_SKET_COEF_21_EIGHT       3	/* 011 (8) */
#define MRV_IMGEFF_SKET_COEF_21_MIN_ONE     4	/* 100 (-1) */
#define MRV_IMGEFF_SKET_COEF_21_MIN_TWO     5	/* 101 (-2) */
#define MRV_IMGEFF_SKET_COEF_21_MIN_FOUR    6	/* 110 (-4) */
#define MRV_IMGEFF_SKET_COEF_21_MIN_EIGHT   8	/* 111 (-8) */
#endif /* MRV_IMGEFF_SKET_COEF_21 */

/* combination of value and enable bit */
#define MRV_IMGEFF_SKET_COEF_21_4
#define MRV_IMGEFF_SKET_COEF_21_4_MASK      0x0000000F
#define MRV_IMGEFF_SKET_COEF_21_4_SHIFT     0

/*****************************************************************************/
/**
 * register: img_eff_mat_5: 3x3 matrix coefficients for sketch effect (3)
 *           (0x0018)
 *
 *****************************************************************************/
/* Slice: sket_coef_33_en:*/
/* 0: entry not used (coefficient is zero)*/
/* 1: entry used */
#ifdef MRV_IMGEFF_SKET_COEF_33_EN
#endif /* MRV_IMGEFF_SKET_COEF_33_EN */

/* Slice: sket_coef_33:*/
/* third line, right entry of 3x3 sketch effect matrix, 2 bit for coefficient, one sign bit.*/
/* coefficients:*/
/* 000 (1), 001(2), 010(4), 011(8)*/
/* 100 (-1), 101(-2), 110(-4), 111(-8)*/
#ifdef MRV_IMGEFF_SKET_COEF_33
#define MRV_IMGEFF_SKET_COEF_33_ONE          0	/* 000 (1) */
#define MRV_IMGEFF_SKET_COEF_33_TWO          1	/* 001 (2) */
#define MRV_IMGEFF_SKET_COEF_33_FOUR         2	/* 010 (4) */
#define MRV_IMGEFF_SKET_COEF_33_EIGHT        3	/* 011 (8) */
#define MRV_IMGEFF_SKET_COEF_33_MIN_ONE      4	/* 100 (-1) */
#define MRV_IMGEFF_SKET_COEF_33_MIN_TWO      5	/* 101 (-2) */
#define MRV_IMGEFF_SKET_COEF_33_MIN_FOUR     6	/* 110 (-4) */
#define MRV_IMGEFF_SKET_COEF_33_MIN_EIGHT    8	/* 111 (-8) */
#endif /* MRV_IMGEFF_SKET_COEF_33 */

/* combination of value and enable bit */
#define MRV_IMGEFF_SKET_COEF_33_4
#define MRV_IMGEFF_SKET_COEF_33_4_MASK 0x000000F0
#define MRV_IMGEFF_SKET_COEF_33_4_SHIFT 4

/* Slice: sket_coef_32_en:*/
/* 0: entry not used (coefficient is zero)*/
/* 1: entry used */
#ifdef MRV_IMGEFF_SKET_COEF_32_EN
#endif /* MRV_IMGEFF_SKET_COEF_32_EN */

/* Slice: sket_coef_32:*/
/* third line, right entry of 3x3 sketch effect matrix, 2 bit for coefficient, one sign bit.*/
/* coefficients:*/
/* 000 (1), 001(2), 010(4), 011(8)*/
/* 100 (-1), 101(-2), 110(-4), 111(-8)*/
#ifdef MRV_IMGEFF_SKET_COEF_32
#define MRV_IMGEFF_SKET_COEF_32_ONE          0	/* 000 (1) */
#define MRV_IMGEFF_SKET_COEF_32_TWO          1	/* 001 (2) */
#define MRV_IMGEFF_SKET_COEF_32_FOUR         2	/* 010 (4) */
#define MRV_IMGEFF_SKET_COEF_32_EIGHT        3	/* 011 (8) */
#define MRV_IMGEFF_SKET_COEF_32_MIN_ONE      4	/* 100 (-1) */
#define MRV_IMGEFF_SKET_COEF_32_MIN_TWO      5	/* 101 (-2) */
#define MRV_IMGEFF_SKET_COEF_32_MIN_FOUR     6	/* 110 (-4) */
#define MRV_IMGEFF_SKET_COEF_32_MIN_EIGHT    8	/* 111 (-8) */
#endif /* MRV_IMGEFF_SKET_COEF_32 */

/* combination of value and enable bit */
#define MRV_IMGEFF_SKET_COEF_32_4
#define MRV_IMGEFF_SKET_COEF_32_4_MASK 0x0000000F
#define MRV_IMGEFF_SKET_COEF_32_4_SHIFT 0

/* valid for all coeffiecient definitions */
#define MRV_IMGEFF_COEF
#define MRV_IMGEFF_COEF_ONE                  0U
#define MRV_IMGEFF_COEF_TWO                  1U	/* 001: (2) */
#define MRV_IMGEFF_COEF_FOUR                 2U	/* 010: (4) */
#define MRV_IMGEFF_COEF_EIGHT                3U	/* 011: (8) */
#define MRV_IMGEFF_COEF_MIN_ONE              4U	/* 100: (-1) */
#define MRV_IMGEFF_COEF_MIN_TWO              5U	/* 101: (-2) */
#define MRV_IMGEFF_COEF_MIN_FOUR             6U	/* 110: (-4) */
#define MRV_IMGEFF_COEF_MIN_EIGHT            7U	/* 111: (-8) */

#define MRV_IMGEFF_COEF_ON                   1U	/* 1: coefficient enabled */
#define MRV_IMGEFF_COEF_OFF                  0U	/* 0: coefficient disabled */
#define MRV_IMGEFF_COEF_SHIFT                3U	/* shift for enable bit */

/*****************************************************************************/
/**
 * register: img_eff_tint: Chrominance increment values of a tint
 *           (used for sepia effect) (0x001c)
 *
 *****************************************************************************/
/* Slice: incr_cr:*/
/* Cr increment value of a tint. 7 bits for value, 1 sign bit.*/
/* Default tint is R=162 G=138 B=101, which is used for the sepia effect. See below for the calculation of the entries.*/
#ifdef MRV_IMGEFF_INCR_CR
#endif /* MRV_IMGEFF_INCR_CR */

/* Slice: incr_cb:*/
/* Cb increment value of a tint. 7 bits for value, 1 sign bit.*/
/* Default tint is R=162 G=138 B=101, which is used for the sepia effect. See below for the calculation of the entries.*/
#ifdef MRV_IMGEFF_INCR_CB
#endif /* MRV_IMGEFF_INCR_CB */

/*****************************************************************************/
/**
 * register: img_eff_ctrl_shd: Shadow register for control register (0x0020)
 *
 *****************************************************************************/
/* Slice: effect_mode_shd:*/
/* effect mode */
/* 000: black & white effect (grayscale)*/
/* 001: negative effect */
/* 010: sepia effect */
/* 011: color selection effect */
/* 100: emboss effect */
/* 101: sketch effect */
/* 110-111: not used */
#ifdef MRV_IMGEFF_EFFECT_MODE_SHD
#define MRV_IMGEFF_EFFECT_MODE_SHD_GRAY         0	/* 000: black & white effect (grayscale) */
#define MRV_IMGEFF_EFFECT_MODE_SHD_NEGATIVE     1	/* 001: negative effect */
#define MRV_IMGEFF_EFFECT_MODE_SHD_SEPIA        2	/* 010: sepia effect */
#define MRV_IMGEFF_EFFECT_MODE_SHD_COLOR_SEL    3	/* 011: color selection effect */
#define MRV_IMGEFF_EFFECT_MODE_SHD_EMBOSS       4	/* 100: emboss effect */
#define MRV_IMGEFF_EFFECT_MODE_SHD_SKETCH       5	/* 101: sketch effect */
#define MRV_IMGEFF_EFFECT_MODE_SHD_SHARPEN      6	/* 110: sharpen effect */
#endif /* MRV_IMGEFF_EFFECT_MODE_SHD */

/*****************************************************************************/
/* Super Impose Registers                                                    */
/*****************************************************************************/

/*****************************************************************************/
/**
 * register: super_imp_ctrl: Global control register (0x0000)
 *
 *****************************************************************************/
/* Slice: transparency_mode:*/
/* transparency mode */
/* 1: transparency mode disabled */
/* 0: transparency mode enabled */
#ifdef MRV_SI_TRANSPARENCY_MODE
#define MRV_SI_TRANSPARENCY_MODE_DISABLED       1	/* 1: transparency mode disabled */
#define MRV_SI_TRANSPARENCY_MODE_ENABLED        0	/* 0: transparency mode enabled */
#endif /* MRV_SI_TRANSPARENCY_MODE */

/* Slice: ref_image:*/
/* Define the reference image */
/* 1: superimpose bitmap from main memory */
/* 0: image from the Image Effect module */
/* Note: the reference image defines the size of the output image */
#ifdef MRV_SI_REF_IMAGE
#define MRV_SI_REF_IMAGE_MEM                    1	/* 1: superimpose bitmap from main memory */
#define MRV_SI_REF_IMAGE_IE                     0	/* 0: image from the Image Effect module */
#endif /* MRV_SI_REF_IMAGE */

/* Slice: bypass_mode:*/
/* bypass mode */
/* 1: processing is activated */
/* 0: processing is deactivated, bypass mode is selected */
#ifdef MRV_SI_BYPASS_MODE
#define MRV_SI_BYPASS_MODE_PROCESS              1	/* 1: processing is activated */
#define MRV_SI_BYPASS_MODE_BYPASS               0	/* 0: processing is deactivated, bypass mode is selected */
#endif /* MRV_IMGEFF_BYPASS_MODE */

/*****************************************************************************/
/**
 * register: super_imp_offset_x: Offset x register (0x0004)
 *
 *****************************************************************************/
/* Slice: offset_x:*/
/* Offset X */
/* Note: the bit 0 is don't care (write 1 doesn't have any effect, the read access always gives 0)*/
/* Note: the offset_x is positive and refers to the reference image */
#ifdef MRV_SI_OFFSET_X
#endif /*  MRV_SI_OFFSET_X */

/*****************************************************************************/
/**
 * register: super_imp_offset_y: Offset y register (0x0008)
 *
 *****************************************************************************/
/* Slice: offset_y:*/
/* Offset Y */
/* Note: the offset_y is positive and refers to the reference image */
#ifdef MRV_SI_OFFSET_Y
#endif /*  MRV_SI_OFFSET_Y */

/*****************************************************************************/
/**
 * register: super_imp_color_y: Y component of transparent key color (0x000c)
 *
 *****************************************************************************/
/* Slice: y_comp:*/
/* Y component of transparent key color */
#ifdef MRV_SI_Y_COMP
#endif /* MRV_SI_Y_COMP */

/*****************************************************************************/
/**
 * register: super_imp_color_cb: Cb component of transparent key color (0x0010)
 *
 *****************************************************************************/
/* Slice: cb_comp:*/
/* Cb component of transparent key color */
#ifdef MRV_SI_CB_COMP
#endif /* MRV_SI_CB_COMP */

/*****************************************************************************/
/**
 * register: super_imp_color_cr: Cr component of transparent key color (0x0014)
 *
 *****************************************************************************/
/* Slice: cr_comp:*/
/* Cr component of transparent key color */
#ifdef MRV_SI_CR_COMP
#endif /* MRV_SI_CR_COMP */

/*****************************************************************************/
/* ISP Registers                                                             */
/*****************************************************************************/

/*****************************************************************************/
/**
 * register: isp_ctrl: global control register (0x0000)
 *
 *****************************************************************************/
/* Slice: ISP_DPF_RAW_OUT */
/*! Slice MRV_ISP_DPF_RAW_OUT:*/
/*! 0: DPF RAW OUT is disable */
/*! 1: DPF RAW OUT is enable */
#ifdef ISP_DPF_RAW
#ifdef MRV_ISP_DPF_RAW_OUT
#define MRV_ISP_DPF_RAW_OUT_DISABLE            0	/* 0: DPF raw out is disable */
#define MRV_ISP_DPF_RAW_OUT_ENABLE             1	/* 1: DPF raw out is enable */
#endif
#endif
/* Slice: ISP_CSM_C_RANGE:*/
/* Color Space Matrix chrominance clipping range for ISP output */
/* 0: CbCr range 64..960 (16..240) according to ITU-R BT.601 standard */
/* 1: full UV range 0..1023 (0..255)*/
/* Numbers in brackets are for 8 bit resolution.*/
#ifdef MRV_ISP_ISP_CSM_C_RANGE
#define MRV_ISP_ISP_CSM_C_RANGE_BT601           0	/* 0: CbCr range 64..960 (16..240) according to ITU-R BT.601 standard */
#define MRV_ISP_ISP_CSM_C_RANGE_FULL            1	/* 1: full UV range 0..1023 (0..255) */
#endif /* MRV_ISP_ISP_CSM_C_RANGE */

/* Slice: ISP_CSM_Y_RANGE:*/
/* Color Space Matrix luminance clipping range for ISP output */
/* 0: Y range 64..940 (16..235) according to ITU-R BT.601 standard */
/* 1: full Y range 0..1023 (0..255)*/
/* Numbers in brackets are for 8 bit resolution.*/
#ifdef MRV_ISP_ISP_CSM_Y_RANGE
#define MRV_ISP_ISP_CSM_Y_RANGE_BT601           0	/* 0: Y range 64..940 (16..235) according to ITU-R BT.601 standard */
#define MRV_ISP_ISP_CSM_Y_RANGE_FULL            1	/* 1: full Y range 0..1023 (0..255) */
#endif /* MRV_ISP_ISP_CSM_Y_RANGE */

/* Slice: ISP_FLASH_MODE:*/
/* 0: sensor interface works independently from flash control unit */
/* 1: one frame is captured when signaled by flash control unit */
#ifdef MRV_ISP_ISP_FLASH_MODE
#define MRV_ISP_ISP_FLASH_MODE_INDEP            0	/* 0: sensor interface works independently from flash control unit */
#define MRV_ISP_ISP_FLASH_MODE_SYNC             1	/* 1: one frame is captured when signaled by flash control unit */
#endif /* MRV_ISP_ISP_FLASH_MODE */

/* Slice: ISP_GAMMA_OUT_ENABLE:*/
/* gamma ON/OFF */
#ifdef MRV_ISP_ISP_GAMMA_OUT_ENABLE
#endif /* MRV_ISP_ISP_GAMMA_OUT_ENABLE */

/* Slice: ISP_GEN_CFG_UPD:*/
/* generate vsynced config shadow signal at the output, write only */
#ifdef MRV_ISP_ISP_GEN_CFG_UPD
#endif /* MRV_ISP_ISP_GEN_CFG_UPD */

/* Slice: ISP_CFG_UPD:*/
/* immediate configure internal shadow registers, write only */
#ifdef MRV_ISP_ISP_CFG_UPD
#endif /* MRV_ISP_ISP_CFG_UPD */

/* Slice: ISP_AE_ENABLE:*/
/* auto exposure ON/OFF */
#ifdef MRV_ISP_ISP_AE_ENABLE
#endif /* MRV_ISP_ISP_AE_ENABLE */

/* Slice: ISP_AWB_ENABLE:*/
/* auto white balance ON/OFF */
#ifdef MRV_ISP_ISP_AWB_ENABLE
#endif /* MRV_ISP_ISP_AWB_ENABLE */

/* Slice: ISP_GAMMA_IN_ENABLE:*/
/* Sensor De-gamma ON/OFF */
#ifdef MRV_ISP_ISP_GAMMA_IN_ENABLE
#define MRV_ISP_ISP_GAMMA_IN_ENABLE_ON          1U
#define MRV_ISP_ISP_GAMMA_IN_ENABLE_OFF         0U
#endif /* MRV_ISP_ISP_GAMMA_IN_ENABLE */

/* Slice: ISP_INFORM_ENABLE:*/
/* input block ON/OFF (frame-synced on)*/
#ifdef MRV_ISP_ISP_INFORM_ENABLE
#endif /* MRV_ISP_ISP_INFORM_ENABLE */

/* Slice: ISP_MODE:*/
/* 000: RAW picture with BT.601 sync (ISP bypass)*/
/* 001: ITU-R BT.656 (YUV with embedded sync)*/
/* 010: ITU-R BT.601 (YUV input with H and Vsync signals)*/
/* 011: Bayer RGB processing with H and Vsync signals */
/* 100: data mode (ISP bypass, sync signals interpreted as data enable)*/
/* 101: Bayer RGB processing with BT.656 synchronization */
/* 110: RAW picture with ITU-R BT.656 synchronization (ISP bypass)*/
/* 111: reserved */
 /**/
/* Side effect:*/
/* If RAW, BT.601, BT.656, or data mode is selected, the clock of the */
/* ISP SRAMs (ISP line buffer, Lens Shading, Bad Pixel) is switched off.*/
/* Only in Bayer RGB mode the clock to the SRAMs is enabled. This */
/* further reduces power consumption.*/
#ifdef MRV_ISP_ISP_MODE
#define MRV_ISP_ISP_MODE_RAW                    0	/* 000 - RAW picture with BT.601 sync (ISP bypass) */
#define MRV_ISP_ISP_MODE_656                    1	/* 001 - ITU-R BT.656 (YUV with embedded sync) */
#define MRV_ISP_ISP_MODE_601                    2	/* 010 - ITU-R BT.601 (YUV input with H and Vsync signals) */
#define MRV_ISP_ISP_MODE_RGB                    3	/* 011 - Bayer RGB processing with H and Vsync signals */
#define MRV_ISP_ISP_MODE_DATA                   4	/* 100 - data mode (ISP bypass, sync signals interpreted as data enable) */
#define MRV_ISP_ISP_MODE_RGB656                 5	/* 101 - Bayer RGB processing with BT.656 synchronization */
#define MRV_ISP_ISP_MODE_RAW656                 6	/* 110 - RAW picture with ITU-R BT.656 synchronization (ISP bypass) */
#endif /* MRV_ISP_ISP_MODE */
/* Slice: ISP_ENABLE:*/
/* MANUAL ON/OFF (controls output formatter, framesynced)*/
#ifdef MRV_ISP_ISP_ENABLE
#endif /* MRV_ISP_ISP_ENABLE */
/*****************************************************************************/
/**
 * register: isp_acq_prop: ISP acquisition properties (0x0004)
 *
 *****************************************************************************/
#ifdef ISP_DVP_PINMAPPING
/*! Slice: MRV_ISP_DVP_INPUT_PIN_MAPPING */
/*! Bit Mapping for LSB to MSP for ISPNano.*/
/*! 3'b000: normal 12-bit external interface */
/*! 3'b001: mapping low 10 bit to high 10 bits, append 2 zeros as LSBs.*/
/*! 3'b010: mapping low 8 bit to high 8 bits, append 4 zeros as LSBs.*/
/*! 3'b011: mapping middle 8 bit to high 8 bits, append 4 zeros as LSBs.*/
/*! 3'b100..3'b111: rsvd */
#ifdef MRV_ISP_DVP_INPUT_PIN_MAPPING
#define MRV_ISP_DVP_INPUT_PIN_MAPPING_12TO12     0
#define MRV_ISP_DVP_INPUT_PIN_MAPPING_L10TOH10   1
#define MRV_ISP_DVP_INPUT_PIN_MAPPING_L8TOH8     2
#define MRV_ISP_DVP_INPUT_PIN_MAPPING_M8TOH8     3
#endif
#endif
/*! Slice: DMA_YUV_SELECTION */
/*! 0: use align or conversion data for isp_is input */
/*! 1: use dma yuv read data for isp_is input */
#ifdef MRV_ISP_DMA_YUV_SELECTION
#define MRV_ISP_DMA_YUV_SELECTION_ALIGNED_CONV 0
#define MRV_ISP_DMA_YUV_SELECTION_DMA_YUV      1
#endif
/* Slice: LATENCY_FIFO_SELECTION:*/
/* 0: use input formatter input for latency fifo.*/
/* 1: use dma rgb read input for latency fifo.*/
#ifdef MRV_ISP_LATENCY_FIFO_SELECTION
#define MRV_ISP_LATENCY_FIFO_SELECTION_INPUT_FORMATTER  0
#define MRV_ISP_LATENCY_FIFO_SELECTION_DMA_READ         1
#endif /* MRV_ISP_LATENCY_FIFO_SELECTION */
/* Slice: INPUT_SELECTION:*/
/* 000: 12Bit external Interface */
/* 001: 10Bit Interface, append 2 zeroes as LSBs */
/* 010: 10Bit Interface, append 2 MSBs as LSBs */
/* 011: 8Bit Interface, append 4 zeroes as LSBs */
/* 100: 8Bit Interface, append 4 MSBs as LSBs */
/* 101...111: reserved */
#ifdef MRV_ISP_INPUT_SELECTION
#define MRV_ISP_INPUT_SELECTION_12EXT           0	/* 000- 12Bit external Interface */
#define MRV_ISP_INPUT_SELECTION_10ZERO          1	/* 001- 10Bit Interface, append 2 zeroes as LSBs */
#define MRV_ISP_INPUT_SELECTION_10MSB           2	/* 010- 10Bit Interface, append 2 MSBs as LSBs */
#define MRV_ISP_INPUT_SELECTION_8ZERO           3	/* 011- 8Bit Interface, append 4 zeroes as LSBs */
#define MRV_ISP_INPUT_SELECTION_8MSB            4	/* 100- 8Bit Interface, append 4 MSBs as LSBs */
#endif /* MRV_ISP_INPUT_SELECTION */
/* Slice: FIELD_SELECTION:*/
/* 00: sample all fields (don't care about fields)*/
/* 01: sample only even fields */
/* 10: sample only odd fields */
/* 11: reserved */
#ifdef MRV_ISP_FIELD_SELECTION
#define MRV_ISP_FIELD_SELECTION_BOTH            0	/* 00- sample all fields (don't care about fields) */
#define MRV_ISP_FIELD_SELECTION_EVEN            1	/* 01- sample only even fields */
#define MRV_ISP_FIELD_SELECTION_ODD             2	/* 10- sample only odd fields */
#endif /* MRV_ISP_FIELD_SELECTION */
/* Slice: CCIR_SEQ:*/
/* 00: YCbYCr */
/* 01: YCrYCb */
/* 10: CbYCrY */
/* 11: CrYCbY */
#ifdef MRV_ISP_CCIR_SEQ
#define MRV_ISP_CCIR_SEQ_YCBYCR                 0	/* 00 - YCbYCr */
#define MRV_ISP_CCIR_SEQ_YCRYCB                 1	/* 01 - YCrYCb */
#define MRV_ISP_CCIR_SEQ_CBYCRY                 2	/* 10 - CbYCrY */
#define MRV_ISP_CCIR_SEQ_CRYCBY                 3	/* 11 - CrYCbY */
#endif /* MRV_ISP_CCIR_SEQ */
/* Slice: CONV_422:*/
/* 00- co-sited color subsampling Y0Cb0Cr0 - Y1 */
/* 01- interleaved color subsampling Y0Cb0 - Y1Cr1 (not recommended)*/
/* 10- non-cosited color subsampling Y0Cb(0+1)/2 - Y1Cr(0+1)/2 */
/* 11- reserved */
#ifdef MRV_ISP_CONV_422
#define MRV_ISP_CONV_422_CO                     0	/* 00- co-sited color subsampling Y0Cb0Cr0 - Y1 */
#define MRV_ISP_CONV_422_INTER                  1	/* 01- interleaved color subsampling Y0Cb0 - Y1Cr1 (not recommended) */
#define MRV_ISP_CONV_422_NONCO                  2	/* 10- non-cosited color subsampling Y0Cb(0+1)/2 - Y1Cr(0+1)/2 */
#endif /* MRV_ISP_CONV_422 */
/* Slice: BAYER_PAT:*/
/* color components from sensor, starting with top left position in sampled frame */
/* (reprogram with ISP_ACQ_H_OFFS, ISP_ACQ_V_OFFS)*/
     /**/
/* 00: first line: RGRG, second line: GBGB, etc.*/
/* 01: first line: GRGR, second line: BGBG, etc.*/
/* 10: first line: GBGB, second line: RGRG, etc.*/
/* 11: first line: BGBG, second line: GRGR, etc.*/
/* This configuration applies for the black level area after cropping by the input formatter.*/
#ifdef MRV_ISP_BAYER_PAT
#define MRV_ISP_BAYER_PAT_RG                    0	/* 00 - first line: RGRG, second line: GBGB, etc. */
#define MRV_ISP_BAYER_PAT_GR                    1	/* 01 - first line: GRGR, second line: BGBG, etc. */
#define MRV_ISP_BAYER_PAT_GB                    2	/* 10 - first line: GBGB, second line: RGRG, etc. */
#define MRV_ISP_BAYER_PAT_BG                    3	/* 11 - first line: BGBG, second line: GRGR, etc. */
#endif /* MRV_ISP_BAYER_PAT */
/* Slice: VSYNC_POL:*/
/* vertical sync polarity */
/* 0: high active */
/* 1: low active */
#ifdef MRV_ISP_VSYNC_POL
#endif /* MRV_ISP_VSYNC_POL */
/* Slice: HSYNC_POL:*/
/* horizontal sync polarity */
/* 0: high active */
/* 1: low active */
#ifdef MRV_ISP_HSYNC_POL
#endif /* MRV_ISP_HSYNC_POL */
/* Slice: SAMPLE_EDGE:*/
/* 0: negative edge sampling */
/* 1: positive edge sampling */
#ifdef MRV_ISP_SAMPLE_EDGE
#endif /* MRV_ISP_SAMPLE_EDGE */
/*****************************************************************************/
/**
 * register: isp_acq_h_offs: horizontal input offset (0x0008)
 *
 *****************************************************************************/
/* Slice: ACQ_H_OFFS:*/
/* horizontal sample offset in 8-bit samples (yuv: 4 samples=2pix)*/
#ifdef MRV_ISP_ACQ_H_OFFS
#endif /* MRV_ISP_ACQ_H_OFFS */
/*****************************************************************************/
/**
 * register: isp_acq_v_offs: vertical input offset (0x000c)
 *
 *****************************************************************************/
/* Slice: ACQ_V_OFFS:*/
/* vertical sample offset in lines */
#ifdef MRV_ISP_ACQ_V_OFFS
#endif /* MRV_ISP_ACQ_V_OFFS */
/*****************************************************************************/
/**
 * register: isp_acq_h_size: horizontal input size (0x0010)
 *
 *****************************************************************************/
/* Slice: ACQ_H_SIZE:*/
/* horizontal sample size in 12-bit samples */
/* YUV input: 2 samples = 1 pixel, else 1 sample = 1 pixel; So in YUV mode ACQ_H_SIZE must be twice as large as horizontal image size */
/* horizontal image size must always be even exept in raw picture mode; if an odd size is programmed the value will be truncated to even size */
#ifdef MRV_ISP_ACQ_H_SIZE
#endif /* MRV_ISP_ACQ_H_SIZE */
/*****************************************************************************/
/**
 * register: isp_acq_v_size: vertical input size (0x0014)
 *
 *****************************************************************************/
/* Slice: ACQ_V_SIZE:*/
/* vertical sample size in lines */
#ifdef MRV_ISP_ACQ_V_SIZE
#endif /* MRV_ISP_ACQ_V_SIZE */
/*****************************************************************************/
/**
 * register: isp_acq_nr_frames: Number of frames to be captured (0x0018)
 *
 *****************************************************************************/
/* Slice: ACQ_NR_FRAMES:*/
/* number of input frames to be sampled (0 = continuous)*/
#ifdef MRV_ISP_ACQ_NR_FRAMES
#endif /* MRV_ISP_ACQ_NR_FRAMES */
/*****************************************************************************/
/**
 * register: isp_gamma_dx_lo: De-Gamma Curve definition lower x increments
 *           (sampling points) (0x001c)
 *
 *****************************************************************************/
/* Slice: GAMMA_DX_8:*/
/* gamma curve sample point definition x-axis (input)*/
#ifdef MRV_ISP_GAMMA_DX_8
#endif /* MRV_ISP_GAMMA_DX_8 */
/* Slice: GAMMA_DX_7:*/
/* gamma curve sample point definition x-axis (input)*/
#ifdef MRV_ISP_GAMMA_DX_7
#endif /* MRV_ISP_GAMMA_DX_7 */
/* Slice: GAMMA_DX_6:*/
/* gamma curve sample point definition x-axis (input)*/
#ifdef MRV_ISP_GAMMA_DX_6
#endif /* MRV_ISP_GAMMA_DX_6 */
/* Slice: GAMMA_DX_5:*/
/* gamma curve sample point definition x-axis (input)*/
#ifdef MRV_ISP_GAMMA_DX_5
#endif /* MRV_ISP_GAMMA_DX_5 */
/* Slice: GAMMA_DX_4:*/
/* gamma curve sample point definition x-axis (input)*/
#ifdef MRV_ISP_GAMMA_DX_4
#endif /* MRV_ISP_GAMMA_DX_4 */
/* Slice: GAMMA_DX_3:*/
/* gamma curve sample point definition x-axis (input)*/
#ifdef MRV_ISP_GAMMA_DX_3
#endif /* MRV_ISP_GAMMA_DX_3 */
/* Slice: GAMMA_DX_2:*/
/* gamma curve sample point definition x-axis (input)*/
#ifdef MRV_ISP_GAMMA_DX_2
#endif /* MRV_ISP_GAMMA_DX_2 */
/* Slice: GAMMA_DX_1:*/
/* gamma curve sample point definition x-axis (input)*/
#ifdef MRV_ISP_GAMMA_DX_1
#endif /* MRV_ISP_GAMMA_DX_1 */
/*****************************************************************************/
/**
 * register: isp_gamma_dx_hi: De-Gamma Curve definition higher x increments
 *           (sampling points) (0x0020)
 *
 *****************************************************************************/
/* Slice: GAMMA_DX_16:*/
/* gamma curve sample point definition x-axis (input)*/
#ifdef MRV_ISP_GAMMA_DX_16
#endif /* MRV_ISP_GAMMA_DX_16 */
/* Slice: GAMMA_DX_15:*/
/* gamma curve sample point definition x-axis (input)*/
#ifdef MRV_ISP_GAMMA_DX_15
#endif /* MRV_ISP_GAMMA_DX_15 */
/* Slice: GAMMA_DX_14:*/
/* gamma curve sample point definition x-axis (input)*/
#ifdef MRV_ISP_GAMMA_DX_14
#endif /* MRV_ISP_GAMMA_DX_14 */
/* Slice: GAMMA_DX_13:*/
/* gamma curve sample point definition x-axis (input)*/
#ifdef MRV_ISP_GAMMA_DX_13
#endif /* MRV_ISP_GAMMA_DX_13 */
/* Slice: GAMMA_DX_12:*/
/* gamma curve sample point definition x-axis (input)*/
#ifdef MRV_ISP_GAMMA_DX_12
#endif /* MRV_ISP_GAMMA_DX_12 */
/* Slice: GAMMA_DX_11:*/
/* gamma curve sample point definition x-axis (input)*/
#ifdef MRV_ISP_GAMMA_DX_11
#endif /* MRV_ISP_GAMMA_DX_11 */
/* Slice: GAMMA_DX_10:*/
/* gamma curve sample point definition x-axis (input)*/
#ifdef MRV_ISP_GAMMA_DX_10
#endif /* MRV_ISP_GAMMA_DX_10 */
/* Slice: GAMMA_DX_9:*/
/* gamma curve sample point definition x-axis (input)*/
#ifdef MRV_ISP_GAMMA_DX_9
#endif /* MRV_ISP_GAMMA_DX_9 */
/*****************************************************************************/
/**
 * register array: isp_gamma_r_y: De-Gamma Curve definition y red (0x0024+n (n=0..16))
 *
 *****************************************************************************/
/* Slice: GAMMA_R_Y:*/
/* gamma curve point definition y-axis (output) for red */
/* RESTRICTION: each Y must be in the +2047/-2048 range compared to its predecessor (so that dy is 12-bit signed !)*/
#ifdef MRV_ISP_GAMMA_R_Y
#endif /* MRV_ISP_GAMMA_R_Y */
/*****************************************************************************/
/**
 * register array: isp_gamma_g_y: De-Gamma Curve definition y green (0x0068+n (n=0..16))
 *
 *****************************************************************************/
/* Slice: GAMMA_G_Y:*/
/* gamma curve point definition y-axis (output) for green */
/* RESTRICTION: each Y must be in the +2047/-2048 range compared to its predecessor (so that dy is 12-bit signed !)*/
#ifdef MRV_ISP_GAMMA_G_Y
#endif /* MRV_ISP_GAMMA_G_Y */
/*****************************************************************************/
/**
 * register array: isp_gamma_b_y: De-Gamma Curve definition y blue (0x00AC+n (n=0..16))
 *
 *****************************************************************************/
/* Slice: GAMMA_B_Y:*/
/* gamma curve point definition y-axis (output) for blue */
/* RESTRICTION: each Y must be in the +2047/-2048 range compared to its predecessor (so that dy is 12-bit signed !)*/
#ifdef MRV_ISP_GAMMA_B_Y
#endif /* MRV_ISP_GAMMA_B_Y */
/*****************************************************************************/
/* ISP Auto White Balance Registers                                          */
/*****************************************************************************/
/*****************************************************************************/
/**
 * register: isp_awb_prop: Auto white balance properties (0x0110)
 *
 *****************************************************************************/
/* Slice: AWB_MEAS_MODE:*/
/* 1: RGB based measurement mode */
/* 0: near white discrimination mode using YCbCr color space */
#ifdef MRV_ISP_AWB_MEAS_MODE
#define MRV_ISP_AWB_MEAS_MODE_RGB               1U	/* 1: RGB based measurement mode */
#define MRV_ISP_AWB_MEAS_MODE_YCBCR             0U	/* 0: near white discrimination mode using YCbCr color space */
#endif /* MRV_ISP_AWB_MEAS_MODE */
/* Slice: AWB_MAX_EN:*/
/* 1: enable Y_MAX compare */
/* 0: disable Y_MAX compare */
/* ignored if RGB measurement mode is enabled */
#ifdef MRV_ISP_AWB_MAX_EN
#define MRV_ISP_AWB_MAX_EN_ENABLE               1U	/* 1: enable Y_MAX compare */
#define MRV_ISP_AWB_MAX_EN_DISABLE              0U	/* 0: disable Y_MAX compare */
#endif /* MRV_ISP_AWB_MAX_EN */
/* Slice: AWB_MODE:*/
/* AWB_MODE(1:0):*/
/* 11: reserved */
/* 10: white balance measurement of YCbCr means */
/* 01: reserved */
/* 00: manual white balance (gain adjust possible), no measurement */
#ifdef MRV_ISP_AWB_MODE
#define MRV_ISP_AWB_MODE_MEAS                   2U	/* 10: white balance measurement of YCbCr or RGB means (dependent on MRV_ISP_AWB_MEAS_MODE) */
#define MRV_ISP_AWB_MODE_NOMEAS                 0U	/* 00: manual white balance (gain adjust possible), no measurement */
#endif /* MRV_ISP_AWB_MODE */
/*****************************************************************************/
/**
 * register: isp_awb_h_offs: Auto white balance horizontal offset of measure
 *           window (0x0114)
 *
 *****************************************************************************/
/* Slice: AWB_H_OFFS:*/
/* horizontal window offset in pixel */
#ifdef MRV_ISP_AWB_H_OFFS
#define MRV_ISP_AWB_H_OFFS_MIN                  0U
#define MRV_ISP_AWB_H_OFFS_MAX                  (MRV_ISP_AWB_H_OFFS_MASK >> MRV_ISP_AWB_H_OFFS_SHIFT)
#endif /* MRV_ISP_AWB_H_OFFS */
/*****************************************************************************/
/**
 * register: isp_awb_v_offs: Auto white balance vertical offset of measure
 *           window (0x0118)
 *
 *****************************************************************************/
/* Slice: AWB_V_OFFS:*/
/* vertical window offset in lines */
#ifdef MRV_ISP_AWB_V_OFFS
#define MRV_ISP_AWB_V_OFFS_MIN                  0U
#define MRV_ISP_AWB_V_OFFS_MAX                  (MRV_ISP_AWB_V_OFFS_MASK >> MRV_ISP_AWB_V_OFFS_SHIFT)
#endif /* MRV_ISP_AWB_V_OFFS */
/*****************************************************************************/
/**
 * register: isp_awb_h_size: Auto white balance horizontal window size (0x011c)
 *
 *****************************************************************************/
/* Slice: AWB_H_SIZE:*/
/* horizontal measurement window size in pixel */
#ifdef MRV_ISP_AWB_H_SIZE
#define MRV_ISP_AWB_H_SIZE_MIN                  0U
#define MRV_ISP_AWB_H_SIZE_MAX                  (MRV_ISP_AWB_H_SIZE_MASK >> MRV_ISP_AWB_H_SIZE_SHIFT)
#endif /* MRV_ISP_AWB_H_SIZE */
/*****************************************************************************/
/**
 * register: isp_awb_v_size: Auto white balance vertical window size (0x0120)
 *
 *****************************************************************************/
/* Slice: AWB_V_SIZE:*/
/* vertical measurement window size in lines */
#ifdef MRV_ISP_AWB_V_SIZE
#define MRV_ISP_AWB_V_SIZE_MIN                  0U
#define MRV_ISP_AWB_V_SIZE_MAX                  (MRV_ISP_AWB_V_SIZE_MASK >> MRV_ISP_AWB_V_SIZE_SHIFT)
#endif /* MRV_ISP_AWB_V_SIZE */
/*****************************************************************************/
/**
 * register: isp_awb_frames: Auto white balance mean value over multiple frames (0x0124)
 *
 *****************************************************************************/
/* Slice: AWB_FRAMES:*/
/* number of frames-1 used for mean value calculation (value of 0 means 1 frame, value of 7 means 8 frames)*/
#ifdef MRV_ISP_AWB_FRAMES
#endif /* MRV_ISP_AWB_FRAMES */
/*****************************************************************************/
/**
 * register: isp_awb_ref: Auto white balance reference Cb/Cr values (0x0128)
 *           or maximum red/blue values
 *
 *****************************************************************************/
/* Slice: AWB_REF_CR__MAX_R:*/
/* - reference Cr value for AWB regulation, target for AWB */
/* - maximum red value, if RGB measurement mode is selected */
#ifdef MRV_ISP_AWB_REF_CR__MAX_R
#endif /* MRV_ISP_AWB_REF_CR__MAX_R */
/* Slice: AWB_REF_CB__MAX_B:*/
/* - reference Cb value for AWB regulation, target for AWB */
/* - maximum blue value, if RGB measurement mode is selected */
#ifdef MRV_ISP_AWB_REF_CB__MAX_B
#endif /* MRV_ISP_AWB_REF_CB__MAX_B */
/*****************************************************************************/
/**
 * register: isp_awb_thresh: Auto white balance threshold values (0x012c)
 *
 *****************************************************************************/
/* Slice: AWB_MAX_Y:*/
/* - Luminance maximum value, only consider pixels with luminance smaller than threshold for the WB measurement (must be enabled by AWB_MODE(2)),*/
/* - ignored if RGB measurement mode is enabled */
#ifdef MRV_ISP_AWB_MAX_Y
#endif /* MRV_ISP_AWB_MAX_Y */
/* Slice: AWB_MIN_Y__MAX_G:*/
/* - Luminance minimum value, only consider pixels with luminance greater than threshold for the WB measurement */
/* - maximum green value, if RGB measurement mode is selected */
#ifdef MRV_ISP_AWB_MIN_Y__MAX_G
#endif /* MRV_ISP_AWB_MIN_Y__MAX_G */
/* Slice: AWB_MAX_CSUM:*/
/* - Chrominance sum maximum value, only consider pixels with Cb+Cr smaller than threshold for WB measurements */
/* - ignored if RGB measurement mode is enabled */
#ifdef MRV_ISP_AWB_MAX_CSUM
#endif /* MRV_ISP_AWB_MAX_CSUM */
/* Slice: AWB_MIN_C:*/
/* - Chrominance minimum value, only consider pixels with Cb/Cr each greater than threshold value for WB measurements */
/* - ignored if RGB measurement mode is enabled */
#ifdef MRV_ISP_AWB_MIN_C
#endif /* MRV_ISP_AWB_MIN_C */
/*****************************************************************************/
/**
 * register: isp_awb_gain_g: Auto white balance gain green (0x0138)
 *
 *****************************************************************************/
/* Slice: AWB_GAIN_GR:*/
/* gain value for green component in red line 100h = 1 */
#ifdef MRV_ISP_AWB_GAIN_GR
#define MRV_ISP_AWB_GAIN_GR_DEFAULT             (0x100U)
#define MRV_ISP_AWB_GAIN_GR_MAX                 (MRV_ISP_AWB_GAIN_GR_MASK >> MRV_ISP_AWB_GAIN_GR_SHIFT)
#endif /* MRV_ISP_AWB_GAIN_GR */
/* Slice: AWB_GAIN_GB:*/
/* gain value for green component in blue line 100h = 1 */
#ifdef MRV_ISP_AWB_GAIN_GB
#define MRV_ISP_AWB_GAIN_GB_DEFAULT             (0x100U)
#define MRV_ISP_AWB_GAIN_GB_MAX                 (MRV_ISP_AWB_GAIN_GB_MASK >> MRV_ISP_AWB_GAIN_GB_SHIFT)
#endif /* MRV_ISP_AWB_GAIN_GB */
/*****************************************************************************/
/**
 * register: isp_awb_gain_rb: Auto white balance gain red and blue (0x013c)
 *
 *****************************************************************************/
/* Slice: AWB_GAIN_R:*/
/* gain value for red component 100h = 1 */
#ifdef MRV_ISP_AWB_GAIN_R
#define MRV_ISP_AWB_GAIN_R_DEFAULT              (0x100U)
#define MRV_ISP_AWB_GAIN_R_MAX                  (MRV_ISP_AWB_GAIN_R_MASK >> MRV_ISP_AWB_GAIN_R_SHIFT)
#endif /* MRV_ISP_AWB_GAIN_R */
/* Slice: AWB_GAIN_B:*/
/* gain value for blue component 100h = 1 */
#ifdef MRV_ISP_AWB_GAIN_B
#define MRV_ISP_AWB_GAIN_B_DEFAULT              (0x100U)
#define MRV_ISP_AWB_GAIN_B_MAX                  (MRV_ISP_AWB_GAIN_B_MASK >> MRV_ISP_AWB_GAIN_B_SHIFT)
#endif /* MRV_ISP_AWB_GAIN_B */
/*****************************************************************************/
/**
 * register: isp_awb_white_cnt: Auto white balance white pixel count (0x0140)
 *
 *****************************************************************************/
/* Slice: AWB_WHITE_CNT:*/
/* White pixel count, number of "white pixels" found during last measurement, i.e. pixels included in mean value calculation */
#ifdef MRV_ISP_AWB_WHITE_CNT
#endif /* MRV_ISP_AWB_WHITE_CNT */
/*****************************************************************************/
/**
 * register: isp_awb_mean: Auto white balance measured mean value (0x0144)
 *
 *****************************************************************************/
/* Slice: AWB_MEAN_Y_G:*/
/* - mean value of Y within window and frames */
/* - mean value of green within window and frames if RGB measurement is enabled */
#ifdef MRV_ISP_AWB_MEAN_Y__G
#endif /* MRV_ISP_AWB_MEAN_Y__G */
/* Slice: AWB_MEAN_CB_B:*/
/* - mean value of Cb within window and frames */
/* - mean value of blue within window and frames if RGB measurement is enabled */
#ifdef MRV_ISP_AWB_MEAN_CB__B
#endif /* MRV_ISP_AWB_MEAN_CB__B */
/* Slice: AWB_MEAN_CR_R:*/
/* - mean value of Cr within window and frames */
/* - mean value of red within window and frames if RGB measurement is enabled */
#ifdef MRV_ISP_AWB_MEAN_CR__R
#endif /* MRV_ISP_AWB_MEAN_CR__R */
/*****************************************************************************/
/**
 * register: isp_cc_coeff_0: Color conversion coefficient 0 (0x0170)
 *
 *****************************************************************************/
/* Slice: cc_coeff_0:*/
/* coefficient 0 for color space conversion */
#ifdef MRV_ISP_CC_COEFF_0
#endif /* MRV_ISP_CC_COEFF_0 */
/*****************************************************************************/
/**
 * register: isp_cc_coeff_1: Color conversion coefficient 1 (0x0174)
 *
 *****************************************************************************/
/* Slice: cc_coeff_1:*/
/* coefficient 1 for color space conversion */
#ifdef MRV_ISP_CC_COEFF_1
#endif /* MRV_ISP_CC_COEFF_1 */
/*****************************************************************************/
/**
 * register: isp_cc_coeff_2: Color conversion coefficient 2 (0x0178)
 *
 *****************************************************************************/
/* Slice: cc_coeff_2:*/
/* coefficient 2 for color space conversion */
#ifdef MRV_ISP_CC_COEFF_2
#endif /* MRV_ISP_CC_COEFF_2 */
/*****************************************************************************/
/**
 * register: isp_cc_coeff_3: Color conversion coefficient 3 (0x017c)
 *
 *****************************************************************************/
/* Slice: cc_coeff_3:*/
/* coefficient 3 for color space conversion */
#ifdef MRV_ISP_CC_COEFF_3
#endif /* MRV_ISP_CC_COEFF_3 */
/*****************************************************************************/
/**
 * register: isp_cc_coeff_4: Color conversion coefficient 4 (0x0180)
 *
 *****************************************************************************/
/* Slice: cc_coeff_4:*/
/* coefficient 4 for color space conversion */
#ifdef MRV_ISP_CC_COEFF_4
#endif /* MRV_ISP_CC_COEFF_4 */
/*****************************************************************************/
/**
 * register: isp_cc_coeff_5: Color conversion coefficient 5 (0x0184)
 *
 *****************************************************************************/
/* Slice: cc_coeff_5:*/
/* coefficient 5 for color space conversion */
#ifdef MRV_ISP_CC_COEFF_5
#endif /* MRV_ISP_CC_COEFF_5 */
/*****************************************************************************/
/**
 * register: isp_cc_coeff_6: Color conversion coefficient 6 (0x0188)
 *
 *****************************************************************************/
/* Slice: cc_coeff_6:*/
/* coefficient 6 for color space conversion */
#ifdef MRV_ISP_CC_COEFF_6
#endif /* MRV_ISP_CC_COEFF_6 */
/*****************************************************************************/
/**
 * register: isp_cc_coeff_7: Color conversion coefficient 7 (0x018c)
 *
 *****************************************************************************/
/* Slice: cc_coeff_7:*/
/* coefficient 7 for color space conversion */
#ifdef MRV_ISP_CC_COEFF_7
#endif /* MRV_ISP_CC_COEFF_7 */
/*****************************************************************************/
/**
 * register: isp_cc_coeff_8: Color conversion coefficient 8 (0x0190)
 *
 *****************************************************************************/
/* Slice: cc_coeff_8:*/
/* coefficient 8 for color space conversion */
#ifdef MRV_ISP_CC_COEFF_8
#endif /* MRV_ISP_CC_COEFF_8 */
/*****************************************************************************/
/**
 * register: isp_out_h_offs: Horizontal offset of output window (0x0194)
 *
 *****************************************************************************/
/* Slice: ISP_OUT_H_OFFS:*/
/* vertical pic offset in lines */
#ifdef MRV_ISP_ISP_OUT_H_OFFS
#endif /* MRV_ISP_ISP_OUT_H_OFFS */
/*****************************************************************************/
/**
 * register: isp_out_v_offs: Vertical offset of output window (0x0198)
 *
 *****************************************************************************/
/* Slice: ISP_OUT_V_OFFS:*/
/* vertical pic offset in lines */
#ifdef MRV_ISP_ISP_OUT_V_OFFS
#endif /* MRV_ISP_ISP_OUT_V_OFFS */
/*****************************************************************************/
/**
 * register: isp_out_h_size: Output horizontal picture size (0x019c)
 *
 *****************************************************************************/
/* Slice: ISP_OUT_H_SIZE:*/
/* horizontal picture size in pixel */
/* if ISP_MODE is set to */
/* 001: (ITU-R BT.656 YUV),*/
/* 010: (ITU-R BT.601 YUV),*/
/* 011: (ITU-R BT.601 Bayer RGB),*/
/* 101: (ITU-R BT.656 Bayer RGB)*/
/* only even numbers are accepted, because complete quadruples of YUYV(YCbYCr)*/
/* are needed for the 422 output. (if an odd size is programmed the value will */
/* be truncated to an even size)*/
#ifdef MRV_ISP_ISP_OUT_H_SIZE
#define MRV_ISP_ISP_OUT_H_SIZE_IS_EVEN(x)       (!(x & 0x01U))	/* check is even value */
#define MRV_ISP_ISP_OUT_H_SIZE_IS_ODD(x)        (x & 0x01U)	/* check is odd value */
#endif /* MRV_ISP_ISP_OUT_H_SIZE */
/*****************************************************************************/
/**
 * register: isp_out_v_size: Output vertical picture size (0x01a0)
 *
 *****************************************************************************/
/* Slice: ISP_OUT_V_SIZE:*/
/* vertical pic size in lines */
#ifdef MRV_ISP_ISP_OUT_V_SIZE
#endif /* MRV_ISP_ISP_OUT_V_SIZE */
/*****************************************************************************/
/**
 * register: isp_demosaic: Demosaic parameters (0x000001a4)
 *
 *****************************************************************************/
/* Slice: DEMOSAIC_BYPASS:*/
/* 0: normal operation for RGB Bayer Pattern input */
/* 1: demosaicing bypass for Black&White input data */
#ifdef MRV_ISP_DEMOSAIC_BYPASS
#define MRV_ISP_DEMOSAIC_MODE_STD               0	/* "0": standard */
#define MRV_ISP_DEMOSAIC_MODE_ENH               1	/* "1": enhanced mode */
#endif /* MRV_ISP_DEMOSAIC_BYPASS */
/* Slice: DEMOSAIC_TH:*/
/* Threshold for Bayer demosaicing texture detection. This value shifted left */
/* 4bit is compared with the difference of the vertical and horizontal 12Bit */
/* wide texture indicators, to decide if the vertical or horizontal texture */
/* flag must be set.*/
/* 0xFF: no texture detection */
/* 0x00: maximum edge sensitivity */
#ifdef MRV_ISP_DEMOSAIC_TH
#define MRV_ISP_DEMOSAIC_TH_MAX_TEXTURE_DETECTION   0xFFU	/* 0xFF: no texture detection */
#define MRV_ISP_DEMOSAIC_TH_MAX_EDGE_SENSITIVITY    0x00U	/* 0x00: maximum edge sensitivity */
#endif /* MRV_ISP_DEMOSAIC_TH */
/*****************************************************************************/
/**
 * register: isp_flags_shd: Flags (current status) of certain signals and
 *           Shadow regs for enable signals (0x000001a8)
 *
 *****************************************************************************/
/* Slice: S_HSYNC:*/
/* state of ISP input port s_hsync, for test purposes */
#ifdef MRV_ISP_S_HSYNC
#endif /* MRV_ISP_S_HSYNC */
/* Slice: S_VSYNC:*/
/* state of ISP input port s_vsync, for test purposes */
#ifdef MRV_ISP_S_VSYNC
#endif /* MRV_ISP_S_VSYNC */
/* Slice: S_DATA:*/
/* state of ISP input port s_data, for test purposes */
#ifdef MRV_ISP_S_DATA
#endif /* MRV_ISP_S_DATA */
/* Slice: INFORM_FIELD:*/
/* current field information */
/* 0: odd */
/* 1: even */
#ifdef MRV_ISP_INFORM_FIELD
#define MRV_ISP_INFORM_FIELD_ODD                0	/* 0: odd field is sampled */
#define MRV_ISP_INFORM_FIELD_EVEN               1	/* 1: even field is sampled */
#endif /* MRV_ISP_INFORM_FIELD */
/* Slice: INFORM_EN_SHD:*/
/* Input formatter enable shadow register */
#ifdef MRV_ISP_INFORM_EN_SHD
#endif /* MRV_ISP_INFORM_EN_SHD */
/* Slice: ISP_ENABLE_SHD:*/
/* ISP enable shadow register */
/* shows, if ISP currently outputs data (1) or not (0)*/
#ifdef MRV_ISP_ISP_ENABLE_SHD
#endif /* MRV_ISP_ISP_ENABLE_SHD */
/*****************************************************************************/
/**
 * register: isp_out_h_offs_shd: current horizontal offset of output window
 *           (shadow register) (0x000001ac)
 *
 *****************************************************************************/
/* Slice: ISP_OUT_H_OFFS_SHD:*/
/* current vertical pic offset in lines */
#ifdef MRV_ISP_ISP_OUT_H_OFFS_SHD
#endif /* MRV_ISP_ISP_OUT_H_OFFS_SHD */
/*****************************************************************************/
/**
 * register: isp_out_v_offs_shd: current vertical offset of output window
 *           (shadow register) (0x000001b0)
 *
 *****************************************************************************/
/* Slice: ISP_OUT_V_OFFS_SHD:*/
/* current vertical pic offset in lines */
#ifdef MRV_ISP_ISP_OUT_V_OFFS_SHD
#endif /* MRV_ISP_ISP_OUT_V_OFFS_SHD */
/*****************************************************************************/
/**
 * register: isp_out_h_size_shd: current output horizontal picture size
 *           (shadow register) (0x000001b4)
 *
 *****************************************************************************/
/* Slice: ISP_OUT_H_SIZE_SHD:*/
/* current horizontal pic size in pixel */
#ifdef MRV_ISP_ISP_OUT_H_SIZE_SHD
#endif /* MRV_ISP_ISP_OUT_H_SIZE_SHD */
/*****************************************************************************/
/**
 * register: isp_out_v_size_shd: current output vertical picture size
 *           (shadow register) (0x000001b8)
 *
 *****************************************************************************/
/* Slice: ISP_OUT_V_SIZE_SHD:*/
/* vertical pic size in lines */
#ifdef MRV_ISP_ISP_OUT_V_SIZE_SHD
#endif /* MRV_ISP_ISP_OUT_V_SIZE_SHD */
/*****************************************************************************/
/**
 * register: isp_imsc: Interrupt mask (0x000001bc)
 *
 *****************************************************************************/
/*! Slice: IMSC_VSM_END:*/
/*! enable interrupt (1) or mask out (0)*/
#ifndef MRV_ISP_IMSC_VSM_END
#define MRV_ISP_IMSC_VSM_END_MASK               0U	/* make sure, that this mask is defined for the combination mask */
#endif /* !MRV_ISP_IMSC_VSM_END */
/* Slice: IMSC_EXP_END:*/
/* enable interrupt (1) or mask out (0)*/
#ifndef MRV_ISP_IMSC_EXP_END
#define MRV_ISP_IMSC_EXP_END_MASK               0U	/* make sure, that this mask is defined for the combination mask */
#endif /* !MRV_ISP_IMSC_EXP_END */
/* Slice: IMSC_FLASH_CAP:*/
/* enable interrupt (1) or mask out (0)*/
#ifndef MRV_ISP_IMSC_FLASH_CAP
#define MRV_ISP_IMSC_FLASH_CAP_MASK             0U	/* make sure, that this mask is defined for the combination mask */
#endif /* !MRV_ISP_IMSC_FLASH_CAP */
/* Slice: IMSC_BP_DET:*/
/* enable interrupt (1) or mask out (0)*/
#ifndef MRV_ISP_IMSC_BP_DET
#define MRV_ISP_IMSC_BP_DET_MASK                0U	/* make sure, that this mask is defined for the combination mask */
#endif /* !MRV_ISP_IMSC_BP_DET */
/* Slice: IMSC_HIST_MEASURE_RDY:*/
/* enable interrupt (1) or mask out (0)*/
#ifndef MRV_ISP_IMSC_HIST_MEASURE_RDY
#define MRV_ISP_IMSC_HIST_MEASURE_RDY_MASK              0U	/* make sure, that this mask is defined for the combination mask */
#endif /* !MRV_ISP_IMSC_HIST_MEASURE_RDY */
/* Slice: IMSC_AFM_FIN:*/
/* enable interrupt (1) or mask out (0)*/
#ifndef MRV_ISP_IMSC_AFM_FIN
#define MRV_ISP_IMSC_AFM_FIN_MASK               0U	/* make sure, that this mask is defined for the combination mask */
#endif /* !IMSC_AFM_FIN */
/* Slice: IMSC_AFM_LUM_OF:*/
/* enable interrupt (1) or mask out (0)*/
#ifndef MRV_ISP_IMSC_AFM_LUM_OF
#define MRV_ISP_IMSC_AFM_LUM_OF_MASK            0U	/* make sure, that this mask is defined for the combination mask */
#endif /* !MRV_ISP_IMSC_AFM_LUM_OF */
/* Slice: IMSC_AFM_SUM_OF:*/
/* enable interrupt (1) or mask out (0)*/
#ifndef MRV_ISP_IMSC_AFM_SUM_OF
#define MRV_ISP_IMSC_AFM_SUM_OF_MASK            0U	/* make sure, that this mask is defined for the combination mask */
#endif /* !MRV_ISP_IMSC_AFM_SUM_OF */
/* Slice: IMSC_SHUTTER_OFF:*/
/* enable interrupt (1) or mask out (0)*/
#ifndef MRV_ISP_IMSC_SHUTTER_OFF
#define MRV_ISP_IMSC_SHUTTER_OFF_MASK           0U	/* make sure, that this mask is defined for the combination mask */
#endif /* !MRV_ISP_IMSC_SHUTTER_OFF */
/* Slice: IMSC_SHUTTER_ON:*/
/* enable interrupt (1) or mask out (0)*/
#ifndef MRV_ISP_IMSC_SHUTTER_ON
#define MRV_ISP_IMSC_SHUTTER_ON_MASK            0U	/* make sure, that this mask is defined for the combination mask */
#endif /* !MRV_ISP_IMSC_SHUTTER_ON */
/* Slice: IMSC_FLASH_OFF:*/
/* enable interrupt (1) or mask out (0)*/
#ifndef MRV_ISP_IMSC_FLASH_OFF
#define MRV_ISP_IMSC_FLASH_OFF_MASK             0U	/* make sure, that this mask is defined for the combination mask */
#endif /* !MRV_ISP_IMSC_FLASH_OFF */
/* Slice: IMSC_FLASH_ON:*/
/* enable interrupt (1) or mask out (0)*/
#ifndef MRV_ISP_IMSC_FLASH_ON
#define MRV_ISP_IMSC_FLASH_ON_MASK              0U	/* make sure, that this mask is defined for the combination mask */
#endif /* !MRV_ISP_IMSC_FLASH_ON */
/* Slice: IMSC_H_START:*/
/* enable interrupt (1) or mask out (0)*/
#ifndef MRV_ISP_IMSC_H_START
#define MRV_ISP_IMSC_H_START_MASK               0U	/* make sure, that this mask is defined for the combination mask */
#endif /* !MRV_ISP_IMSC_H_START */
/* Slice: IMSC_V_START:*/
/* enable interrupt (1) or mask out (0)*/
#ifndef MRV_ISP_IMSC_V_START
#define MRV_ISP_IMSC_V_START_MASK               0U	/* make sure, that this mask is defined for the combination mask */
#endif /* !MRV_ISP_IMSC_V_START */
/* Slice: IMSC_FRAME_IN:*/
/* enable interrupt (1) or mask out (0)*/
#ifndef MRV_ISP_IMSC_FRAME_IN
#define MRV_ISP_IMSC_FRAME_IN_MASK              0U	/* make sure, that this mask is defined for the combination mask */
#endif /* !MRV_ISP_IMSC_FRAME_IN */
/* Slice: IMSC_AWB_DONE:*/
/* enable interrupt (1) or mask out (0)*/
#ifndef MRV_ISP_IMSC_AWB_DONE
#define MRV_ISP_IMSC_AWB_DONE_MASK              0U	/* make sure, that this mask is defined for the combination mask */
#endif /* !MRV_ISP_IMSC_AWB_DONE */
/* Slice: IMSC_PIC_SIZE_ERR:*/
/* enable interrupt (1) or mask out (0)*/
#ifndef MRV_ISP_IMSC_PIC_SIZE_ERR
#define MRV_ISP_IMSC_PIC_SIZE_ERR_MASK          0U	/* make sure, that this mask is defined for the combination mask */
#endif /* !MRV_ISP_IMSC_PIC_SIZE_ERR */
/* Slice: IMSC_DATA_LOSS:*/
/* enable interrupt (1) or mask out (0)*/
#ifndef MRV_ISP_IMSC_DATA_LOSS
#define MRV_ISP_IMSC_DATA_LOSS_MASK             0U	/* make sure, that this mask is defined for the combination mask */
#endif /* !MRV_ISP_IMSC_DATA_LOSS */
/* Slice: IMSC_FRAME:*/
/* enable interrupt (1) or mask out (0)*/
#ifndef MRV_ISP_IMSC_FRAME
#define MRV_ISP_IMSC_FRAME_MASK                 0U	/* make sure, that this mask is defined for the combination mask */
#endif /* !MRV_ISP_IMSC_FRAME */
/* Slice: IMSC_ISP_OFF:*/
/* enable interrupt (1) or mask out (0)*/
#ifndef MRV_ISP_IMSC_ISP_OFF
#define MRV_ISP_IMSC_ISP_OFF_MASK               0U	/* make sure, that this mask is defined for the combination mask */
#endif /* !MRV_ISP_IMSC_ISP_OFF */
/* combination of all interrupt lines */
#define MRV_ISP_IMSC_ALL_IRQS
#define MRV_ISP_IMSC_ALL_IRQS_MASK \
(0 \
	| MRV_ISP_IMSC_VSM_END_MASK \
	| MRV_ISP_IMSC_EXP_END_MASK \
	| MRV_ISP_IMSC_FLASH_CAP_MASK \
	| MRV_ISP_IMSC_BP_DET_MASK \
	| MRV_ISP_IMSC_HIST_MEASURE_RDY_MASK \
	| MRV_ISP_IMSC_AFM_FIN_MASK \
	| MRV_ISP_IMSC_AFM_LUM_OF_MASK \
	| MRV_ISP_IMSC_AFM_SUM_OF_MASK \
	| MRV_ISP_IMSC_SHUTTER_OFF_MASK \
	| MRV_ISP_IMSC_SHUTTER_ON_MASK \
	| MRV_ISP_IMSC_FLASH_OFF_MASK \
	| MRV_ISP_IMSC_FLASH_ON_MASK \
	| MRV_ISP_IMSC_H_START_MASK \
	| MRV_ISP_IMSC_V_START_MASK \
	| MRV_ISP_IMSC_FRAME_IN_MASK \
	| MRV_ISP_IMSC_AWB_DONE_MASK \
	| MRV_ISP_IMSC_PIC_SIZE_ERR_MASK \
	| MRV_ISP_IMSC_DATA_LOSS_MASK \
	| MRV_ISP_IMSC_FRAME_MASK \
	| MRV_ISP_IMSC_ISP_OFF_MASK \
)
#define MRV_ISP_IMSC_ALL_IRQS_SHIFT             0U
/*****************************************************************************/
/**
 * register: isp_ris: Raw interrupt status (0x000001c0)
 *
 *****************************************************************************/
/*! Slice: RIS_VSM_END:*/
/*! VSM measurement complete */
#ifndef MRV_ISP_RIS_VSM_END
#define MRV_ISP_RIS_VSM_END_MASK               0U	/* make sure, that this mask is defined for the combination mask */
#endif /* !MRV_ISP_RIS_VSM_END */
/* Slice: RIS_EXP_END:*/
/* enable interrupt (1) or mask out (0)*/
#ifndef MRV_ISP_RIS_EXP_END
#define MRV_ISP_RIS_EXP_END_MASK               0U	/* make sure, that this mask is defined for the combination mask */
#endif /* !MRV_ISP_RIS_EXP_END */
/* Slice: RIS_FLASH_CAP:*/
/* enable interrupt (1) or mask out (0)*/
#ifndef MRV_ISP_RIS_FLASH_CAP
#define MRV_ISP_RIS_FLASH_CAP_MASK             0U	/* make sure, that this mask is defined for the combination mask */
#endif /* !MRV_ISP_RIS_FLASH_CAP */
/* Slice: RIS_BP_DET:*/
/* enable interrupt (1) or mask out (0)*/
#ifndef MRV_ISP_RIS_BP_DET
#define MRV_ISP_RIS_BP_DET_MASK                0U	/* make sure, that this mask is defined for the combination mask */
#endif /* !MRV_ISP_RIS_BP_DET */
/* Slice: RIS_HIST_MEASURE_RDY:*/
/* enable interrupt (1) or mask out (0)*/
#ifndef MRV_ISP_RIS_HIST_MEASURE_RDY
#define MRV_ISP_RIS_HIST_MEASURE_RDY_MASK              0U	/* make sure, that this mask is defined for the combination mask */
#endif /* !MRV_ISP_RIS_HIST_MEASURE_RDY */
/* Slice: RIS_AFM_FIN:*/
/* enable interrupt (1) or mask out (0)*/
#ifndef MRV_ISP_RIS_AFM_FIN
#define MRV_ISP_RIS_AFM_FIN_MASK               0U	/* make sure, that this mask is defined for the combination mask */
#endif /* !RIS_AFM_FIN */
/* Slice: RIS_AFM_LUM_OF:*/
/* enable interrupt (1) or mask out (0)*/
#ifndef MRV_ISP_RIS_AFM_LUM_OF
#define MRV_ISP_RIS_AFM_LUM_OF_MASK            0U	/* make sure, that this mask is defined for the combination mask */
#endif /* !MRV_ISP_RIS_AFM_LUM_OF */
/* Slice: RIS_AFM_SUM_OF:*/
/* enable interrupt (1) or mask out (0)*/
#ifndef MRV_ISP_RIS_AFM_SUM_OF
#define MRV_ISP_RIS_AFM_SUM_OF_MASK            0U	/* make sure, that this mask is defined for the combination mask */
#endif /* !MRV_ISP_RIS_AFM_SUM_OF */
/* Slice: RIS_SHUTTER_OFF:*/
/* enable interrupt (1) or mask out (0)*/
#ifndef MRV_ISP_RIS_SHUTTER_OFF
#define MRV_ISP_RIS_SHUTTER_OFF_MASK           0U	/* make sure, that this mask is defined for the combination mask */
#endif /* !MRV_ISP_RIS_SHUTTER_OFF */
/* Slice: RIS_SHUTTER_ON:*/
/* enable interrupt (1) or mask out (0)*/
#ifndef MRV_ISP_RIS_SHUTTER_ON
#define MRV_ISP_RIS_SHUTTER_ON_MASK            0U	/* make sure, that this mask is defined for the combination mask */
#endif /* !MRV_ISP_RIS_SHUTTER_ON */
/* Slice: RIS_FLASH_OFF:*/
/* enable interrupt (1) or mask out (0)*/
#ifndef MRV_ISP_RIS_FLASH_OFF
#define MRV_ISP_RIS_FLASH_OFF_MASK             0U	/* make sure, that this mask is defined for the combination mask */
#endif /* !MRV_ISP_RIS_FLASH_OFF */
/* Slice: RIS_FLASH_ON:*/
/* enable interrupt (1) or mask out (0)*/
#ifndef MRV_ISP_RIS_FLASH_ON
#define MRV_ISP_RIS_FLASH_ON_MASK              0U	/* make sure, that this mask is defined for the combination mask */
#endif /* !MRV_ISP_RIS_FLASH_ON */
/* Slice: RIS_H_START:*/
/* enable interrupt (1) or mask out (0)*/
#ifndef MRV_ISP_RIS_H_START
#define MRV_ISP_RIS_H_START_MASK               0U	/* make sure, that this mask is defined for the combination mask */
#endif /* !MRV_ISP_RIS_H_START */
/* Slice: RIS_V_START:*/
/* enable interrupt (1) or mask out (0)*/
#ifndef MRV_ISP_RIS_V_START
#define MRV_ISP_RIS_V_START_MASK               0U	/* make sure, that this mask is defined for the combination mask */
#endif /* !MRV_ISP_RIS_V_START */
/* Slice: RIS_FRAME_IN:*/
/* enable interrupt (1) or mask out (0)*/
#ifndef MRV_ISP_RIS_FRAME_IN
#define MRV_ISP_RIS_FRAME_IN_MASK              0U	/* make sure, that this mask is defined for the combination mask */
#endif /* !MRV_ISP_RIS_FRAME_IN */
/* Slice: RIS_AWB_DONE:*/
/* enable interrupt (1) or mask out (0)*/
#ifndef MRV_ISP_RIS_AWB_DONE
#define MRV_ISP_RIS_AWB_DONE_MASK              0U	/* make sure, that this mask is defined for the combination mask */
#endif /* !MRV_ISP_RIS_AWB_DONE */
/* Slice: RIS_PIC_SIZE_ERR:*/
/* enable interrupt (1) or mask out (0)*/
#ifndef MRV_ISP_RIS_PIC_SIZE_ERR
#define MRV_ISP_RIS_PIC_SIZE_ERR_MASK          0U	/* make sure, that this mask is defined for the combination mask */
#endif /* !MRV_ISP_RIS_PIC_SIZE_ERR */
/* Slice: RIS_DATA_LOSS:*/
/* enable interrupt (1) or mask out (0)*/
#ifndef MRV_ISP_RIS_DATA_LOSS
#define MRV_ISP_RIS_DATA_LOSS_MASK             0U	/* make sure, that this mask is defined for the combination mask */
#endif /* !MRV_ISP_RIS_DATA_LOSS */
/* Slice: RIS_FRAME:*/
/* enable interrupt (1) or mask out (0)*/
#ifndef MRV_ISP_RIS_FRAME
#define MRV_ISP_RIS_FRAME_MASK                 0U	/* make sure, that this mask is defined for the combination mask */
#endif /* !MRV_ISP_RIS_FRAME */
/* Slice: RIS_ISP_OFF:*/
/* enable interrupt (1) or mask out (0)*/
#ifndef MRV_ISP_RIS_ISP_OFF
#define MRV_ISP_RIS_ISP_OFF_MASK               0U	/* make sure, that this mask is defined for the combination mask */
#endif /* !MRV_ISP_RIS_ISP_OFF */
/* combination of all interrupt lines */
#define MRV_ISP_RIS_ALL_IRQS
#define MRV_ISP_RIS_ALL_IRQS_MASK \
(0 \
	| MRV_ISP_RIS_VSM_END_MASK \
	| MRV_ISP_RIS_EXP_END_MASK \
	| MRV_ISP_RIS_FLASH_CAP_MASK \
	| MRV_ISP_RIS_BP_DET_MASK \
	| MRV_ISP_RIS_HIST_MEASURE_RDY_MASK \
	| MRV_ISP_RIS_AFM_FIN_MASK \
	| MRV_ISP_RIS_AFM_LUM_OF_MASK \
	| MRV_ISP_RIS_AFM_SUM_OF_MASK \
	| MRV_ISP_RIS_SHUTTER_OFF_MASK \
	| MRV_ISP_RIS_SHUTTER_ON_MASK \
	| MRV_ISP_RIS_FLASH_OFF_MASK \
	| MRV_ISP_RIS_FLASH_ON_MASK \
	| MRV_ISP_RIS_H_START_MASK \
	| MRV_ISP_RIS_V_START_MASK \
	| MRV_ISP_RIS_FRAME_IN_MASK \
	| MRV_ISP_RIS_AWB_DONE_MASK \
	| MRV_ISP_RIS_PIC_SIZE_ERR_MASK \
	| MRV_ISP_RIS_DATA_LOSS_MASK \
	| MRV_ISP_RIS_FRAME_MASK \
	| MRV_ISP_RIS_ISP_OFF_MASK \
)
#define MRV_ISP_RIS_ALL_IRQS_SHIFT             0U
/*****************************************************************************/
/**
 * register: isp_mis: Masked interrupt status (0x000001c4)
 *
 *****************************************************************************/
/*! Slice: MIS_VSM_END:*/
/*! VSM measurement complete */
#ifndef MRV_ISP_MIS_VSM_END
#define MRV_ISP_MIS_VSM_END_MASK               0U	/* make sure, that this mask is defined for the combination mask */
#endif /* !MRV_ISP_MIS_VSM_END_MASK */
/* Slice: MIS_EXP_END:*/
/* enable interrupt (1) or mask out (0)*/
#ifndef MRV_ISP_MIS_EXP_END
#define MRV_ISP_MIS_EXP_END_MASK               0U	/* make sure, that this mask is defined for the combination mask */
#endif /* !MRV_ISP_MIS_EXP_END */
/* Slice: MIS_FLASH_CAP:*/
/* enable interrupt (1) or mask out (0)*/
#ifndef MRV_ISP_MIS_FLASH_CAP
#define MRV_ISP_MIS_FLASH_CAP_MASK             0U	/* make sure, that this mask is defined for the combination mask */
#endif /* !MRV_ISP_MIS_FLASH_CAP */
/* Slice: MIS_BP_DET:*/
/* enable interrupt (1) or mask out (0)*/
#ifndef MRV_ISP_MIS_BP_DET
#define MRV_ISP_MIS_BP_DET_MASK                0U	/* make sure, that this mask is defined for the combination mask */
#endif /* !MRV_ISP_MIS_BP_DET */
/* Slice: MIS_HIST_MEASURE_RDY:*/
/* enable interrupt (1) or mask out (0)*/
#ifndef MRV_ISP_MIS_HIST_MEASURE_RDY
#define MRV_ISP_MIS_HIST_MEASURE_RDY_MASK              0U	/* make sure, that this mask is defined for the combination mask */
#endif /* !MRV_ISP_MIS_HIST_MEASURE_RDY */
/* Slice: MIS_AFM_FIN:*/
/* enable interrupt (1) or mask out (0)*/
#ifndef MRV_ISP_MIS_AFM_FIN
#define MRV_ISP_MIS_AFM_FIN_MASK               0U	/* make sure, that this mask is defined for the combination mask */
#endif /* !MIS_AFM_FIN */
/* Slice: MIS_AFM_LUM_OF:*/
/* enable interrupt (1) or mask out (0)*/
#ifndef MRV_ISP_MIS_AFM_LUM_OF
#define MRV_ISP_MIS_AFM_LUM_OF_MASK            0U	/* make sure, that this mask is defined for the combination mask */
#endif /* !MRV_ISP_MIS_AFM_LUM_OF */
/* Slice: MIS_AFM_SUM_OF:*/
/* enable interrupt (1) or mask out (0)*/
#ifndef MRV_ISP_MIS_AFM_SUM_OF
#define MRV_ISP_MIS_AFM_SUM_OF_MASK            0U	/* make sure, that this mask is defined for the combination mask */
#endif /* !MRV_ISP_MIS_AFM_SUM_OF */
/* Slice: MIS_SHUTTER_OFF:*/
/* enable interrupt (1) or mask out (0)*/
#ifndef MRV_ISP_MIS_SHUTTER_OFF
#define MRV_ISP_MIS_SHUTTER_OFF_MASK           0U	/* make sure, that this mask is defined for the combination mask */
#endif /* !MRV_ISP_MIS_SHUTTER_OFF */
/* Slice: MIS_SHUTTER_ON:*/
/* enable interrupt (1) or mask out (0)*/
#ifndef MRV_ISP_MIS_SHUTTER_ON
#define MRV_ISP_MIS_SHUTTER_ON_MASK            0U	/* make sure, that this mask is defined for the combination mask */
#endif /* !MRV_ISP_MIS_SHUTTER_ON */
/* Slice: MIS_FLASH_OFF:*/
/* enable interrupt (1) or mask out (0)*/
#ifndef MRV_ISP_MIS_FLASH_OFF
#define MRV_ISP_MIS_FLASH_OFF_MASK             0U	/* make sure, that this mask is defined for the combination mask */
#endif /* !MRV_ISP_MIS_FLASH_OFF */
/* Slice: MIS_FLASH_ON:*/
/* enable interrupt (1) or mask out (0)*/
#ifndef MRV_ISP_MIS_FLASH_ON
#define MRV_ISP_MIS_FLASH_ON_MASK              0U	/* make sure, that this mask is defined for the combination mask */
#endif /* !MRV_ISP_MIS_FLASH_ON */
/* Slice: MIS_H_START:*/
/* enable interrupt (1) or mask out (0)*/
#ifndef MRV_ISP_MIS_H_START
#define MRV_ISP_MIS_H_START_MASK               0U	/* make sure, that this mask is defined for the combination mask */
#endif /* !MRV_ISP_MIS_H_START */
/* Slice: MIS_V_START:*/
/* enable interrupt (1) or mask out (0)*/
#ifndef MRV_ISP_MIS_V_START
#define MRV_ISP_MIS_V_START_MASK               0U	/* make sure, that this mask is defined for the combination mask */
#endif /* !MRV_ISP_MIS_V_START */
/* Slice: MIS_FRAME_IN:*/
/* enable interrupt (1) or mask out (0)*/
#ifndef MRV_ISP_MIS_FRAME_IN
#define MRV_ISP_MIS_FRAME_IN_MASK              0U	/* make sure, that this mask is defined for the combination mask */
#endif /* !MRV_ISP_MIS_FRAME_IN */
/* Slice: MIS_AWB_DONE:*/
/* enable interrupt (1) or mask out (0)*/
#ifndef MRV_ISP_MIS_AWB_DONE
#define MRV_ISP_MIS_AWB_DONE_MASK              0U	/* make sure, that this mask is defined for the combination mask */
#endif /* !MRV_ISP_MIS_AWB_DONE */
/* Slice: MIS_PIC_SIZE_ERR:*/
/* enable interrupt (1) or mask out (0)*/
#ifndef MRV_ISP_MIS_PIC_SIZE_ERR
#define MRV_ISP_MIS_PIC_SIZE_ERR_MASK          0U	/* make sure, that this mask is defined for the combination mask */
#endif /* !MRV_ISP_MIS_PIC_SIZE_ERR */
/* Slice: MIS_DATA_LOSS:*/
/* enable interrupt (1) or mask out (0)*/
#ifndef MRV_ISP_MIS_DATA_LOSS
#define MRV_ISP_MIS_DATA_LOSS_MASK             0U	/* make sure, that this mask is defined for the combination mask */
#endif /* !MRV_ISP_MIS_DATA_LOSS */
/* Slice: MIS_FRAME:*/
/* enable interrupt (1) or mask out (0)*/
#ifndef MRV_ISP_MIS_FRAME
#define MRV_ISP_MIS_FRAME_MASK                 0U	/* make sure, that this mask is defined for the combination mask */
#endif /* !MRV_ISP_MIS_FRAME */
/* Slice: MIS_ISP_OFF:*/
/* enable interrupt (1) or mask out (0)*/
#ifndef MRV_ISP_MIS_ISP_OFF
#define MRV_ISP_MIS_ISP_OFF_MASK               0U	/* make sure, that this mask is defined for the combination mask */
#endif /* !MRV_ISP_MIS_ISP_OFF */
/* combination of all interrupt lines */
#define MRV_ISP_MIS_ALL_IRQS
#define MRV_ISP_MIS_ALL_IRQS_MASK \
	(0 \
	| MRV_ISP_MIS_VSM_END_MASK \
	| MRV_ISP_MIS_EXP_END_MASK \
	| MRV_ISP_MIS_FLASH_CAP_MASK \
	| MRV_ISP_MIS_BP_DET_MASK \
	| MRV_ISP_MIS_HIST_MEASURE_RDY_MASK \
	| MRV_ISP_MIS_AFM_FIN_MASK \
	| MRV_ISP_MIS_AFM_LUM_OF_MASK \
	| MRV_ISP_MIS_AFM_SUM_OF_MASK \
	| MRV_ISP_MIS_SHUTTER_OFF_MASK \
	| MRV_ISP_MIS_SHUTTER_ON_MASK \
	| MRV_ISP_MIS_FLASH_OFF_MASK \
	| MRV_ISP_MIS_FLASH_ON_MASK \
	| MRV_ISP_MIS_H_START_MASK \
	| MRV_ISP_MIS_V_START_MASK \
	| MRV_ISP_MIS_FRAME_IN_MASK \
	| MRV_ISP_MIS_AWB_DONE_MASK \
	| MRV_ISP_MIS_PIC_SIZE_ERR_MASK \
	| MRV_ISP_MIS_DATA_LOSS_MASK \
	| MRV_ISP_MIS_FRAME_MASK \
	| MRV_ISP_MIS_ISP_OFF_MASK \
	)
#define MRV_ISP_MIS_ALL_IRQS_SHIFT             0U
/*****************************************************************************/
/**
 * register: isp_icr: Interrupt clear register (0x000001c8)
 *
 *****************************************************************************/
/*! Slice: ICR_VSM_END:*/
/*! clear interrupt */
#ifndef MRV_ISP_ICR_VSM_END
#define MRV_ISP_ICR_VSM_END_MASK               0U	/* make sure, that this mask is defined for the combination mask */
#endif /* !MRV_ISP_ICR_VSM_END */
/* Slice: ICR_EXP_END:*/
/* enable interrupt (1) or mask out (0)*/
#ifndef MRV_ISP_ICR_EXP_END
#define MRV_ISP_ICR_EXP_END_MASK               0U	/* make sure, that this mask is defined for the combination mask */
#endif /* !MRV_ISP_ICR_EXP_END */
/* Slice: ICR_FLASH_CAP:*/
/* enable interrupt (1) or mask out (0)*/
#ifndef MRV_ISP_ICR_FLASH_CAP
#define MRV_ISP_ICR_FLASH_CAP_MASK             0U	/* make sure, that this mask is defined for the combination mask */
#endif /* !MRV_ISP_ICR_FLASH_CAP */
/* Slice: ICR_BP_DET:*/
/* enable interrupt (1) or mask out (0)*/
#ifndef MRV_ISP_ICR_BP_DET
#define MRV_ISP_ICR_BP_DET_MASK                0U	/* make sure, that this mask is defined for the combination mask */
#endif /* !MRV_ISP_ICR_BP_DET */
/* Slice: ICR_HIST_MEASURE_RDY:*/
/* enable interrupt (1) or mask out (0)*/
#ifndef MRV_ISP_ICR_HIST_MEASURE_RDY
#define MRV_ISP_ICR_HIST_MEASURE_RDY_MASK              0U	/* make sure, that this mask is defined for the combination mask */
#endif /* !MRV_ISP_ICR_HIST_MEASURE_RDY */
/* Slice: ICR_AFM_FIN:*/
/* enable interrupt (1) or mask out (0)*/
#ifndef MRV_ISP_ICR_AFM_FIN
#define MRV_ISP_ICR_AFM_FIN_MASK               0U	/* make sure, that this mask is defined for the combination mask */
#endif /* !ICR_AFM_FIN */
/* Slice: ICR_AFM_LUM_OF:*/
/* enable interrupt (1) or mask out (0)*/
#ifndef MRV_ISP_ICR_AFM_LUM_OF
#define MRV_ISP_ICR_AFM_LUM_OF_MASK            0U	/* make sure, that this mask is defined for the combination mask */
#endif /* !MRV_ISP_ICR_AFM_LUM_OF */
/* Slice: ICR_AFM_SUM_OF:*/
/* enable interrupt (1) or mask out (0)*/
#ifndef MRV_ISP_ICR_AFM_SUM_OF
#define MRV_ISP_ICR_AFM_SUM_OF_MASK            0U	/* make sure, that this mask is defined for the combination mask */
#endif /* !MRV_ISP_ICR_AFM_SUM_OF */
/* Slice: ICR_SHUTTER_OFF:*/
/* enable interrupt (1) or mask out (0)*/
#ifndef MRV_ISP_ICR_SHUTTER_OFF
#define MRV_ISP_ICR_SHUTTER_OFF_MASK           0U	/* make sure, that this mask is defined for the combination mask */
#endif /* !MRV_ISP_ICR_SHUTTER_OFF */
/* Slice: ICR_SHUTTER_ON:*/
/* enable interrupt (1) or mask out (0)*/
#ifndef MRV_ISP_ICR_SHUTTER_ON
#define MRV_ISP_ICR_SHUTTER_ON_MASK            0U	/* make sure, that this mask is defined for the combination mask */
#endif /* !MRV_ISP_ICR_SHUTTER_ON */
/* Slice: ICR_FLASH_OFF:*/
/* enable interrupt (1) or mask out (0)*/
#ifndef MRV_ISP_ICR_FLASH_OFF
#define MRV_ISP_ICR_FLASH_OFF_MASK             0U	/* make sure, that this mask is defined for the combination mask */
#endif /* !MRV_ISP_ICR_FLASH_OFF */
/* Slice: ICR_FLASH_ON:*/
/* enable interrupt (1) or mask out (0)*/
#ifndef MRV_ISP_ICR_FLASH_ON
#define MRV_ISP_ICR_FLASH_ON_MASK              0U	/* make sure, that this mask is defined for the combination mask */
#endif /* !MRV_ISP_ICR_FLASH_ON */
/* Slice: ICR_H_START:*/
/* enable interrupt (1) or mask out (0)*/
#ifndef MRV_ISP_ICR_H_START
#define MRV_ISP_ICR_H_START_MASK               0U	/* make sure, that this mask is defined for the combination mask */
#endif /* !MRV_ISP_ICR_H_START */
/* Slice: ICR_V_START:*/
/* enable interrupt (1) or mask out (0)*/
#ifndef MRV_ISP_ICR_V_START
#define MRV_ISP_ICR_V_START_MASK               0U	/* make sure, that this mask is defined for the combination mask */
#endif /* !MRV_ISP_ICR_V_START */
/* Slice: ICR_FRAME_IN:*/
/* enable interrupt (1) or mask out (0)*/
#ifndef MRV_ISP_ICR_FRAME_IN
#define MRV_ISP_ICR_FRAME_IN_MASK              0U	/* make sure, that this mask is defined for the combination mask */
#endif /* !MRV_ISP_ICR_FRAME_IN */
/* Slice: ICR_AWB_DONE:*/
/* enable interrupt (1) or mask out (0)*/
#ifndef MRV_ISP_ICR_AWB_DONE
#define MRV_ISP_ICR_AWB_DONE_MASK              0U	/* make sure, that this mask is defined for the combination mask */
#endif /* !MRV_ISP_ICR_AWB_DONE */
/* Slice: ICR_PIC_SIZE_ERR:*/
/* enable interrupt (1) or mask out (0)*/
#ifndef MRV_ISP_ICR_PIC_SIZE_ERR
#define MRV_ISP_ICR_PIC_SIZE_ERR_MASK          0U	/* make sure, that this mask is defined for the combination mask */
#endif /* !MRV_ISP_ICR_PIC_SIZE_ERR */
/* Slice: ICR_DATA_LOSS:*/
/* enable interrupt (1) or mask out (0)*/
#ifndef MRV_ISP_ICR_DATA_LOSS
#define MRV_ISP_ICR_DATA_LOSS_MASK             0U	/* make sure, that this mask is defined for the combination mask */
#endif /* !MRV_ISP_ICR_DATA_LOSS */
/* Slice: ICR_FRAME:*/
/* enable interrupt (1) or mask out (0)*/
#ifndef MRV_ISP_ICR_FRAME
#define MRV_ISP_ICR_FRAME_MASK                 0U	/* make sure, that this mask is defined for the combination mask */
#endif /* !MRV_ISP_ICR_FRAME */
/* Slice: ICR_ISP_OFF:*/
/* enable interrupt (1) or mask out (0)*/
#ifndef MRV_ISP_ICR_ISP_OFF
#define MRV_ISP_ICR_ISP_OFF_MASK               0U	/* make sure, that this mask is defined for the combination mask */
#endif /* !MRV_ISP_ICR_ISP_OFF */
/* combination of all interrupt lines */
#define MRV_ISP_ICR_ALL_IRQS
#define MRV_ISP_ICR_ALL_IRQS_MASK \
(0	\
	| MRV_ISP_ICR_VSM_END_MASK \
	| MRV_ISP_ICR_EXP_END_MASK \
	| MRV_ISP_ICR_FLASH_CAP_MASK \
	| MRV_ISP_ICR_BP_DET_MASK \
	| MRV_ISP_ICR_HIST_MEASURE_RDY_MASK \
	| MRV_ISP_ICR_AFM_FIN_MASK \
	| MRV_ISP_ICR_AFM_LUM_OF_MASK \
	| MRV_ISP_ICR_AFM_SUM_OF_MASK \
	| MRV_ISP_ICR_SHUTTER_OFF_MASK \
	| MRV_ISP_ICR_SHUTTER_ON_MASK \
	| MRV_ISP_ICR_FLASH_OFF_MASK \
	| MRV_ISP_ICR_FLASH_ON_MASK \
	| MRV_ISP_ICR_H_START_MASK \
	| MRV_ISP_ICR_V_START_MASK \
	| MRV_ISP_ICR_FRAME_IN_MASK \
	| MRV_ISP_ICR_AWB_DONE_MASK \
	| MRV_ISP_ICR_PIC_SIZE_ERR_MASK \
	| MRV_ISP_ICR_DATA_LOSS_MASK \
	| MRV_ISP_ICR_FRAME_MASK \
	| MRV_ISP_ICR_ISP_OFF_MASK \
)
#define MRV_ISP_ICR_ALL_IRQS_SHIFT             0U
/*****************************************************************************/
/**
 * register: isp_isr: Interrupt set register (0x000001cc)
 *
 *****************************************************************************/
/*! Register: isp_isr: Interrupt set register (0x000001cc)*/
/*! Slice: ISR_VSM_END:*/
/*! set interrupt */
#ifndef MRV_ISP_ISR_VSM_END
#define MRV_ISP_ISR_VSM_END_MASK               0U	/* make sure, that this mask is defined for the combination mask */
#endif /* !MRV_ISP_ISR_VSM_END */
/* Slice: ISR_EXP_END:*/
/* enable interrupt (1) or mask out (0)*/
#ifndef MRV_ISP_ISR_EXP_END
#define MRV_ISP_ISR_EXP_END_MASK               0U	/* make sure, that this mask is defined for the combination mask */
#endif /* !MRV_ISP_ISR_EXP_END */
/* Slice: ISR_FLASH_CAP:*/
/* enable interrupt (1) or mask out (0)*/
#ifndef MRV_ISP_ISR_FLASH_CAP
#define MRV_ISP_ISR_FLASH_CAP_MASK             0U	/* make sure, that this mask is defined for the combination mask */
#endif /* !MRV_ISP_ISR_FLASH_CAP */
/* Slice: ISR_BP_DET:*/
/* enable interrupt (1) or mask out (0)*/
#ifndef MRV_ISP_ISR_BP_DET
#define MRV_ISP_ISR_BP_DET_MASK                0U	/* make sure, that this mask is defined for the combination mask */
#endif /* !MRV_ISP_ISR_BP_DET */
/* Slice: ISR_HIST_MEASURE_RDY:*/
/* enable interrupt (1) or mask out (0)*/
#ifndef MRV_ISP_ISR_HIST_MEASURE_RDY
#define MRV_ISP_ISR_HIST_MEASURE_RDY_MASK              0U	/* make sure, that this mask is defined for the combination mask */
#endif /* !MRV_ISP_ISR_HIST_MEASURE_RDY */
/* Slice: ISR_AFM_FIN:*/
/* enable interrupt (1) or mask out (0)*/
#ifndef MRV_ISP_ISR_AFM_FIN
#define MRV_ISP_ISR_AFM_FIN_MASK               0U	/* make sure, that this mask is defined for the combination mask */
#endif /* !ISR_AFM_FIN */
/* Slice: ISR_AFM_LUM_OF:*/
/* enable interrupt (1) or mask out (0)*/
#ifndef MRV_ISP_ISR_AFM_LUM_OF
#define MRV_ISP_ISR_AFM_LUM_OF_MASK            0U	/* make sure, that this mask is defined for the combination mask */
#endif /* !MRV_ISP_ISR_AFM_LUM_OF */
/* Slice: ISR_AFM_SUM_OF:*/
/* enable interrupt (1) or mask out (0)*/
#ifndef MRV_ISP_ISR_AFM_SUM_OF
#define MRV_ISP_ISR_AFM_SUM_OF_MASK            0U	/* make sure, that this mask is defined for the combination mask */
#endif /* !MRV_ISP_ISR_AFM_SUM_OF */
/* Slice: ISR_SHUTTER_OFF:*/
/* enable interrupt (1) or mask out (0)*/
#ifndef MRV_ISP_ISR_SHUTTER_OFF
#define MRV_ISP_ISR_SHUTTER_OFF_MASK           0U	/* make sure, that this mask is defined for the combination mask */
#endif /* !MRV_ISP_ISR_SHUTTER_OFF */
/* Slice: ISR_SHUTTER_ON:*/
/* enable interrupt (1) or mask out (0)*/
#ifndef MRV_ISP_ISR_SHUTTER_ON
#define MRV_ISP_ISR_SHUTTER_ON_MASK            0U	/* make sure, that this mask is defined for the combination mask */
#endif /* !MRV_ISP_ISR_SHUTTER_ON */
/* Slice: ISR_FLASH_OFF:*/
/* enable interrupt (1) or mask out (0)*/
#ifndef MRV_ISP_ISR_FLASH_OFF
#define MRV_ISP_ISR_FLASH_OFF_MASK             0U	/* make sure, that this mask is defined for the combination mask */
#endif /* !MRV_ISP_ISR_FLASH_OFF */
/* Slice: ISR_FLASH_ON:*/
/* enable interrupt (1) or mask out (0)*/
#ifndef MRV_ISP_ISR_FLASH_ON
#define MRV_ISP_ISR_FLASH_ON_MASK              0U	/* make sure, that this mask is defined for the combination mask */
#endif /* !MRV_ISP_ISR_FLASH_ON */
/* Slice: ISR_H_START:*/
/* enable interrupt (1) or mask out (0)*/
#ifndef MRV_ISP_ISR_H_START
#define MRV_ISP_ISR_H_START_MASK               0U	/* make sure, that this mask is defined for the combination mask */
#endif /* !MRV_ISP_ISR_H_START */
/* Slice: ISR_V_START:*/
/* enable interrupt (1) or mask out (0)*/
#ifndef MRV_ISP_ISR_V_START
#define MRV_ISP_ISR_V_START_MASK               0U	/* make sure, that this mask is defined for the combination mask */
#endif /* !MRV_ISP_ISR_V_START */
/* Slice: ISR_FRAME_IN:*/
/* enable interrupt (1) or mask out (0)*/
#ifndef MRV_ISP_ISR_FRAME_IN
#define MRV_ISP_ISR_FRAME_IN_MASK              0U	/* make sure, that this mask is defined for the combination mask */
#endif /* !MRV_ISP_ISR_FRAME_IN */
/* Slice: ISR_AWB_DONE:*/
/* enable interrupt (1) or mask out (0)*/
#ifndef MRV_ISP_ISR_AWB_DONE
#define MRV_ISP_ISR_AWB_DONE_MASK              0U	/* make sure, that this mask is defined for the combination mask */
#endif /* !MRV_ISP_ISR_AWB_DONE */
/* Slice: ISR_PIC_SIZE_ERR:*/
/* enable interrupt (1) or mask out (0)*/
#ifndef MRV_ISP_ISR_PIC_SIZE_ERR
#define MRV_ISP_ISR_PIC_SIZE_ERR_MASK          0U	/* make sure, that this mask is defined for the combination mask */
#endif /* !MRV_ISP_ISR_PIC_SIZE_ERR */
/* Slice: ISR_DATA_LOSS:*/
/* enable interrupt (1) or mask out (0)*/
#ifndef MRV_ISP_ISR_DATA_LOSS
#define MRV_ISP_ISR_DATA_LOSS_MASK             0U	/* make sure, that this mask is defined for the combination mask */
#endif /* !MRV_ISP_ISR_DATA_LOSS */
/* Slice: ISR_FRAME:*/
/* enable interrupt (1) or mask out (0)*/
#ifndef MRV_ISP_ISR_FRAME
#define MRV_ISP_ISR_FRAME_MASK                 0U	/* make sure, that this mask is defined for the combination mask */
#endif /* !MRV_ISP_ISR_FRAME */
/* Slice: ISR_ISP_OFF:*/
/* enable interrupt (1) or mask out (0)*/
#ifndef MRV_ISP_ISR_ISP_OFF
#define MRV_ISP_ISR_ISP_OFF_MASK               0U	/* make sure, that this mask is defined for the combination mask */
#endif /* !MRV_ISP_ISR_ISP_OFF */
/* combination of all interrupt lines */
#define MRV_ISP_ISR_ALL_IRQS
#define MRV_ISP_ISR_ALL_IRQS_MASK \
(0 \
	| MRV_ISP_ISR_VSM_END_MASK \
	| MRV_ISP_ISR_EXP_END_MASK \
	| MRV_ISP_ISR_FLASH_CAP_MASK \
	| MRV_ISP_ISR_BP_DET_MASK \
	| MRV_ISP_ISR_HIST_MEASURE_RDY_MASK \
	| MRV_ISP_ISR_AFM_FIN_MASK \
	| MRV_ISP_ISR_AFM_LUM_OF_MASK \
	| MRV_ISP_ISR_AFM_SUM_OF_MASK \
	| MRV_ISP_ISR_SHUTTER_OFF_MASK \
	| MRV_ISP_ISR_SHUTTER_ON_MASK \
	| MRV_ISP_ISR_FLASH_OFF_MASK \
	| MRV_ISP_ISR_FLASH_ON_MASK \
	| MRV_ISP_ISR_H_START_MASK \
	| MRV_ISP_ISR_V_START_MASK \
	| MRV_ISP_ISR_FRAME_IN_MASK \
	| MRV_ISP_ISR_AWB_DONE_MASK \
	| MRV_ISP_ISR_PIC_SIZE_ERR_MASK \
	| MRV_ISP_ISR_DATA_LOSS_MASK \
	| MRV_ISP_ISR_FRAME_MASK \
	| MRV_ISP_ISR_ISP_OFF_MASK \
)
#define MRV_ISP_ISR_ALL_IRQS_SHIFT             0U
/*****************************************************************************/
/**
 * register array: isp_ct_coeff: cross-talk configuration register (color
 *                 correction matrix) (0x03A0 + n*0x4 (n=0..8))
 *
 *****************************************************************************/
/* Slice: ct_coeff:*/
/* Coefficient n for cross talk matrix.*/
     /**/
/* Values are 11-bit signed fixed-point numbers with 4 bit integer and */
/* 7 bit fractional part, ranging from -8 (0x400) to +7.992 (0x3FF).*/
/* 0 is reprsented by 0x000 and a coefficient value of 1 as 0x080.*/
#ifdef MRV_ISP_CT_COEFF
#define MRV_ISP_CT_COEFF_DEFAULT                0x080U	/* default value */
#endif /* MRV_ISP_CT_COEFF */
/*****************************************************************************/
/**
 * register: isp_gamma_out_mode: gamma segmentation mode register for output
 *           gamma (0x000001f4)
 *
 *****************************************************************************/
/* Slice: equ_segm:*/
/* 0: logarithmic like segmentation of gamma curve (default after reset)*/
/*   segmentation from 0 to 4095: 64 64 64 64 128 128 128 128 256 256 256 512 512 512 512 512 */
/* 1: equidistant segmentation (all 16 segments are 256)*/
#ifdef MRV_ISP_EQU_SEGM
#define MRV_ISP_EQU_SEGM_LOG                    0	/* 0: logarithmic like segmentation of gamma curve (default after reset) */
#define MRV_ISP_EQU_SEGM_EQU                    1	/* 1: equidistant segmentation (all 16 segments are 256) */
#endif /* MRV_ISP_EQU_SEGM */
/*****************************************************************************/
/**
 * register array: isp_gamma_out_y: Gamma Out Curve definition y (0x03F0 + n*0x4 (n=0..16))
 *
 *****************************************************************************/
/* Slice: isp_gamma_out_y:*/
/* Gamma_out curve point definition y-axis (output) for all color */
/* components (red, green, blue)*/
/* RESTRICTION: each Y_n must be in the +511/-512 range compared */
/* to its predecessor (so that dy is 10-bit signed !)*/
#ifdef MRV_ISP_ISP_GAMMA_OUT_Y
#endif /* MRV_ISP_ISP_GAMMA_OUT_Y */
/*****************************************************************************/
/**
 * register: isp_err: ISP error register (0x0000023c)
 *
 *****************************************************************************/
/* Slice: outform_size_err:*/
/* size error is generated in outmux submodule */
#ifdef MRV_ISP_OUTFORM_SIZE_ERR
#endif /* MRV_ISP_OUTFORM_SIZE_ERR */
/* Slice: is_size_err:*/
/* size error is generated in image stabilization submodule */
#ifdef MRV_ISP_IS_SIZE_ERR
#endif /* MRV_ISP_IS_SIZE_ERR */
/* Slice: inform_size_err:*/
/* size error is generated in inform submodule */
#ifdef MRV_ISP_INFORM_SIZE_ERR
#endif /* MRV_ISP_INFORM_SIZE_ERR */
/*****************************************************************************/
/**
 * register: isp_err_clr: ISP error clear register (0x00000240)
 *
 *****************************************************************************/
/* Slice: outform_size_err_clr:*/
/* size error is cleared */
#ifdef MRV_ISP_OUTFORM_SIZE_ERR_CLR
#endif /* MRV_ISP_OUTFORM_SIZE_ERR_CLR */
/* Slice: is_size_err_clr:*/
/* size error is cleared */
#ifdef MRV_ISP_IS_SIZE_ERR_CLR
#endif /* MRV_ISP_IS_SIZE_ERR_CLR */
/* Slice: inform_size_err_clr:*/
/* size error is cleared */
#ifdef MRV_ISP_INFORM_SIZE_ERR_CLR
#endif /* MRV_ISP_INFORM_SIZE_ERR_CLR */
/*****************************************************************************/
/**
 * register: isp_frame_count: Frame counter (0x00000244)
 *
 *****************************************************************************/
/* Slice: frame_counter:*/
/* Current frame count of processing */
#ifdef MRV_ISP_FRAME_COUNTER
#endif /* MRV_ISP_FRAME_COUNTER */
/*****************************************************************************/
/**
 * register: isp_ct_offset_r: cross-talk offset red (0x00000248)
 *
 *****************************************************************************/
/* Slice: ct_offset_r:*/
/* Offset red for cross talk matrix. Two's complement integer number ranging */
/* from -2048 (0x800) to 2047 (0x7FF). 0 is represented as 0x000.*/
#ifdef MRV_ISP_CT_OFFSET_R
#define MRV_ISP_CT_OFFSET_R_DEFAULT             0x000U	/* default value */
#endif /* MRV_ISP_CT_OFFSET_R */
/*****************************************************************************/
/**
 * register: isp_ct_offset_g: cross-talk offset green (0x0000024c)
 *
 *****************************************************************************/
/* Slice: ct_offset_g:*/
/* Offset green for cross talk matrix. Two's complement integer number ranging */
/* from -2048 (0x800) to 2047 (0x7FF). 0 is represented as 0x000.*/
#ifdef MRV_ISP_CT_OFFSET_G
#define MRV_ISP_CT_OFFSET_G_DEFAULT             0x000U	/* default value */
#endif /* MRV_ISP_CT_OFFSET_G */
/*****************************************************************************/
/**
 * register: isp_ct_offset_b: cross-talk offset blue (0x00000250)
 *
 *****************************************************************************/
/* Slice: ct_offset_b:*/
/* Offset blue for cross talk matrix. Two's complement integer number ranging */
/* from -2048 (0x800) to 2047 (0x7FF). 0 is represented as 0x000.*/
#ifdef MRV_ISP_CT_OFFSET_B
#define MRV_ISP_CT_OFFSET_B_DEFAULT             0x000U	/* default value */
#endif /* MRV_ISP_CT_OFFSET_B */
/*****************************************************************************/
/* ISP Flash Module Registers                                                */
/*****************************************************************************/
/*****************************************************************************/
/**
 * register: isp_flash_cmd: Flash command (0x0000)
 *
 *****************************************************************************/
/* Slice: preflash_on:*/
/* preflash on */
/* 0: no effect */
/* 1: flash delay counter is started at next trigger event */
/* No capture event is signaled to the sensor interface block.*/
#ifdef MRV_FLASH_PREFLASH_ON
#endif /* MRV_FLASH_PREFLASH_ON */
/* Slice: flash_on:*/
/* flash on */
/* 0: no effect */
/* 1: flash delay counter is started at next trigger event */
/* A capture event is signaled to the sensor interface block.*/
#ifdef MRV_FLASH_FLASH_ON
#endif /* MRV_FLASH_FLASH_ON */
/* Slice: prelight_on:*/
/* prelight on */
/* 0: prelight is switched off at next trigger event */
/* 1: prelight is switched on at next trigger event */
#ifdef MRV_FLASH_PRELIGHT_ON
#endif /* MRV_FLASH_PRELIGHT_ON */
/*****************************************************************************/
/**
 * register: isp_flash_config: Flash config (0x0004)
 *
 *****************************************************************************/
/* Slice: fl_cap_del:*/
/* capture delay */
/* frame number (0 to 15) to be captured after trigger event */
#ifdef MRV_FLASH_FL_CAP_DEL
#endif /* MRV_FLASH_FL_CAP_DEL */
/* Slice: fl_trig_src:*/
/* trigger source for flash and prelight */
/* 0: use "vds_vsync" for trigger event (with evaluation of vs_in_edge)*/
/* 1: use "fl_trig" for trigger event (positive edge)*/
#ifdef MRV_FLASH_FL_TRIG_SRC
#define MRV_FLASH_FL_TRIG_SRC_VDS               0	/* 0: use "vds_vsync" for trigger event (with evaluation of vs_in_edge) */
#define MRV_FLASH_FL_TRIG_SRC_FL                1	/* 1: use "fl_trig" for trigger event (positive edge) */
#endif /* MRV_FLASH_FL_TRIG_SRC */
/* Slice: fl_pol:*/
/* polarity of flash related signals */
/* 0: flash_trig, prelight_trig are high active */
/* 1: flash_trig, prelight_trig are low active */
#ifdef MRV_FLASH_FL_POL
#define MRV_FLASH_FL_POL_HIGH                   0	/* 0: flash_trig, prelight_trig are high active */
#define MRV_FLASH_FL_POL_LOW                    1	/* 1: flash_trig, prelight_trig are low active */
#endif /* MRV_FLASH_FL_POL */
/* Slice: vs_in_edge:*/
/* VSYNC edge */
/* 0: use negative edge of "vds_vsync" if generating a trigger event */
/* 1: use positive edge of "vds_vsync" if generating a trigger event */
#ifdef MRV_FLASH_VS_IN_EDGE
#define MRV_FLASH_VS_IN_EDGE_NEG                0	/* 0: use negative edge of "vds_vsync" if generating a trigger event */
#define MRV_FLASH_VS_IN_EDGE_POS                1	/* 1: use positive edge of "vds_vsync" if generating a trigger event */
#endif /* MRV_FLASH_VS_IN_EDGE */
/* Slice: prelight_mode:*/
/* prelight mode */
/* 0: prelight is switched off at begin of flash */
/* 1: prelight is switched off at end of flash */
#ifdef MRV_FLASH_PRELIGHT_MODE
#define MRV_FLASH_PRELIGHT_MODE_OASF            0	/* 0: prelight is switched off at begin of flash */
#define MRV_FLASH_PRELIGHT_MODE_OAEF            1	/* 1: prelight is switched off at end of flash */
#endif /* MRV_FLASH_PRELIGHT_MODE */
/*****************************************************************************/
/**
 * register: isp_flash_prediv: Flash Counter Pre-Divider (0x00000008)
 *
 *****************************************************************************/
/* Slice: fl_pre_div:*/
/* pre-divider for flush/preflash counter */
#ifdef MRV_FLASH_FL_PRE_DIV
#endif /* MRV_FLASH_FL_PRE_DIV */
/*****************************************************************************/
/**
 * register: isp_flash_delay: Flash Delay (0x000c)
 *
 *****************************************************************************/
/* Slice: fl_delay:*/
/* counter value for flash/preflash delay */
/* open_delay   =  (fl_delay + 1) * (fl_pre_div+1) / clk_isp */
/* fl_delay     =  (open_delay * clk_isp) / (fl_pre_div+1) - 1 */
#ifdef MRV_FLASH_FL_DELAY
#endif /* MRV_FLASH_FL_DELAY */
/*****************************************************************************/
/**
 * register: isp_flash_time: Flash time (0x00000010)
 *
 *****************************************************************************/
/* Slice: fl_time:*/
/* counter value for flash/preflash time */
/* open_time =  (fl_time + 1) * (fl_pre_div+1) / clk_isp */
/* fl_time =  (open_time * clk_isp) / (fl_pre_div+1) - 1 */
#ifdef MRV_FLASH_FL_TIME
#endif /* MRV_FLASH_FL_TIME */
/*****************************************************************************/
/**
 * register: isp_flash_maxp: Maximum value for flash or preflash (0x00000014)
 *
 *****************************************************************************/
/* Slice: fl_maxp:*/
/* maximum period value for flash or preflash */
/* max. flash/preflash period = 214 * (fl_maxp + 1) / clk_isp */
/* fl_maxp =  (max_period * clk_isp) / 214  - 1 */
#ifdef MRV_FLASH_FL_MAXP
#endif /* MRV_FLASH_FL_MAXP */
/*****************************************************************************/
/* ISP Shutter Module Registers                                              */
/*****************************************************************************/
/*****************************************************************************/
/**
 * register: isp_sh_ctrl: mechanical shutter control (0x0000)
 *
 *****************************************************************************/
/* Slice: sh_open_pol:*/
/* shutter_open polarity */
/* 0: shutter_open is high active */
/* 1: shutter_open is low active */
#ifdef MRV_SHUT_SH_OPEN_POL
#define MRV_SHUT_SH_OPEN_POL_HIGH               0	/* 0: shutter_open is high active */
#define MRV_SHUT_SH_OPEN_POL_LOW                1	/* 1: shutter_open is low active */
#endif /* MRV_SHUT_SH_OPEN_POL */
/* Slice: sh_trig_en:*/
/* mechanical shutter trigger edge */
/* 0: use negative edge of trigger signal */
/* 1: use positive edge of trigger signal */
#ifdef MRV_SHUT_SH_TRIG_EN
#define MRV_SHUT_SH_TRIG_EN_NEG                 0	/* 0: use negative edge of trigger signal */
#define MRV_SHUT_SH_TRIG_EN_POS                 1	/* 1: use positive edge of trigger signal */
#endif /* MRV_SHUT_SH_TRIG_EN */
/* Slice: sh_trig_src:*/
/* mechanical shutter trigger source */
/* 0: use "vds_vsync" for trigger event */
/* 1: use "shutter_trig" for trigger event */
#ifdef MRV_SHUT_SH_TRIG_SRC
#define MRV_SHUT_SH_TRIG_SRC_VDS                0	/* 0: use "vds_vsync" for trigger event */
#define MRV_SHUT_SH_TRIG_SRC_SHUT               1	/* 1: use "shutter_trig" for trigger event */
#endif /* MRV_SHUT_SH_TRIG_SRC */
/* Slice: sh_rep_en:*/
/* mechanical shutter repetition enable */
/* 0: shutter is opened only once */
/* 1: shutter is opened with the repetition rate of the trigger signal */
#ifdef MRV_SHUT_SH_REP_EN
#define MRV_SHUT_SH_REP_EN_ONCE                 0	/* 0: shutter is opened only once */
#define MRV_SHUT_SH_REP_EN_REP                  1	/* 1: shutter is opened with the repetition rate of the trigger signal */
#endif /* MRV_SHUT_SH_REP_EN */
/* Slice: sh_en:*/
/* mechanical shutter enable */
/* 0: mechanical shutter function is disabled */
/* 1: mechanical shutter function is enabled */
#ifdef MRV_SHUT_SH_EN
#endif /* MRV_SHUT_SH_EN */
/*****************************************************************************/
/**
 * register: isp_sh_prediv: Mech. Shutter Counter Pre-Divider (0x0004)
 *
 *****************************************************************************/
/* Slice: sh_pre_div:*/
/* pre-divider for mechanical shutter open_delay and open_time counter */
#ifdef MRV_SHUT_SH_PRE_DIV
#endif /* MRV_SHUT_SH_PRE_DIV */
/*****************************************************************************/
/**
 * register: isp_sh_delay: Delay register (0x00000008)
 *
 *****************************************************************************/
/* Slice: sh_delay:*/
/* counter value for delay */
/* open_delay =  (sh_delay + 1) * (fl_pre_div+1) / clk_isp */
/* sh_delay =  (open_delay * clk_isp) / (sh_pre_div+1)  1 */
#ifdef MRV_SHUT_SH_DELAY
#endif /* MRV_SHUT_SH_DELAY */
/*****************************************************************************/
/**
 * register: isp_sh_time: Time register (0x0000000c)
 *
 *****************************************************************************/
/* Slice: sh_time:*/
/* counter value for time */
/* open_time =  (sh_time + 1) * (fl_pre_div+1) / clk_isp */
/* sh_time =  (open_time * clk_isp) / (sh_pre_div+1) - 1 */
#ifndef MRV_SHUT_SH_TIME
#endif /* MRV_SHUT_SH_TIME */
/*****************************************************************************/
/* Color Processing Module Registers                                         */
/*****************************************************************************/
/*****************************************************************************/
/**
 * register: c_proc_ctrl: Global control register (0x0000)
 *
 *****************************************************************************/
/* Slice: cproc_c_out_range:*/
/* Color processing chrominance pixel clipping range at output */
/* 0: CbCr_out clipping range 16..240 according to ITU-R BT.601 standard */
/* 1: full UV_out clipping range 0..255 */
#ifdef MRV_CPROC_CPROC_C_OUT_RANGE
#define MRV_CPROC_CPROC_C_OUT_RANGE_BT601       0	/* 0: CbCr_out clipping range 16..240 according to ITU-R BT.601 standard */
#define MRV_CPROC_CPROC_C_OUT_RANGE_FULL        1	/* 1: full UV_out clipping range 0..255 */
#endif /* MRV_CPROC_CPROC_C_OUT_RANGE */
/* Slice: cproc_y_in_range:*/
/* Color processing luminance input range (offset processing)*/
/* 0: Y_in range 64..940 according to ITU-R BT.601 standard;*/
/* offset of 64 will be subtracted from Y_in */
/* 1: Y_in full range 0..1023;  no offset will be subtracted from Y_in */
#ifdef MRV_CPROC_CPROC_Y_IN_RANGE
#define MRV_CPROC_CPROC_Y_IN_RANGE_BT601        0	/* 0: Y_in range 64..940 according to ITU-R BT.601 standard */
#define MRV_CPROC_CPROC_Y_IN_RANGE_FULL         1	/* 1: Y_in full range 0..1023 */
#endif /* MRV_CPROC_CPROC_Y_IN_RANGE */
/* Slice: cproc_y_out_range:*/
/* Color processing luminance output clipping range */
/* 0: Y_out clipping range 16..235; offset of 16 is added to Y_out according to ITU-R BT.601 standard */
/* 1: Y_out clipping range 0..255; no offset is added to Y_out */
#ifdef MRV_CPROC_CPROC_Y_OUT_RANGE
#define MRV_CPROC_CPROC_Y_OUT_RANGE_BT601       0	/* 0: Y_out clipping range 16..235; offset of 16 is added to Y_out according to ITU-R BT.601 standard */
#define MRV_CPROC_CPROC_Y_OUT_RANGE_FULL        1	/* 1: Y_out clipping range 0..255; no offset is added to Y_out */
#endif /* MRV_CPROC_CPROC_Y_OUT_RANGE */
/* Slice: cproc_enable:*/
/* color processing enable */
/* 0: color processing is bypassed */
/* 2 * 10 Bit input data are truncated to 2 * 8Bit output data */
/* 1: color processing is active */
/* output data are rounded to 2 * 8Bit and clipping is active */
#ifdef MRV_CPROC_CPROC_ENABLE
#define MRV_CPROC_CPROC_ENABLE_PROCESS          1	/* 1: processing is activated */
#define MRV_CPROC_CPROC_ENABLE_BYPASS           0	/* 0: processing is deactivated, bypass mode is selected */
#endif /* MRV_CPROC_CPROC_ENABLE */
/*****************************************************************************/
/**
 * register: c_proc_contrast: Color Processing contrast register (0x0004)
 *
 *****************************************************************************/
/* Slice: cproc_contrast:*/
/* contrast adjustment value */
/* 00H equals x 0.0 */
/* ...*/
/* 80H equals x 1.0 */
/* ...*/
/* FFH equals x 1.992 */
#ifdef MRV_CPROC_CPROC_CONTRAST
#endif /* MRV_CPROC_CPROC_CONTRAST */
/*****************************************************************************/
/**
 * register: c_proc_brightness: Color Processing brightness register (0x0008)
 *
 *****************************************************************************/
/* Slice: cproc_brightness:*/
/* brightness adjustment value */
/* 80H equals -128 */
/* ...*/
/* 00H equals +0 */
/* ...*/
/* 7FH equals +127 */
#ifdef MRV_CPROC_CPROC_BRIGHTNESS
#endif /* MRV_CPROC_CPROC_BRIGHTNESS */
/*****************************************************************************/
/**
 * register: c_proc_saturation: Color Processing saturation register (0x000c)
 *
 *****************************************************************************/
/* Slice: cproc_saturation:*/
/* saturation adjustment value */
/* 00H equals x 0.0 */
/* ...*/
/* 80H equals x 1.0 */
/* ...*/
/* FFH equals x 1.992 */
#ifdef MRV_CPROC_CPROC_SATURATION
#endif /* MRV_CPROC_CPROC_SATURATION */
/*****************************************************************************/
/**
 * register: c_proc_hue: Color Processing hue register (0x0010)
 *
 *****************************************************************************/
/* Slice: cproc_hue:*/
/* hue adjustment value */
/* 80H equals -90 deg */
/* ...*/
/* 00H equals 0 deg */
/* ...*/
/* 7FH equals +87.188 deg */
#ifdef MRV_CPROC_CPROC_HUE
#endif /* MRV_CPROC_CPROC_HUE */
/*****************************************************************************/
/* Main Resizer/Scaler Registers                                             */
/*****************************************************************************/
/*****************************************************************************/
/**
 * register: mrsz_ctrl: global control register (0x00000000)
 *
 *****************************************************************************/
/* Slice: cfg_upd:*/
/* write 0: nothing happens */
/* write 1: update shadow registers */
/* read: always 0 */
#ifdef MRV_MRSZ_CFG_UPD
#endif /* MRV_MRSZ_CFG_UPD */
/* Slice: scale_vc_up:*/
/* 1: vertical chrominance upscaling selected */
/* 0: vertical chrominance downscaling selected */
#ifdef MRV_MRSZ_SCALE_VC_UP
#define MRV_MRSZ_SCALE_VC_UP_UPSCALE            1	/* 1: vertical chrominance upscaling selected */
#define MRV_MRSZ_SCALE_VC_UP_DOWNSCALE          0	/* 0: vertical chrominance downscaling selected */
#endif /* MRV_MRSZ_SCALE_VC_UP */
/* Slice: scale_vy_up:*/
/* 1: vertical luminance upscaling selected */
/* 0: vertical luminance downscaling selected */
#ifdef MRV_MRSZ_SCALE_VY_UP
#define MRV_MRSZ_SCALE_VY_UP_UPSCALE            1	/* 1: vertical luminance upscaling selected */
#define MRV_MRSZ_SCALE_VY_UP_DOWNSCALE          0	/* 0: vertical luminance downscaling selected */
#endif /* MRV_MRSZ_SCALE_VY_UP */
/* Slice: scale_hc_up:*/
/* 1: horizontal chrominance upscaling selected */
/* 0: horizontal chrominance downscaling selected */
#ifdef MRV_MRSZ_SCALE_HC_UP
#define MRV_MRSZ_SCALE_HC_UP_UPSCALE            1	/* 1: horizontal chrominance upscaling selected */
#define MRV_MRSZ_SCALE_HC_UP_DOWNSCALE          0	/* 0: horizontal chrominance downscaling selected */
#endif /* MRV_MRSZ_SCALE_HC_UP */
/* Slice: scale_hy_up:*/
/* 1: horizontal luminance upscaling selected */
/* 0: horizontal luminance downscaling selected */
#ifdef MRV_MRSZ_SCALE_HY_UP
#define MRV_MRSZ_SCALE_HY_UP_UPSCALE            1	/* 1: horizontal luminance upscaling selected */
#define MRV_MRSZ_SCALE_HY_UP_DOWNSCALE          0	/* 0: horizontal luminance downscaling selected */
#endif /* MRV_MRSZ_SCALE_HY_UP */
/* Slice: scale_vc_enable:*/
/* 0: bypass vertical chrominance scaling unit */
/* 1: enable vertical chrominance scaling unit */
#ifdef MRV_MRSZ_SCALE_VC_ENABLE
#define MRV_MRSZ_SCALE_VC_ENABLE_PROCESS        1	/* 1: enable vertical chrominance scaling unit */
#define MRV_MRSZ_SCALE_VC_ENABLE_BYPASS         0	/* 0: bypass vertical chrominance scaling unit */
#endif /* MRV_MRSZ_SCALE_VC_ENABLE */
/* Slice: scale_vy_enable:*/
/* 0: bypass vertical luminance scaling unit */
/* 1: enable vertical luminance scaling unit */
#ifdef MRV_MRSZ_SCALE_VY_ENABLE
#define MRV_MRSZ_SCALE_VY_ENABLE_PROCESS        1	/* 1: enable vertical luminance scaling unit */
#define MRV_MRSZ_SCALE_VY_ENABLE_BYPASS         0	/* 0: bypass vertical luminance scaling unit */
#endif /* MRV_MRSZ_SCALE_VY_ENABLE */
/* Slice: scale_hc_enable:*/
/* 0: bypass horizontal chrominance scaling unit */
/* 1: enable horizontal chrominance scaling unit */
#ifdef MRV_MRSZ_SCALE_HC_ENABLE
#define MRV_MRSZ_SCALE_HC_ENABLE_PROCESS        1	/* 1: enable horizontal chrominance scaling unit */
#define MRV_MRSZ_SCALE_HC_ENABLE_BYPASS         0	/* 0: bypass horizontal chrominance scaling unit */
#endif /* MRV_MRSZ_SCALE_HC_ENABLE */
/* Slice: scale_hy_enable:*/
/* 0: bypass horizontal luminance scaling unit */
/* 1: enable horizontal luminance scaling unit */
#ifdef MRV_MRSZ_SCALE_HY_ENABLE
#define MRV_MRSZ_SCALE_HY_ENABLE_PROCESS        1	/* 1: enable horizontal luminance scaling unit */
#define MRV_MRSZ_SCALE_HY_ENABLE_BYPASS         0	/* 0: bypass horizontal luminance scaling unit */
#endif /* MRV_MRSZ_SCALE_HY_ENABLE */
/*****************************************************************************/
/**
 * register: mrsz_scale_hy: horizontal luminance scale factor register
 *           (0x00000004)
 *
 *****************************************************************************/
/* Slice: scale_hy:*/
/* This register is set to the horizontal luminance downscale factor or to */
/* the reciprocal of the horizontal luminance upscale factor */
#ifdef MRV_MRSZ_SCALE_HY
#endif /* MRV_MRSZ_SCALE_HY */
/*****************************************************************************/
/**
 * register: mrsz_scale_hcb: horizontal Cb scale factor register (0x00000008)
 *
 *****************************************************************************/
/* Slice: scale_hcb:*/
/* This register is set to the horizontal Cb downscale factor or to the */
/* reciprocal of the horizontal Cb upscale factor */
#ifdef MRV_MRSZ_SCALE_HCB
#endif /* MRV_MRSZ_SCALE_HCB */
/*****************************************************************************/
/**
 * register: mrsz_scale_hcr: horizontal Cr scale factor register (0x0000000c)
 *
 *****************************************************************************/
/* Slice: scale_hcr:*/
/* This register is set to the horizontal Cr downscale factor or to the */
/* reciprocal of the horizontal Cr upscale factor */
#ifdef MRV_MRSZ_SCALE_HCR
#endif /* MRV_MRSZ_SCALE_HCR */
/*****************************************************************************/
/**
 * register: mrsz_scale_vy: vertical luminance scale factor register (0x00000010)
 *
 *****************************************************************************/
/* Slice: scale_vy:*/
/* This register is set to the vertical luminance downscale factor or to the */
/* reciprocal of the vertical luminance upscale factor */
#ifdef MRV_MRSZ_SCALE_VY
#endif /* MRV_MRSZ_SCALE_VY */
/*****************************************************************************/
/**
 * register: mrsz_scale_vc: vertical chrominance scale factor register (0x00000014)
 *
 *****************************************************************************/
/* Slice: scale_vc:*/
/* This register is set to the vertical chrominance downscale factor or to the */
/* reciprocal of the vertical chrominance upscale factor */
#ifdef MRV_MRSZ_SCALE_VC
#endif /* MRV_MRSZ_SCALE_VC */
/*****************************************************************************/
/**
 * register: mrsz_phase_hy: horizontal luminance phase register (0x00000018)
 *
 *****************************************************************************/
/* Slice: phase_hy:*/
/* This register is set to the horizontal luminance phase offset */
#ifdef MRV_MRSZ_PHASE_HY
#endif /* MRV_MRSZ_PHASE_HY */
/*****************************************************************************/
/**
 * register: mrsz_phase_hc: horizontal chrominance phase register (0x0000001c)
 *
 *****************************************************************************/
/* Slice: phase_hc:*/
/* This register is set to the horizontal chrominance phase offset */
#ifdef MRV_MRSZ_PHASE_HC
#endif /* MRV_MRSZ_PHASE_HC */
/*****************************************************************************/
/**
 * register: mrsz_phase_vy: vertical luminance phase register (0x00000020)
 *
 *****************************************************************************/
/* Slice: phase_vy:*/
/* This register is set to the vertical luminance phase offset */
#ifdef MRV_MRSZ_PHASE_VY
#endif /* MRV_MRSZ_PHASE_VY */
/*****************************************************************************/
/**
 * register: mrsz_phase_vc: vertical chrominance phase register (0x00000024)
 *
 *****************************************************************************/
/* Slice: phase_vc:*/
/* This register is set to the vertical chrominance phase offset */
#ifdef MRV_MRSZ_PHASE_VC
#endif /* MRV_MRSZ_PHASE_VC */
/*****************************************************************************/
/**
 * register: mrsz_scale_lut_addr: Address pointer of up-scaling look up table
 *           (0x00000028)
 *
 *****************************************************************************/
/* Slice: scale_lut_addr:*/
/* Pointer to entry of lookup table */
#ifdef MRV_MRSZ_SCALE_LUT_ADDR
#endif /* MRV_MRSZ_SCALE_LUT_ADDR */
/*****************************************************************************/
/**
 * register: mrsz_scale_lut: Entry of up-scaling look up table (0x0000002c)
 *
 *****************************************************************************/
/* Slice: scale_lut:*/
/* Entry of lookup table at position scale_lut_addr. The lookup table must be */
/* filled with appropriate values before the up-scaling functionality can be */
/* used.*/
#ifdef MRV_MRSZ_SCALE_LUT
#endif /* MRV_MRSZ_SCALE_LUT */
/*****************************************************************************/
/**
 * register: mrsz_ctrl_shd: global control shadow register (0x0030)
 *
 *****************************************************************************/
/* Slice: scale_vc_up_shd:*/
/* 1: vertical chrominance upscaling selected */
/* 0: vertical chrominance downscaling selected */
#ifdef MRV_MRSZ_SCALE_VC_UP_SHD
#define MRV_MRSZ_SCALE_VC_UP_SHD_UPSCALE        1	/* 1: vertical chrominance upscaling selected */
#define MRV_MRSZ_SCALE_VC_UP_SHD_DOWNSCALE      0	/* 0: vertical chrominance downscaling selected */
#endif /* MRV_MRSZ_SCALE_VC_UP_SHD */
/* Slice: scale_vy_up_shd:*/
/* 1: vertical luminance upscaling selected */
/* 0: vertical luminance downscaling selected */
#ifdef MRV_MRSZ_SCALE_VY_UP_SHD
#define MRV_MRSZ_SCALE_VY_UP_SHD_UPSCALE        1	/* 1: vertical luminance upscaling selected */
#define MRV_MRSZ_SCALE_VY_UP_SHD_DOWNSCALE      0	/* 0: vertical luminance downscaling selected */
#endif /* MRV_MRSZ_SCALE_VY_UP_SHD */
/* Slice: scale_hc_up_shd:*/
/* 1: horizontal chrominance upscaling selected */
/* 0: horizontal chrominance downscaling selected */
#ifdef MRV_MRSZ_SCALE_HC_UP_SHD
#define MRV_MRSZ_SCALE_HC_UP_SHD_UPSCALE        1	/* 1: horizontal chrominance upscaling selected */
#define MRV_MRSZ_SCALE_HC_UP_SHD_DOWNSCALE      0	/* 0: horizontal chrominance downscaling selected */
#endif /* MRV_MRSZ_SCALE_HC_UP_SHD */
/* Slice: scale_hy_up_shd:*/
/* 1: horizontal luminance upscaling selected */
/* 0: horizontal luminance downscaling selected */
#ifdef MRV_MRSZ_SCALE_HY_UP_SHD
#define MRV_MRSZ_SCALE_HY_UP_SHD_UPSCALE        1	/* 1: horizontal luminance upscaling selected */
#define MRV_MRSZ_SCALE_HY_UP_SHD_DOWNSCALE      0	/* 0: horizontal luminance downscaling selected */
#endif /* MRV_MRSZ_SCALE_HY_UP_SHD */
/* Slice: scale_vc_enable_shd:*/
/* 0: bypass vertical chrominance scaling unit */
/* 1: enable vertical chrominance scaling unit */
#ifdef MRV_MRSZ_SCALE_VC_ENABLE_SHD
#define MRV_MRSZ_SCALE_VC_ENABLE_SHD_PROCESS    1	/* 1: enable vertical chrominance scaling unit */
#define MRV_MRSZ_SCALE_VC_ENABLE_SHD_BYPASS     0	/* 0: bypass vertical chrominance scaling unit */
#endif /* MRV_MRSZ_SCALE_VC_ENABLE_SHD */
/* Slice: scale_vy_enable_shd:*/
/* 0: bypass vertical luminance scaling unit */
/* 1: enable vertical luminance scaling unit */
#ifdef MRV_MRSZ_SCALE_VY_ENABLE_SHD
#define MRV_MRSZ_SCALE_VY_ENABLE_SHD_PROCESS    1	/* 1: enable vertical luminance scaling unit */
#define MRV_MRSZ_SCALE_VY_ENABLE_SHD_BYPASS     0	/* 0: bypass vertical luminance scaling unit */
#endif /* MRV_MRSZ_SCALE_VY_ENABLE_SHD */
/* Slice: scale_hc_enable_shd:*/
/* 0: bypass horizontal chrominance scaling unit */
/* 1: enable horizontal chrominance scaling unit */
#ifdef MRV_MRSZ_SCALE_HC_ENABLE_SHD
#define MRV_MRSZ_SCALE_HC_ENABLE_SHD_PROCESS    1	/* 1: enable horizontal chrominance scaling unit */
#define MRV_MRSZ_SCALE_HC_ENABLE_SHD_BYPASS     0	/* 0: bypass horizontal chrominance scaling unit */
#endif /* MRV_MRSZ_SCALE_HC_ENABLE_SHD */
/* Slice: scale_hy_enable_shd:*/
/* 0: bypass horizontal luminance scaling unit */
/* 1: enable horizontal luminance scaling unit */
#ifdef MRV_MRSZ_SCALE_HY_ENABLE_SHD
#define MRV_MRSZ_SCALE_HY_ENABLE_SHD_PROCESS    1	/* 1: enable horizontal luminance scaling unit */
#define MRV_MRSZ_SCALE_HY_ENABLE_SHD_BYPASS     0	/* 0: bypass horizontal luminance scaling unit */
#endif /* MRV_MRSZ_SCALE_HY_ENABLE_SHD */
/*****************************************************************************/
/**
 * register: mrsz_scale_hy_shd: horizontal luminance scale factor shadow
 *           register (0x00000034)
 *
 *****************************************************************************/
/* Slice: scale_hy_shd:*/
/* This register is set to the horizontal luminance downscale factor or to the */
/* reciprocal of the horizontal luminance upscale factor */
#ifdef MRV_MRSZ_SCALE_HY_SHD
#endif /* MRV_MRSZ_SCALE_HY_SHD */
/*****************************************************************************/
/**
 * register: mrsz_scale_hcb_shd: horizontal Cb scale factor shadow register
 *           (0x00000038)
 *
 *****************************************************************************/
/* Slice: scale_hcb_shd:*/
/* This register is set to the horizontal Cb downscale factor or to the */
/* reciprocal of the horizontal Cb upscale factor */
#ifdef MRV_MRSZ_SCALE_HCB_SHD
#endif /* MRV_MRSZ_SCALE_HCB_SHD */
/*****************************************************************************/
/**
 * register: mrsz_scale_hcr_shd: horizontal Cr scale factor shadow register
 *           (0x0000003c)
 *
 *****************************************************************************/
/* Slice: scale_hcr_shd:*/
/* This register is set to the horizontal Cr downscale factor or to the */
/* reciprocal of the horizontal Cr upscale factor */
#ifdef MRV_MRSZ_SCALE_HCR_SHD
#endif /*  MRV_MRSZ_SCALE_HCR_SHD */
/*****************************************************************************/
/**
 * register: mrsz_scale_vy_shd: vertical luminance scale factor shadow register
 *           (0x00000040)
 *
 *****************************************************************************/
/* Slice: scale_vy_shd:*/
/* This register is set to the vertical luminance downscale factor or to the */
/* reciprocal of the vertical luminance upscale factor */
#ifdef MRV_MRSZ_SCALE_VY_SHD
#endif /* MRV_MRSZ_SCALE_VY_SHD */
/*****************************************************************************/
/**
 * register: mrsz_scale_vc_shd: vertical chrominance scale factor shadow
 *           register (0x00000044)
 *
 *****************************************************************************/
/* Slice: scale_vc_shd:*/
/* This register is set to the vertical chrominance downscale factor or to */
/* the reciprocal of the vertical chrominance upscale factor */
#ifdef MRV_MRSZ_SCALE_VC_SHD
#endif /* MRV_MRSZ_SCALE_VC_SHD */
/*****************************************************************************/
/**
 * register: mrsz_phase_hy_shd: horizontal luminance phase shadow register
 *           (0x00000048)
 *
 *****************************************************************************/
/* Slice: phase_hy_shd:*/
/* This register is set to the horizontal luminance phase offset */
#ifdef MRV_MRSZ_PHASE_HY_SHD
#endif /* MRV_MRSZ_PHASE_HY_SHD */
/*****************************************************************************/
/**
 * register: mrsz_phase_hc_shd: horizontal chrominance phase shadow register
 *           (0x0000004c)
 *
 *****************************************************************************/
/* Slice: phase_hc_shd:*/
/* This register is set to the horizontal chrominance phase offset */
#ifdef MRV_MRSZ_PHASE_HC_SHD
#endif /* MRV_MRSZ_PHASE_HC_SHD */
/*****************************************************************************/
/**
 * register: mrsz_phase_vy_shd: vertical luminance phase shadow register
 *           (0x00000050)
 *
 *****************************************************************************/
/* Slice: phase_vy_shd:*/
/* This register is set to the vertical luminance phase offset */
#ifdef MRV_MRSZ_PHASE_VY_SHD
#endif /* MRV_MRSZ_PHASE_VY_SHD */
/*****************************************************************************/
/**
 * register: mrsz_phase_vc_shd: vertical chrominance phase shadow register
 *           (0x00000054)
 *
 *****************************************************************************/
/* Slice: phase_vc_shd:*/
/* This register is set to the vertical chrominance phase offset */
#ifdef MRV_MRSZ_PHASE_VC_SHD
#endif /* MRV_MRSZ_PHASE_VC_SHD */
/*****************************************************************************/
/* Self Resizer/Scaler Registers                                             */
/*****************************************************************************/
/*****************************************************************************/
/**
 * register: srsz_ctrl: global control register (0x00000000)
 *
 *****************************************************************************/
/* Slice: cfg_upd:*/
/* write 0: nothing happens */
/* write 1: update shadow registers */
/* read: always 0 */
#ifdef MRV_SRSZ_CFG_UPD
#endif /* MRV_SRSZ_CFG_UPD */
/* Slice: scale_vc_up:*/
/* 1: vertical chrominance upscaling selected */
/* 0: vertical chrominance downscaling selected */
#ifdef MRV_SRSZ_SCALE_VC_UP
#define MRV_SRSZ_SCALE_VC_UP_UPSCALE            1	/* 1: vertical chrominance upscaling selected */
#define MRV_SRSZ_SCALE_VC_UP_DOWNSCALE          0	/* 0: vertical chrominance downscaling selected */
#endif /* MRV_SRSZ_SCALE_VC_UP */
/* Slice: scale_vy_up:*/
/* 1: vertical luminance upscaling selected */
/* 0: vertical luminance downscaling selected */
#ifdef MRV_SRSZ_SCALE_VY_UP
#define MRV_SRSZ_SCALE_VY_UP_UPSCALE            1	/* 1: vertical luminance upscaling selected */
#define MRV_SRSZ_SCALE_VY_UP_DOWNSCALE          0	/* 0: vertical luminance downscaling selected */
#endif /* MRV_SRSZ_SCALE_VY_UP */
/* Slice: scale_hc_up:*/
/* 1: horizontal chrominance upscaling selected */
/* 0: horizontal chrominance downscaling selected */
#ifdef MRV_SRSZ_SCALE_HC_UP
#define MRV_SRSZ_SCALE_HC_UP_UPSCALE            1	/* 1: horizontal chrominance upscaling selected */
#define MRV_SRSZ_SCALE_HC_UP_DOWNSCALE          0	/* 0: horizontal chrominance downscaling selected */
#endif /* MRV_SRSZ_SCALE_HC_UP */
/* Slice: scale_hy_up:*/
/* 1: horizontal luminance upscaling selected */
/* 0: horizontal luminance downscaling selected */
#ifdef MRV_SRSZ_SCALE_HY_UP
#define MRV_SRSZ_SCALE_HY_UP_UPSCALE            1	/* 1: horizontal luminance upscaling selected */
#define MRV_SRSZ_SCALE_HY_UP_DOWNSCALE          0	/* 0: horizontal luminance downscaling selected */
#endif /* MRV_SRSZ_SCALE_HY_UP */
/* Slice: scale_vc_enable:*/
/* 0: bypass vertical chrominance scaling unit */
/* 1: enable vertical chrominance scaling unit */
#ifdef MRV_SRSZ_SCALE_VC_ENABLE
#define MRV_SRSZ_SCALE_VC_ENABLE_PROCESS        1	/* 1: enable vertical chrominance scaling unit */
#define MRV_SRSZ_SCALE_VC_ENABLE_BYPASS         0	/* 0: bypass vertical chrominance scaling unit */
#endif /* MRV_SRSZ_SCALE_VC_ENABLE */
/* Slice: scale_vy_enable:*/
/* 0: bypass vertical luminance scaling unit */
/* 1: enable vertical luminance scaling unit */
#ifdef MRV_SRSZ_SCALE_VY_ENABLE
#define MRV_SRSZ_SCALE_VY_ENABLE_PROCESS        1	/* 1: enable vertical luminance scaling unit */
#define MRV_SRSZ_SCALE_VY_ENABLE_BYPASS         0	/* 0: bypass vertical luminance scaling unit */
#endif /* MRV_SRSZ_SCALE_VY_ENABLE */
/* Slice: scale_hc_enable:*/
/* 0: bypass horizontal chrominance scaling unit */
/* 1: enable horizontal chrominance scaling unit */
#ifdef MRV_SRSZ_SCALE_HC_ENABLE
#define MRV_SRSZ_SCALE_HC_ENABLE_PROCESS        1	/* 1: enable horizontal chrominance scaling unit */
#define MRV_SRSZ_SCALE_HC_ENABLE_BYPASS         0	/* 0: bypass horizontal chrominance scaling unit */
#endif /* MRV_SRSZ_SCALE_HC_ENABLE */
/* Slice: scale_hy_enable:*/
/* 0: bypass horizontal luminance scaling unit */
/* 1: enable horizontal luminance scaling unit */
#ifdef MRV_SRSZ_SCALE_HY_ENABLE
#define MRV_SRSZ_SCALE_HY_ENABLE_PROCESS        1	/* 1: enable horizontal luminance scaling unit */
#define MRV_SRSZ_SCALE_HY_ENABLE_BYPASS         0	/* 0: bypass horizontal luminance scaling unit */
#endif /* MRV_SRSZ_SCALE_HY_ENABLE */
/*****************************************************************************/
/**
 * register: srsz_scale_hy: horizontal luminance scale factor register
 *           (0x00000004)
 *
 *****************************************************************************/
/* Slice: scale_hy:*/
/* This register is set to the horizontal luminance downscale factor or to */
/* the reciprocal of the horizontal luminance upscale factor */
#ifdef MRV_SRSZ_SCALE_HY
#endif /* MRV_SRSZ_SCALE_HY */
/*****************************************************************************/
/**
 * register: srsz_scale_hcb: horizontal Cb scale factor register (0x00000008)
 *
 *****************************************************************************/
/* Slice: scale_hcb:*/
/* This register is set to the horizontal Cb downscale factor or to the */
/* reciprocal of the horizontal Cb upscale factor */
#ifdef MRV_SRSZ_SCALE_HCB
#endif /* MRV_SRSZ_SCALE_HCB */
/*****************************************************************************/
/**
 * register: srsz_scale_hcr: horizontal Cr scale factor register (0x0000000c)
 *
 *****************************************************************************/
/* Slice: scale_hcr:*/
/* This register is set to the horizontal Cr downscale factor or to the */
/* reciprocal of the horizontal Cr upscale factor */
#ifdef MRV_SRSZ_SCALE_HCR
#endif /* MRV_SRSZ_SCALE_HCR */
/*****************************************************************************/
/**
 * register: srsz_scale_vy: vertical luminance scale factor register (0x00000010)
 *
 *****************************************************************************/
/* Slice: scale_vy:*/
/* This register is set to the vertical luminance downscale factor or to the */
/* reciprocal of the vertical luminance upscale factor */
#ifdef MRV_SRSZ_SCALE_VY
#endif /* MRV_SRSZ_SCALE_VY */
/*****************************************************************************/
/**
 * register: srsz_scale_vc: vertical chrominance scale factor register (0x00000014)
 *
 *****************************************************************************/
/* Slice: scale_vc:*/
/* This register is set to the vertical chrominance downscale factor or to the */
/* reciprocal of the vertical chrominance upscale factor */
#ifdef MRV_SRSZ_SCALE_VC
#endif /* MRV_SRSZ_SCALE_VC */
/*****************************************************************************/
/**
 * register: srsz_phase_hy: horizontal luminance phase register (0x00000018)
 *
 *****************************************************************************/
/* Slice: phase_hy:*/
/* This register is set to the horizontal luminance phase offset */
#ifdef MRV_SRSZ_PHASE_HY
#endif /* MRV_SRSZ_PHASE_HY */
/*****************************************************************************/
/**
 * register: srsz_phase_hc: horizontal chrominance phase register (0x0000001c)
 *
 *****************************************************************************/
/* Slice: phase_hc:*/
/* This register is set to the horizontal chrominance phase offset */
#ifdef MRV_SRSZ_PHASE_HC
#endif /* MRV_SRSZ_PHASE_HC */
/*****************************************************************************/
/**
 * register: srsz_phase_vy: vertical luminance phase register (0x00000020)
 *
 *****************************************************************************/
/* Slice: phase_vy:*/
/* This register is set to the vertical luminance phase offset */
#ifdef MRV_SRSZ_PHASE_VY
#endif /* MRV_SRSZ_PHASE_VY */
/*****************************************************************************/
/**
 * register: srsz_phase_vc: vertical chrominance phase register (0x00000024)
 *
 *****************************************************************************/
/* Slice: phase_vc:*/
/* This register is set to the vertical chrominance phase offset */
#ifdef MRV_SRSZ_PHASE_VC
#endif /* MRV_SRSZ_PHASE_VC */
/*****************************************************************************/
/**
 * register: srsz_scale_lut_addr: Address pointer of up-scaling look up table
 *           (0x00000028)
 *
 *****************************************************************************/
/* Slice: scale_lut_addr:*/
/* Pointer to entry of lookup table */
#ifdef MRV_SRSZ_SCALE_LUT_ADDR
#endif /* MRV_SRSZ_SCALE_LUT_ADDR */
/*****************************************************************************/
/**
 * register: srsz_scale_lut: Entry of up-scaling look up table (0x0000002c)
 *
 *****************************************************************************/
/* Slice: scale_lut:*/
/* Entry of lookup table at position scale_lut_addr. The lookup table must be */
/* filled with appropriate values before the up-scaling functionality can be */
/* used.*/
#ifdef MRV_SRSZ_SCALE_LUT
#endif /* MRV_SRSZ_SCALE_LUT */
/*****************************************************************************/
/**
 * register: srsz_ctrl_shd: global control shadow register (0x0030)
 *
 *****************************************************************************/
/* Slice: scale_vc_up_shd:*/
/* 1: vertical chrominance upscaling selected */
/* 0: vertical chrominance downscaling selected */
#ifdef MRV_SRSZ_SCALE_VC_UP_SHD
#define MRV_SRSZ_SCALE_VC_UP_SHD_UPSCALE        1	/* 1: vertical chrominance upscaling selected */
#define MRV_SRSZ_SCALE_VC_UP_SHD_DOWNSCALE      0	/* 0: vertical chrominance downscaling selected */
#endif /* MRV_SRSZ_SCALE_VC_UP_SHD */
/* Slice: scale_vy_up_shd:*/
/* 1: vertical luminance upscaling selected */
/* 0: vertical luminance downscaling selected */
#ifdef MRV_SRSZ_SCALE_VY_UP_SHD
#define MRV_SRSZ_SCALE_VY_UP_SHD_UPSCALE        1	/* 1: vertical luminance upscaling selected */
#define MRV_SRSZ_SCALE_VY_UP_SHD_DOWNSCALE      0	/* 0: vertical luminance downscaling selected */
#endif /* MRV_SRSZ_SCALE_VY_UP_SHD */
/* Slice: scale_hc_up_shd:*/
/* 1: horizontal chrominance upscaling selected */
/* 0: horizontal chrominance downscaling selected */
#ifdef MRV_SRSZ_SCALE_HC_UP_SHD
#define MRV_SRSZ_SCALE_HC_UP_SHD_UPSCALE        1	/* 1: horizontal chrominance upscaling selected */
#define MRV_SRSZ_SCALE_HC_UP_SHD_DOWNSCALE      0	/* 0: horizontal chrominance downscaling selected */
#endif /* MRV_SRSZ_SCALE_HC_UP_SHD */
/* Slice: scale_hy_up_shd:*/
/* 1: horizontal luminance upscaling selected */
/* 0: horizontal luminance downscaling selected */
#ifdef MRV_SRSZ_SCALE_HY_UP_SHD
#define MRV_SRSZ_SCALE_HY_UP_SHD_UPSCALE        1	/* 1: horizontal luminance upscaling selected */
#define MRV_SRSZ_SCALE_HY_UP_SHD_DOWNSCALE      0	/* 0: horizontal luminance downscaling selected */
#endif /* MRV_SRSZ_SCALE_HY_UP_SHD */
/* Slice: scale_vc_enable_shd:*/
/* 0: bypass vertical chrominance scaling unit */
/* 1: enable vertical chrominance scaling unit */
#ifdef MRV_SRSZ_SCALE_VC_ENABLE_SHD
#define MRV_SRSZ_SCALE_VC_ENABLE_SHD_PROCESS    1	/* 1: enable vertical chrominance scaling unit */
#define MRV_SRSZ_SCALE_VC_ENABLE_SHD_BYPASS     0	/* 0: bypass vertical chrominance scaling unit */
#endif /* MRV_SRSZ_SCALE_VC_ENABLE_SHD */
/* Slice: scale_vy_enable_shd:*/
/* 0: bypass vertical luminance scaling unit */
/* 1: enable vertical luminance scaling unit */
#ifdef MRV_SRSZ_SCALE_VY_ENABLE_SHD
#define MRV_SRSZ_SCALE_VY_ENABLE_SHD_PROCESS    1	/* 1: enable vertical luminance scaling unit */
#define MRV_SRSZ_SCALE_VY_ENABLE_SHD_BYPASS     0	/* 0: bypass vertical luminance scaling unit */
#endif /* MRV_SRSZ_SCALE_VY_ENABLE_SHD */
/* Slice: scale_hc_enable_shd:*/
/* 0: bypass horizontal chrominance scaling unit */
/* 1: enable horizontal chrominance scaling unit */
#ifdef MRV_SRSZ_SCALE_HC_ENABLE_SHD
#define MRV_SRSZ_SCALE_HC_ENABLE_SHD_PROCESS    1	/* 1: enable horizontal chrominance scaling unit */
#define MRV_SRSZ_SCALE_HC_ENABLE_SHD_BYPASS     0	/* 0: bypass horizontal chrominance scaling unit */
#endif /* MRV_SRSZ_SCALE_HC_ENABLE_SHD */
/* Slice: scale_hy_enable_shd:*/
/* 0: bypass horizontal luminance scaling unit */
/* 1: enable horizontal luminance scaling unit */
#ifdef MRV_SRSZ_SCALE_HY_ENABLE_SHD
#define MRV_SRSZ_SCALE_HY_ENABLE_SHD_PROCESS    1	/* 1: enable horizontal luminance scaling unit */
#define MRV_SRSZ_SCALE_HY_ENABLE_SHD_BYPASS     0	/* 0: bypass horizontal luminance scaling unit */
#endif /* MRV_SRSZ_SCALE_HY_ENABLE_SHD */
/*****************************************************************************/
/**
 * register: srsz_scale_hy_shd: horizontal luminance scale factor shadow
 *           register (0x00000034)
 *
 *****************************************************************************/
/* Slice: scale_hy_shd:*/
/* This register is set to the horizontal luminance downscale factor or to the */
/* reciprocal of the horizontal luminance upscale factor */
#ifdef MRV_SRSZ_SCALE_HY_SHD
#endif /* MRV_SRSZ_SCALE_HY_SHD */
/*****************************************************************************/
/**
 * register: srsz_scale_hcb_shd: horizontal Cb scale factor shadow register
 *           (0x00000038)
 *
 *****************************************************************************/
/* Slice: scale_hcb_shd:*/
/* This register is set to the horizontal Cb downscale factor or to the */
/* reciprocal of the horizontal Cb upscale factor */
#ifdef MRV_SRSZ_SCALE_HCB_SHD
#endif /* MRV_SRSZ_SCALE_HCB_SHD */
/*****************************************************************************/
/**
 * register: srsz_scale_hcr_shd: horizontal Cr scale factor shadow register
 *           (0x0000003c)
 *
 *****************************************************************************/
/* Slice: scale_hcr_shd:*/
/* This register is set to the horizontal Cr downscale factor or to the */
/* reciprocal of the horizontal Cr upscale factor */
#ifdef MRV_SRSZ_SCALE_HCR_SHD
#endif /*  MRV_SRSZ_SCALE_HCR_SHD */
/*****************************************************************************/
/**
 * register: srsz_scale_vy_shd: vertical luminance scale factor shadow register
 *           (0x00000040)
 *
 *****************************************************************************/
/* Slice: scale_vy_shd:*/
/* This register is set to the vertical luminance downscale factor or to the */
/* reciprocal of the vertical luminance upscale factor */
#ifdef MRV_SRSZ_SCALE_VY_SHD
#endif /* MRV_SRSZ_SCALE_VY_SHD */
/*****************************************************************************/
/**
 * register: srsz_scale_vc_shd: vertical chrominance scale factor shadow
 *           register (0x00000044)
 *
 *****************************************************************************/
/* Slice: scale_vc_shd:*/
/* This register is set to the vertical chrominance downscale factor or to */
/* the reciprocal of the vertical chrominance upscale factor */
#ifdef MRV_SRSZ_SCALE_VC_SHD
#endif /* MRV_SRSZ_SCALE_VC_SHD */
/*****************************************************************************/
/**
 * register: srsz_phase_hy_shd: horizontal luminance phase shadow register
 *           (0x00000048)
 *
 *****************************************************************************/
/* Slice: phase_hy_shd:*/
/* This register is set to the horizontal luminance phase offset */
#ifdef MRV_SRSZ_PHASE_HY_SHD
#endif /* MRV_SRSZ_PHASE_HY_SHD */
/*****************************************************************************/
/**
 * register: srsz_phase_hc_shd: horizontal chrominance phase shadow register
 *           (0x0000004c)
 *
 *****************************************************************************/
/* Slice: phase_hc_shd:*/
/* This register is set to the horizontal chrominance phase offset */
#ifdef MRV_SRSZ_PHASE_HC_SHD
#endif /* MRV_SRSZ_PHASE_HC_SHD */
/*****************************************************************************/
/**
 * register: srsz_phase_vy_shd: vertical luminance phase shadow register
 *           (0x00000050)
 *
 *****************************************************************************/
/* Slice: phase_vy_shd:*/
/* This register is set to the vertical luminance phase offset */
#ifdef MRV_SRSZ_PHASE_VY_SHD
#endif /* MRV_SRSZ_PHASE_VY_SHD */
/*****************************************************************************/
/**
 * register: srsz_phase_vc_shd: vertical chrominance phase shadow register
 *           (0x00000054)
 *
 *****************************************************************************/
/* Slice: phase_vc_shd:*/
/* This register is set to the vertical chrominance phase offset */
#ifdef MRV_SRSZ_PHASE_VC_SHD
#endif /* MRV_SRSZ_PHASE_VC_SHD */
/*****************************************************************************/
/* Memory Interface Registers                                                */
/*****************************************************************************/
/*****************************************************************************/
/**
 * register: mi_ctrl: Global control register (0x0000)
 *
 *****************************************************************************/
/* Slice: sp_output_format:*/
/* Selects output format of self picture. For possible restrictions see sub-*/
/* chapter "Picture Orientation" in chapter "Self Path Output Programming".*/
     /**/
/* 111: reserved */
/* 110: RGB 888 */
/* 101: RGB 666 */
/* 100: RGB 565 */
     /**/
/* 011: YCbCr  4:4:4 */
/* 010: YCbCr  4:2:2 */
/* 001: YCbCr  4:2:0 */
/* 000: YCbCr  4:0:0 */
     /**/
/* Note:*/
/* - Programmed value becomes effective immediately. So write to the */
/*   register only if no picture data is sent to the self path.*/
/* - for RGB output format the SP input format must be YCbCr 4:2:2 */
#ifdef MRV_MI_SP_OUTPUT_FORMAT
#define MRV_MI_SP_OUTPUT_FORMAT_RGB888          6	/* 110: RGB 888 */
#define MRV_MI_SP_OUTPUT_FORMAT_RGB666          5	/* 101: RGB 666 */
#define MRV_MI_SP_OUTPUT_FORMAT_RGB565          4	/* 100: RGB 565 */
#define MRV_MI_SP_OUTPUT_FORMAT_YUV444          3	/* 011: YCbCr 4:4:4 */
#define MRV_MI_SP_OUTPUT_FORMAT_YUV422          2	/* 010: YCbCr 4:2:2 */
#define MRV_MI_SP_OUTPUT_FORMAT_YUV420          1	/* 001: YCbCr 4:2:0 */
#define MRV_MI_SP_OUTPUT_FORMAT_YUV400          0	/* 000: YCbCr 4:0:0 */
#endif /* MRV_MI_SP_OUTPUT_FORMAT */
/* Slice: sp_input_format:*/
/* Selects input format of self picture. For possible restrictions see sub-*/
/* chapter "Picture Orientation" in chapter "Self Path Output Programming".*/
     /**/
/* 11: YCbCr  4:4:4 */
/* 10: YCbCr  4:2:2 */
/* 01: YCbCr  4:2:0 */
/* 00: YCbCr  4:0:0 */
     /**/
/* Note:*/
/* - Programmed value becomes effective immediately. So write to the */
/*   register only if no picture data is sent to the self path.*/
#ifdef MRV_MI_SP_INPUT_FORMAT
#define MRV_MI_SP_INPUT_FORMAT_YUV444           3	/* 11: YCbCr  4:4:4 */
#define MRV_MI_SP_INPUT_FORMAT_YUV422           2	/* 10: YCbCr  4:2:2 */
#define MRV_MI_SP_INPUT_FORMAT_YUV420           1	/* 01: YCbCr  4:2:0 */
#define MRV_MI_SP_INPUT_FORMAT_YUV400           0	/* 00: YCbCr  4:0:0 */
#endif /* MRV_MI_SP_INPUT_FORMAT */
/* Slice: sp_write_format:*/
/* Defines how YCbCr self picture data is written to memory. Ignored if */
/* RGB conversion is chosen. With RGB conversion active the output format */
/* is always interleaved.*/
     /**/
/* 00: planar */
/* 01: semi planar, for YCbCr 4:2:x */
/* 10: interleaved (combined), for YCbCr 4:2:2 only */
/* 11: reserved */
     /**/
/* Note:*/
/* - Programmed value becomes effective immediately. So write to the */
/*   register only if no picture data is sent to the self path.*/
#ifdef MRV_MI_SP_WRITE_FORMAT
#define MRV_MI_SP_WRITE_FORMAT_PLANAR           0	/* 00: planar */
#define MRV_MI_SP_WRITE_FORMAT_SEMIPLANAR       1	/* 01: semi planar, for YCbCr 4:2:x */
#define MRV_MI_SP_WRITE_FORMAT_INTERLEAVED      2	/* 10: interleaved (combined), for YCbCr 4:2:2 only */
#define MRV_MI_SP_WRITE_FORMAT_RGB_INTERLEAVED  0	/* 00: hw expects a 0 in RGB mode */
#endif /* MRV_MI_SP_WRITE_FORMAT */
/* Slice: mp_write_format:*/
/* Defines how YCbCr main picture data is written to memory.*/
/* Ignored if JPEG data is chosen.*/
/* In YCbCr mode the following meaning is applicable */
/* 00: planar */
/* 01: semi planar, for YCbCr 4:2:x */
/* 10: interleaved (combined), for YCbCr 4:2:2 only */
/* 11: reserved */
/* In RAW data mode the following meaning is applicable */
/* 00: RAW 8 bit */
/* 01: reserved */
/* 10: RAW 12 bit */
/* 11: reserved */
/* Note:*/
/* - Programmed value becomes effective immediately. So write to the */
/*   register only if no picture data is sent to the main path.*/
#ifdef MRV_MI_MP_WRITE_FORMAT
#define MRV_MI_MP_WRITE_FORMAT_PLANAR           0	/* 00: planar */
#define MRV_MI_MP_WRITE_FORMAT_SEMIPLANAR       1	/* 01: semi planar, for YCbCr 4:2:x */
#define MRV_MI_MP_WRITE_FORMAT_INTERLEAVED      2	/* 10: interleaved (combined), for YCbCr 4:2:2 only */
#define MRV_MI_MP_WRITE_FORMAT_RAW_8            0	/* 0x: RAW 8 bit */
#define MRV_MI_MP_WRITE_FORMAT_RAW_12           2	/* 1x: RAW 12 bit */
#endif /* MRV_MI_MP_WRITE_FORMAT */
/* Slice: bp_write_format:*/
/* In RAW data mode the following meaning is applicable */
/* 00: RAW 8 bit */
/* 01: RAW 10 bit */
/* 10: RAW 12 bit */
/* 11: reserved */
/* Note:*/
/* - Programmed value becomes effective immediately. So write to the */
/*   register only if no picture data is sent to the main path.*/
#ifdef MRV_MI_BP_WRITE_RAWBIT
#define MRV_MI_BP_WRITE_RAWBIT_RAW_8            0	/* 0x: RAW 8 bit */
#define MRV_MI_BP_WRITE_RAWBIT_RAW_10           1	/* 01x: RAW 10 bit */
#define MRV_MI_BP_WRITE_RAWBIT_RAW_12           2	/* 10x: RAW 12 bit */
#endif /* MRV_MI_BP_WRITE_RAWBIT */
/* Slice: init_offset_en:*/
/* Enables updating of the offset counters shadow registers for */
/* main and self picture to the programmed register init values.*/
     /**/
/* MI_MP/SP_Y/CB/CR_OFFS_CNT_INIT */
/* -> MI_MP/SP_Y/CB/CR_OFFS_CNT_SHD */
     /**/
/* The update will be executed either when a forced software */
/* update occurs (in register MI_INIT bit cfg_upd = 1) or when */
/* an automatic config update signal arrives at the MI input port.*/
/* The latter is split into main and self picture. So only the */
/* corresponding main/self shadow registers are affected.*/
/* After a picture skip has been performed init_offset_en selects */
/* between skip restart and skip init mode (see bit skip in */
/* register MI_INIT).*/
#ifdef MRV_MI_INIT_OFFSET_EN
#endif /* MRV_MI_INIT_OFFSET_EN */
/* Slice: init_base_en:*/
/* Enables updating of the base address and buffer size shadow */
/* registers for main and self picture to the programmed register */
/* init values.*/
     /**/
/* MI_MP/SP_Y/CB/CR_BASE_AD_INIT */
/* -> MI_MP/SP_Y/CB/CR_BASE_AD_SHD */
     /**/
/* MI_MP/SP_Y/CB/CR_SIZE_INIT */
/* -> MI_MP/SP_Y/CB/CR_SIZE_SHD */
     /**/
/* The update will be executed either when a forced software */
/* update occurs (in register MI_INIT bit cfg_upd = 1) or when */
/* an automatic config update signal arrives at the MI input port.*/
/* The latter is split into main and self picture. So only the */
/* corresponding main/self shadow registers are affected.*/
#ifdef MRV_MI_INIT_BASE_EN
#endif /* MRV_MI_INIT_BASE_EN */
/* Slice: burst_len_chrom:*/
/* Burst length for Cb or Cr data affecting write port.*/
/* 00: 4-beat bursts */
/* 01: 8-beat bursts */
/* 10: 16-beat bursts */
/* 11: reserved */
/* Ignored if 8- or 16-beat bursts are not supported. If rotation */
/* is active, then only 4-beat bursts will be generated in self path,*/
/* regardless of the setting here.*/
     /**/
/* Note:*/
/* - Programmed value becomes effective immediately. So write to the */
/*   register only if no picture data is sent to the main and self path.*/
#ifdef MRV_MI_BURST_LEN_CHROM
#define MRV_MI_BURST_LEN_CHROM_4                0	/* 0: 4-beat bursts */
#define MRV_MI_BURST_LEN_CHROM_8                1	/* 1: 8-beat bursts */
#define MRV_MI_BURST_LEN_CHROM_16               2	/* 2: 16-beat bursts */
#endif /* MRV_MI_BURST_LEN_CHROM */
/* Slice: burst_len_lum:*/
/* Burst length for Y, JPEG, or raw data affecting write port.*/
/* 00: 4-beat bursts */
/* 01: 8-beat bursts */
/* 10: 16-beat bursts */
/* 11: reserved */
/* Ignored if 8- or 16-beat bursts are not supported.*/
     /**/
/* Note: Programmed value becomes effective immediately. So write to */
/* the register only if no picture data is sent to the main and self path.*/
#ifdef MRV_MI_BURST_LEN_LUM
#define MRV_MI_BURST_LEN_LUM_4                  0	/* 0: 4-beat bursts */
#define MRV_MI_BURST_LEN_LUM_8                  1	/* 1: 8-beat bursts */
#define MRV_MI_BURST_LEN_LUM_16                 2	/* 2: 16-beat bursts */
#endif /* MRV_MI_BURST_LEN_LUM */
/* Slice: last_pixel_sig_en:*/
/* enables the last pixel signalization */
/* 1: enabled */
/* 0: disabled */
#ifdef MRV_MI_LAST_PIXEL_SIG_EN
#define MRV_MI_LAST_PIXEL_SIG_EN_ENABLE         1	/* 1: enable last pixel signalization */
#define MRV_MI_LAST_PIXEL_SIG_EN_DISABLE        0	/* 0: disable last pixel signalization */
#endif /* MRV_MI_LAST_PIXEL_SIG_EN */
/* Slice: 422noncosited:*/
/* Enables self path YCbCr422non-co-sited -> YCbCr444 interpolation */
/* 1: YCbCr422 data are non_co-sited (Cb and Cr samples */
/*    are centered between Y samples) so modified interpolation */
/*    is activated */
/* 0: YCbCr422 data are co-sited (Y0 Cb0 and Cr0 are */
/*    sampled at the same position)*/
     /**/
/* Note:*/
/* - Programmed value becomes effective immediately. So write to the */
/*   register only if no picture data is sent to the self path.*/
#ifdef MRV_MI_422NONCOSITED
#endif /* MRV_MI_422NONCOSITED */
/* Slice: cbcr_full_range:*/
/* Enables CbCr full range for self path YCbCr -> RGB conversion */
/* 1: CbCr have full range (0..255)*/
/* 0: CbCr have compressed range range (16..240)*/
     /**/
/* Note:*/
/* - Programmed value becomes effective immediately. So write to the */
/*   register only if no picture data is sent to the self path.*/
#ifdef MRV_MI_CBCR_FULL_RANGE
#endif /* MRV_MI_CBCR_FULL_RANGE */
/* Slice: y_full_range:*/
/* Enables Y full range for self path YCbCr -> RGB conversion */
/* 1: Y has full range (0..255)*/
/* 0: Y has compressed range (16..235)*/
     /**/
/* Note:*/
/* - Programmed value becomes effective immediately. So write to the */
/*   register only if no picture data is sent to the self path.*/
#ifdef MRV_MI_Y_FULL_RANGE
#endif /* MRV_MI_Y_FULL_RANGE */
/* Slice: byte_swap:*/
/* Enables change of byte order of the 32 bit output word at write port */
/* 1: byte order is mirrored but the bit order within one byte doesn't */
/*    change */
/* 0: no byte mirroring */
     /**/
/* Note: Programmed value becomes effective immediately. So write to the */
/* register only if no picture data is sent to the main and self path.*/
#ifdef MRV_MI_BYTE_SWAP
#endif /* MRV_MI_BYTE_SWAP */
/* Slice: rot:*/
/* Rotation 90 degree counter clockwise of self picture, only in RGB */
/* mode. For picture orientation and operation modes see sub-chapter */
/* "Picture Orientation" in chapter "Self Path Output Programming".*/
     /**/
/* For RGB 565 format the line length must be a multiple of 2. There */
/* are no restrictions for RGB 888/666.*/
/* 1: enabled */
/* 0: disabled */
     /**/
/* Note:*/
/* - Programmed value becomes effective immediately. So write to the */
/*   register only if no picture data is sent to the self path. In */
/*   rotation mode only 4-beat bursts are supported for self-path.*/
#ifdef MRV_MI_ROT
#endif /* MRV_MI_ROT */
/* Slice: v_flip:*/
/* Vertical flipping of self picture. For picture orientation and */
/* operation modes see sub-chapter "Picture Orientation" in chapter */
/* "Self Path Output Programming". For Y component the line length */
/* in 4:2:x planar mode must be a multiple of 8, for all other component */
/* modes a multiple of 4 and for RGB 565 a multiple of 2. There are */
/* no restrictions for RGB 888/666.*/
     /**/
/* 1: enabled */
/* 0: disabled */
     /**/
/* Note:*/
/* - Programmed value becomes effective immediately. So write to the */
/*   register only if no picture data is sent to the self path.*/
#ifdef MRV_MI_V_FLIP
#endif /* MRV_MI_V_FLIP */
/* Slice: h_flip:*/
/* Horizontal flipping of self picture. For picture orientation and */
/* operation modes see sub-chapter "Picture Orientation" in chapter */
/* "Self Path Output Programming".*/
     /**/
/* For Y component the line length in 4:2:x planar mode must be a */
/* multiple of 8, for all other component modes a multiple of 4 and */
/* for RGB 565 a multiple of 2. There are no restrictions for RGB 888/666.*/
     /**/
/* 1: enabled */
/* 0: disabled */
     /**/
/* Note:*/
/* - Programmed value becomes effective immediately. So write to the */
/*   register only if no picture data is sent to the self path.*/
#ifdef MRV_MI_H_FLIP
#endif /* MRV_MI_H_FLIP */
/* Programmed value becomes effective (visible in shadow register)*/
/* after a soft reset, a forced software update or an automatic */
/* config update.  Affects MI_IN and MI_OUT module.*/
/* Slice: raw_enable:*/
/* Enables raw data */
/* Programmed value becomes effective (visible in control shadow register) after a soft reset or a forced software update.*/
/* Affects MI_IN and MI_OUT module.*/
#ifndef MRV_MI_RAW_ENABLE
#define MRV_MI_RAW_ENABLE
#define MRV_MI_RAW_ENABLE_MASK 0x00000008
#define MRV_MI_RAW_ENABLE_SHIFT 3
#endif /* MRV_MI_RAW_ENABLE */
/* Slice: dpcc_enable:*/
/* Enables DPCC data */
/* Programmed value becomes effective (visible in control shadow register) after a soft reset or a forced software.*/
/* Affects MI_IN and MI_OUT module.*/
#ifndef MRV_MI_DPCC_ENABLE
#define MRV_MI_DPCC_ENABLE
#define MRV_MI_DPCC_ENABLE_MASK 0x0000000C
#define MRV_MI_DPCC_ENABLE_SHIFT 2
#endif /* MRV_MI_JPEG_ENABLE */
/* Slice: jpeg_enable:*/
/* Enables JPEG data */
/* Programmed value becomes effective (visible in control shadow register) after a soft reset or a forced software.*/
/* Affects MI_IN and MI_OUT module.*/
#ifndef MRV_MI_JPEG_ENABLE
#define MRV_MI_JPEG_ENABLE
#define MRV_MI_JPEG_ENABLE_MASK 0x00000004
#define MRV_MI_JPEG_ENABLE_SHIFT 2
#endif /* MRV_MI_JPEG_ENABLE */
/* Slice: sp_enable:*/
/* Enables self picture data path.*/
/* Programmed value becomes effective (visible in control shadow register) after a soft reset, a forced software update or an automatic config update.*/
/* Affects MI_IN and MI_OUT module.*/
#ifndef MRV_MI_SP_ENABLE
#define MRV_MI_SP_ENABLE
#define MRV_MI_SP_ENABLE_MASK 0x00000002
#define MRV_MI_SP_ENABLE_SHIFT 1
#endif /* MRV_MI_SP_ENABLE */
/* Slice: mp_enable:*/
/* Enables main picture data path */
/* Programmed value becomes effective (visible in control shadow register) after a soft reset, a forced software update or an automatic config update.*/
/* Affects MI_IN and MI_OUT module.*/
#ifndef MRV_MI_MP_ENABLE
#define MRV_MI_MP_ENABLE
#define MRV_MI_MP_ENABLE_MASK 0x00000001
#define MRV_MI_MP_ENABLE_SHIFT 0
#endif /* MRV_MI_MP_ENABLE */
/* Slice: path_enable:*/
/* Enables data pathes of MI according to the following table:*/
     /**/
/* 0000: disabled, no data is transferred */
/* 0001: YUV data output, mainpath only (mp_enable only)*/
/* 0010: self-path only, output data format depending on other settings (sp_enable only)*/
/* 0011: YUV data output in mainpath and self-path image data active */
/* 0100: JPEG data output, mainpath only (jpeg_enable only)*/
/* 0101: not allowed */
/* 0110: JPEG data output in mainpath and self-path image data active */
/* 0111: not allowed */
/* 1000: RAW data output, mainpath only (raw_enable only)*/
/* 1001: defect pixel data on self-path, image data on mainpath */
/* 1010: defect pixel data on mainpath, image data on self-path */
/* 1011: not allowed */
/* 1100: defect pixel data on self-path, JPEG data on mainpath */
/* 1101: defect pixel data on mainpath only */
/* 1110: defect pixel data on self-path only */
/* 1111: defect pixel data on self-path, RAW data on mainpath */
#ifdef MRV_MI_PATH_ENABLE
#endif /* MRV_MI_PATH_ENABLE */
/*****************************************************************************/
/**
 * register: mi_init: Control register for address init and skip function
 *           (0x00000004)
 *
 *****************************************************************************/
/* Slice: mi_cfg_upd:*/
/* Forced configuration update. Leads to an immediate update of the shadow registers.*/
/* Depending on the two init enable bits in the MI_CTRL register (init_offset_en and */
/* init_base_en) the offset counter, base address and buffer size shadow registers */
/* are also updated.*/
#ifdef MRV_MI_MI_CFG_UPD
#endif /* MRV_MI_MI_CFG_UPD */
/* Slice: mp_output_format:*/
/* Selects output format of main picture.*/
/* 1xxx: Reserved */
/* 0111: RAW10 */
/* 0110: JPEG */
/* 0101: RAW8 */
/* 0100: RAW12 */
     /**/
/* 0011: YCbCr  4:4:4 */
/* 0010: YCbCr  4:2:2 */
/* 0001: YCbCr  4:2:0 */
/* 0000: YCbCr  4:0:0 */
     /**/
#ifdef MRV_MI_MP_OUTPUT_FORMAT
#define MRV_MI_MP_OUTPUT_FORMAT_RAW10           7	/* 0111: RAW10 */
#define MRV_MI_MP_OUTPUT_FORMAT_JPEG            6	/* 0110: JPEG */
#define MRV_MI_MP_OUTPUT_FORMAT_RAW8            5	/* 0101: RAW8 */
#define MRV_MI_MP_OUTPUT_FORMAT_RAW12           4	/* 0100: RAW12 */
#define MRV_MI_MP_OUTPUT_FORMAT_YUV444          3	/* 0011: YCbCr 4:4:4 */
#define MRV_MI_MP_OUTPUT_FORMAT_YUV422          2	/* 0010: YCbCr 4:2:2 */
#define MRV_MI_MP_OUTPUT_FORMAT_YUV420          1	/* 0001: YCbCr 4:2:0 */
#define MRV_MI_MP_OUTPUT_FORMAT_YUV400          0	/* 0000: YCbCr 4:0:0 */
#endif /* MRV_MI_MP_OUTPUT_FORMAT */
/* Slice: mi_skip:*/
/* Skip of current or next starting main picture:*/
/* Aborts writing of main picture image data of the current frame to RAM (after the */
/* current burst transmission has been completed). Further main picture data up to */
/* the end of the current frame are discarded.*/
     /**/
/* No further makroblock line interrupt (mblk_line), no wrap around interrupt for */
/* main picture (wrap_mp_y/cb/cr) and no fill level interrupt (fill_mp_y) are generated.*/
     /**/
/* Skip does not affect the generation of the main path frame end interrupt (mp_frame_end).*/
/* Skip does not affect the processing of self picture and its corresponding interrupts */
/* namely the self path frame end interrupt (sp_frame_end).*/
     /**/
/* The byte counter (register MI_BYTE_CNT) is not affected. It produces the correct */
/* number of JPEG or RAW data bytes at the end of the current (skipped) frame.*/
     /**/
/* After a skip has been performed the offset counter for the main picture at the start */
/* of the following frame are set depending on the bit init_offset_en in register MI_CTRL:*/
     /**/
/* - Skip restart mode (init_offset_en = 0)*/
/*   The offset counters of the main picture are restarted at the old start values of */
/*   the previous skipped frame.*/
     /**/
/* - Skip init mode (init_offset_en = 1)*/
/*   The offset counters of the main picture are initialized with the register contents */
/*   of the offset counter init registers without any additional forced software update */
/*   or automatic config update.*/
#ifdef MRV_MI_MI_SKIP
#endif /* MRV_MI_MI_SKIP */
/*****************************************************************************/
/**
 * register: mi_mp_y_base_ad_init: Base address for main picture Y component,
 *           JPEG or raw data (0x00000008)
 *
 *****************************************************************************/
/* Slice: mp_y_base_ad_init:*/
/* Base address of main picture Y component ring buffer, JPEG ring buffer or raw */
/* data ring buffer.*/
     /**/
/* Programmed value becomes effective (visible in corresponding shadow register)*/
/* after a soft reset, a forced software update or an automatic config update.*/
     /**/
/* Must be 64-bit aligned (bit 0, bit 1 and bit 2 are hard wired to "000")*/
#ifdef MRV_MI_MP_Y_BASE_AD_INIT
#define MRV_MI_MP_Y_BASE_AD_INIT_VALID_MASK     (MRV_MI_MP_Y_BASE_AD_INIT_MASK & ~0x00000007)
#endif /* MRV_MI_MP_Y_BASE_AD_INIT */
/*****************************************************************************/
/**
 * register: mi_mp_y_size_init: Size of main picture Y component, JPEG or raw
 *           data (0x0000000c)
 *
 *****************************************************************************/
/* Slice: mp_y_size_init:*/
/* Size of main picture Y component ring buffer, JPEG ring buffer or raw data */
/* ring buffer.*/
     /**/
/* Programmed value becomes effective (visible in corresponding shadow register)*/
/* after a soft reset, a forced software update or an automatic config update.*/
     /**/
/* Must be 64-bit aligned (bit 0, bit 1 and bit 2 are hard wired to "000")*/
#ifdef MRV_MI_MP_Y_SIZE_INIT
#define MRV_MI_MP_Y_SIZE_INIT_VALID_MASK        (MRV_MI_MP_Y_SIZE_INIT_MASK & ~0x00000007)
#endif /* MRV_MI_MP_Y_SIZE_INIT */
/*****************************************************************************/
/**
 * register: mi_mp_y_offs_cnt_init: Offset counter init value for main picture
 *           Y, JPEG or raw data (0x00000010)
 *
 *****************************************************************************/
/* Slice: mp_y_offs_cnt_init:*/
/* Offset counter init value of main picture Y component ring buffer, JPEG ring */
/* buffer or raw data ring buffer.*/
     /**/
/* Programmed value becomes effective (visible in corresponding shadow register)*/
/* after a soft reset, a forced software update or an automatic config update.*/
     /**/
/* Must be 64-bit aligned (bit 0, bit 1 and bit 2 are hard wired to "000")*/
#ifdef MRV_MI_MP_Y_OFFS_CNT_INIT
#define MRV_MI_MP_Y_OFFS_CNT_INIT_VALID_MASK    (MRV_MI_MP_Y_OFFS_CNT_INIT_MASK & ~0x00000007)
#endif /* MRV_MI_MP_Y_OFFS_CNT_INIT */
/*****************************************************************************/
/**
 * register: mi_mp_y_offs_cnt_start: Offset counter start value for main picture
 *           Y, JPEG or raw data (0x00000014)
 *
 *****************************************************************************/
/* Slice: mp_y_offs_cnt_start:*/
/* Offset counter value which points to the start address of the previously */
/* processed picture (main picture Y component, JPEG or raw data). Updated at */
/* frame end.*/
     /**/
/* Note: A soft reset resets the contents to the reset value.*/
     /**/
/* Must be 64-bit aligned (bit 0, bit 1 and bit 2 are hard wired to "000")*/
#ifdef MRV_MI_MP_Y_OFFS_CNT_START
#define MRV_MI_MP_Y_OFFS_CNT_START_VALID_MASK   (MRV_MI_MP_Y_OFFS_CNT_START_MASK & ~0x00000007)
#endif /* MRV_MI_MP_Y_OFFS_CNT_START */
/*****************************************************************************/
/**
 * register: mi_mp_y_irq_offs_init: Fill level interrupt offset value for main
 *           picture Y, JPEG or raw data (0x00000018)
 *
 *****************************************************************************/
/* Slice: mp_y_irq_offs_init:*/
/* Reaching this programmed value by the current offset counter for addressing */
/* main picture Y component, JPEG or raw data leads to generation of fill level */
/* interrupt fill_mp_y.*/
     /**/
/* Programmed value becomes effective (visible in corresponding shadow register)*/
/* after a soft reset, a forced software update or an automatic config update.*/
     /**/
/* Must be 64-bit aligned (bit 0, bit 1 and bit 2 are hard wired to "000")*/
#ifdef MRV_MI_MP_Y_IRQ_OFFS_INIT
#define MRV_MI_MP_Y_IRQ_OFFS_INIT_VALID_MASK    (MRV_MI_MP_Y_IRQ_OFFS_INIT_MASK & ~0x00000007)
#endif /* MRV_MI_MP_Y_IRQ_OFFS_INIT */
/*****************************************************************************/
/**
 * register: mi_mp_cb_base_ad_init: Base address for main picture Cb component
 *           ring buffer (0x0000001c)
 *
 *****************************************************************************/
/* Slice: mp_cb_base_ad_init:*/
/* Base address of main picture Cb component ring buffer.*/
     /**/
/* Programmed value becomes effective (visible in corresponding shadow register)*/
/* after a soft reset, a forced software update or an automatic config update.*/
     /**/
/* Note: Set control bit init_base_en before updating so that a forced or */
/*       automatic update can take effect.*/
     /**/
/* Must be 64-bit aligned (bit 0, bit 1 and bit 2 are hard wired to "000")*/
#ifdef MRV_MI_MP_CB_BASE_AD_INIT
#define MRV_MI_MP_CB_BASE_AD_INIT_VALID_MASK    (MRV_MI_MP_CB_BASE_AD_INIT_MASK & ~0x00000007)
#endif /* MRV_MI_MP_CB_BASE_AD_INIT */
/*****************************************************************************/
/**
 * register: mi_mp_cb_size_init: Size of main picture Cb component ring buffer
 *           (0x00000020)
 *
 *****************************************************************************/
/* Slice: mp_cb_size_init:*/
/* Size of main picture Cb component ring buffer.*/
     /**/
/* Programmed value becomes effective (visible in corresponding shadow register)*/
/* after a soft reset, a forced software update or an automatic config update.*/
     /**/
/* Note: Set control bit init_base_en before updating so that a forced or */
/*       automatic update can take effect.*/
     /**/
/* Must be 64-bit aligned (bit 0, bit 1 and bit 2 are hard wired to "000")*/
#ifdef MRV_MI_MP_CB_SIZE_INIT
#define MRV_MI_MP_CB_SIZE_INIT_VALID_MASK       (MRV_MI_MP_CB_SIZE_INIT_MASK & ~0x00000007)
#endif /* MRV_MI_MP_CB_SIZE_INIT */
/*****************************************************************************/
/**
 * register: mi_mp_cb_offs_cnt_init: Offset counter init value for main picture
 *           Cb component ring buffer (0x00000024)
 *
 *****************************************************************************/
/* Slice: mp_cb_offs_cnt_init:*/
/* Offset counter init value of main picture Cb component ring buffer.*/
     /**/
/* Programmed value becomes effective (visible in corresponding shadow register)*/
/* after a soft reset, a forced software update or an automatic config update.*/
     /**/
/* Note: Set control bit init_base_en before updating so that a forced or automatic */
/*       update can take effect. Check exceptional handling in skip modes.*/
     /**/
/* Must be 64-bit aligned (bit 0, bit 1 and bit 2 are hard wired to "000")*/
#ifdef MRV_MI_MP_CB_OFFS_CNT_INIT
#define MRV_MI_MP_CB_OFFS_CNT_INIT_VALID_MASK   (MRV_MI_MP_CB_OFFS_CNT_INIT_MASK & ~0x00000007)
#endif /* MRV_MI_MP_CB_OFFS_CNT_INIT */
/*****************************************************************************/
/**
 * register: mi_mp_cb_offs_cnt_start: Offset counter start value for main
 *           picture Cb component ring buffer (0x00000028)
 *
 *****************************************************************************/
/* Slice: mp_cb_offs_cnt_start:*/
/* Offset counter value which points to the start address of the previously */
/* processed picture (main picture Cb component). Updated at frame end.*/
     /**/
/* Must be 64-bit aligned (bit 0, bit 1 and bit 2 are hard wired to "000")*/
#ifdef MRV_MI_MP_CB_OFFS_CNT_START
#define MRV_MI_MP_CB_OFFS_CNT_START_VALID_MASK  (MRV_MI_MP_CB_OFFS_CNT_START_MASK & ~0x00000007)
#endif /* MRV_MI_MP_CB_OFFS_CNT_START */
/*****************************************************************************/
/**
 * register: mi_mp_cr_base_ad_init: Base address for main picture Cr component
 *           ring buffer (0x0000002c)
 *
 *****************************************************************************/
/* Slice: mp_cr_base_ad_init:*/
/* Base address of main picture Cr component ring buffer.*/
     /**/
/* Programmed value becomes effective (visible in corresponding shadow register)*/
/* after a soft reset, a forced software update or an automatic config update.*/
     /**/
/* Note:*/
/* - Set control bit init_base_en before updating so that a forced or automatic */
/*   update can take effect.*/
     /**/
/* Must be 64-bit aligned (bit 0, bit 1 and bit 2 are hard wired to "000")*/
#ifdef MRV_MI_MP_CR_BASE_AD_INIT
#define MRV_MI_MP_CR_BASE_AD_INIT_VALID_MASK    (MRV_MI_MP_CR_BASE_AD_INIT_MASK & ~0x00000007)
#endif /* MRV_MI_MP_CR_BASE_AD_INIT */
/*****************************************************************************/
/**
 * register: mi_mp_cr_size_init: Size of main picture Cr component ring buffer
 *           (0x00000030)
 *
 *****************************************************************************/
/* Slice: mp_cr_size_init:*/
/* Size of main picture Cr component ring buffer.*/
     /**/
/* Programmed value becomes effective (visible in corresponding shadow register)*/
/* after a soft reset, a forced software update or an automatic config update.*/
     /**/
/* Note:*/
/* - Set control bit init_base_en before updating so that a forced or automatic */
/*   update can take effect.*/
     /**/
/* Must be 64-bit aligned (bit 0, bit 1 and bit 2 are hard wired to "000")*/
#ifdef MRV_MI_MP_CR_SIZE_INIT
#define MRV_MI_MP_CR_SIZE_INIT_VALID_MASK       (MRV_MI_MP_CR_SIZE_INIT_MASK & ~0x00000007)
#endif /* MRV_MI_MP_CR_SIZE_INIT */
/*****************************************************************************/
/**
 * register: mi_mp_cr_offs_cnt_init: Offset counter init value for main
 *           picture Cr component ring buffer (0x00000034)
 *
 *****************************************************************************/
/* Slice: mp_cr_offs_cnt_init:*/
/* Offset counter init value of main picture Cr component ring buffer.*/
     /**/
/* Programmed value becomes effective (visible in corresponding shadow register)*/
/* after a soft reset, a forced software update or an automatic config update.*/
     /**/
/* Note:*/
/* - Set control bit init_base_en before updating so that a forced or automatic */
/*   update can take effect. Check exceptional handling in skip modes.*/
     /**/
/* Must be 64-bit aligned (bit 0, bit 1 and bit 2 are hard wired to "000")*/
#ifdef MRV_MI_MP_CR_OFFS_CNT_INIT
#define MRV_MI_MP_CR_OFFS_CNT_INIT_VALID_MASK   (MRV_MI_MP_CR_OFFS_CNT_INIT_MASK & ~0x00000007)
#endif /* MRV_MI_MP_CR_OFFS_CNT_INIT */
/*****************************************************************************/
/**
 * register: mi_mp_cr_offs_cnt_start: Offset counter start value for main
 *           picture Cr component ring buffer (0x00000038)
 *
 *****************************************************************************/
/* Slice: mp_cr_offs_cnt_start:*/
/* Offset counter value which points to the start address of the previously */
/* processed picture (main picture Cr component). Updated at frame end.*/
     /**/
/* Note:*/
/* - Soft reset will reset the contents to reset value.*/
     /**/
/* Must be 64-bit aligned (bit 0, bit 1 and bit 2 are hard wired to "000")*/
#ifdef MRV_MI_MP_CR_OFFS_CNT_START
#define MRV_MI_MP_CR_OFFS_CNT_START_VALID_MASK  (MRV_MI_MP_CR_OFFS_CNT_START_MASK & ~0x00000007)
#endif /* MRV_MI_MP_CR_OFFS_CNT_START */
/*****************************************************************************/
/**
 * register: mi_sp_y_base_ad_init: Base address for self picture Y component
 *           ring buffer (0x0000003c)
 *
 *****************************************************************************/
/* Slice: sp_y_base_ad_init:*/
/* Base address of self picture Y component ring buffer.*/
     /**/
/* Programmed value becomes effective (visible in corresponding shadow register)*/
/* after a soft reset, a forced software update or an automatic config update.*/
     /**/
/* Note:*/
/* - Set control bit init_base_en before updating so that a forced or automatic */
/*   update can take effect.*/
     /**/
/* Must be 64-bit aligned (bit 0, bit 1 and bit 2 are hard wired to "000")*/
#ifdef MRV_MI_SP_Y_BASE_AD_INIT
#define MRV_MI_SP_Y_BASE_AD_INIT_VALID_MASK     (MRV_MI_SP_Y_BASE_AD_INIT_MASK & ~0x00000007)
#endif /* MRV_MI_SP_Y_BASE_AD_INIT */
/*****************************************************************************/
/**
 * register: mi_sp_y_size_init: Size of self picture Y component ring buffer
 *           (0x00000040)
 *
 *****************************************************************************/
/* Slice: sp_y_size_init:*/
/* Size of self picture Y component ring buffer.*/
     /**/
/* Programmed value becomes effective (visible in corresponding shadow register)*/
/* after a soft reset, a forced software update or an automatic config update.*/
     /**/
/* Note: Set control bit init_base_en before updating so that a forced or */
/*       automatic update can take effect.*/
     /**/
/* Must be 64-bit aligned (bit 0, bit 1 and bit 2 are hard wired to "000")*/
#ifdef MRV_MI_SP_Y_SIZE_INIT
#define MRV_MI_SP_Y_SIZE_INIT_VALID_MASK        (MRV_MI_SP_Y_SIZE_INIT_MASK & ~0x00000007)
#endif /* MRV_MI_SP_Y_SIZE_INIT */
/*****************************************************************************/
/**
 * register: mi_sp_y_offs_cnt_init: Offset counter init value for self
 *           picture Y component ring buffer (0x00000044)
 *
 *****************************************************************************/
/* Slice: sp_y_offs_cnt_init:*/
/* Offset counter init value of self picture Y component ring buffer.*/
     /**/
/* Programmed value becomes effective (visible in corresponding shadow register)*/
/* after a soft reset, a forced software update or an automatic config update.*/
     /**/
/* Note: Set control bit init_base_en before updating so that a forced or */
/*       automatic update can take effect.*/
     /**/
/* Must be 64-bit aligned (bit 0, bit 1 and bit 2 are hard wired to "000")*/
#ifdef MRV_MI_SP_Y_OFFS_CNT_INIT
#define MRV_MI_SP_Y_OFFS_CNT_INIT_VALID_MASK    (MRV_MI_SP_Y_OFFS_CNT_INIT_MASK & ~0x00000007)
#endif /* MRV_MI_SP_Y_OFFS_CNT_INIT */
/*****************************************************************************/
/**
 * register: mi_sp_y_offs_cnt_start: Offset counter start value for self
 *           picture Y component ring buffer (0x00000048)
 *
 *****************************************************************************/
/* Slice: sp_y_offs_cnt_start:*/
/* Offset counter value which points to the start address of the previously */
/* processed picture (self picture Y component). Updated at frame end.*/
     /**/
/* Note:*/
/* - Soft reset will reset the contents to reset value.*/
     /**/
/* Must be 64-bit aligned (bit 0, bit 1 and bit 2 are hard wired to "000")*/
#ifdef MRV_MI_SP_Y_OFFS_CNT_START
#define MRV_MI_SP_Y_OFFS_CNT_START_VALID_MASK   (MRV_MI_SP_Y_OFFS_CNT_START_MASK & ~0x00000007)
#endif /* MRV_MI_SP_Y_OFFS_CNT_START */
/*****************************************************************************/
/**
 * register: mi_sp_y_llength: Line length of self picture Y component (0x0000004c)
 *
 *****************************************************************************/
/* Slice: sp_y_llength:*/
/* Line length of self picture Y component or RGB picture in pixel, also */
/* known as line stride.*/
     /**/
/* If no line stride is used, line length must match image width.*/
     /**/
/* For Y component the line length in 4:2:x planar mode must be a multiple of 8,*/
/* for all other component modes a multiple of 4 and for RGB 565 a multiple of 2.*/
/* There are no restrictions for RGB 888/666.*/
     /**/
/* In planar mode the line length of the Cb and Cr component is assumed according */
/* to the YCbCr format, i.e. half for 4:2:x and the same size for 4:4:4. In semi */
/* planar 4:2:x mode the line length of the Cb and Cr component is assumed the */
/* same size.*/
     /**/
/* Note:*/
/* - Line length always refers to the line length of the output image. This */
/*   is particularly important when rotating.*/
     /**/
/* Note:*/
/* - Programmed value becomes effective immediately. So write to the register */
/*   only if no picture data is sent to the self path.*/
#ifdef MRV_MI_SP_Y_LLENGTH
#define MRV_MI_SP_Y_LLENGTH_VALID_MASK          (MRV_MI_SP_Y_LLENGTH_MASK & ~0x00000000)
#endif /* MRV_MI_SP_Y_LLENGTH */
/*****************************************************************************/
/**
 * register: mi_sp_cb_base_ad_init: Base address for self picture Cb component
 *           ring buffer (0x00000050)
 *
 *****************************************************************************/
/* Slice: sp_cb_base_ad_init:*/
/* Base address of self picture Cb component ring buffer.*/
     /**/
/* Programmed value becomes effective (visible in corresponding shadow register)*/
/* after a soft reset, a forced software update or an automatic config update.*/
     /**/
/* Note: Set control bit init_base_en before updating so that a forced or */
/*       automatic update can take effect.*/
     /**/
/* Must be 64-bit aligned (bit 0, bit 1 and bit 2 are hard wired to "000")*/
#ifdef MRV_MI_SP_CB_BASE_AD_INIT
#define MRV_MI_SP_CB_BASE_AD_INIT_VALID_MASK    (MRV_MI_SP_CB_BASE_AD_INIT_MASK & ~0x00000007)
#endif /* MRV_MI_SP_CB_BASE_AD_INIT */
/*****************************************************************************/
/**
 * register: mi_sp_cb_size_init: Size of self picture Cb component ring buffer
 *           (0x00000054)
 *
 *****************************************************************************/
/* Slice: sp_cb_size_init:*/
/* Size of self picture Cb component ring buffer.*/
     /**/
/* Programmed value becomes effective (visible in corresponding shadow register)*/
/* after a soft reset, a forced software update or an automatic config update.*/
     /**/
/* Note:*/
/* - Set control bit init_base_en before updating so that a forced or automatic */
/*   update can take effect.*/
     /**/
/* Must be 64-bit aligned (bit 0, bit 1 and bit 2 are hard wired to "000")*/
#ifdef MRV_MI_SP_CB_SIZE_INIT
#define MRV_MI_SP_CB_SIZE_INIT_VALID_MASK       (MRV_MI_SP_CB_SIZE_INIT_MASK & ~0x00000007)
#endif /* MRV_MI_SP_CB_SIZE_INIT */
/*****************************************************************************/
/**
 * register: mi_sp_cb_offs_cnt_init: Offset counter init value for self picture
 *           Cb component ring buffer (0x00000058)
 *
 *****************************************************************************/
/* Slice: sp_cb_offs_cnt_init:*/
/* Offset counter init value of self picture Cb component ring buffer.*/
     /**/
/* Programmed value becomes effective (visible in corresponding shadow register)*/
/* after a soft reset, a forced software update or an automatic config update.*/
     /**/
/* Note:*/
/* - Set control bit init_base_en before updating so that a forced or automatic */
/*   update can take effect.*/
     /**/
/* Must be 64-bit aligned (bit 0, bit 1 and bit 2 are hard wired to "000")*/
#ifdef MRV_MI_SP_CB_OFFS_CNT_INIT
#define MRV_MI_SP_CB_OFFS_CNT_INIT_VALID_MASK   (MRV_MI_SP_CB_OFFS_CNT_INIT_MASK & ~0x00000007)
#endif /* MRV_MI_SP_CB_OFFS_CNT_INIT */
/*****************************************************************************/
/**
 * register: mi_sp_cb_offs_cnt_start: Offset counter start value for self
 *           picture Cb component ring buffer (0x0000005c)
 *
 *****************************************************************************/
/* Slice: sp_cb_offs_cnt_start:*/
     /**/
/* Offset counter value which points to the start address of the previously */
/* processed picture (self picture Cb component). Updated at frame end.*/
     /**/
/* Note:*/
/* - Soft reset will reset the contents to reset value.*/
     /**/
/* Must be 64-bit aligned (bit 0, bit 1 and bit 2 are hard wired to "000")*/
#ifdef MRV_MI_SP_CB_OFFS_CNT_START
#define MRV_MI_SP_CB_OFFS_CNT_START_VALID_MASK  (MRV_MI_SP_CB_OFFS_CNT_START_MASK & ~0x00000007)
#endif /* MRV_MI_SP_CB_OFFS_CNT_START */
/*****************************************************************************/
/**
 * register: mi_sp_cr_base_ad_init: Base address for self picture Cr component
 *           ring buffer (0x00000060)
 *
 *****************************************************************************/
/* Slice: sp_cr_base_ad_init:*/
/* Base address of self picture Cr component ring buffer.*/
     /**/
/* Programmed value becomes effective (visible in corresponding shadow register)*/
/* after a soft reset, a forced software update or an automatic config update.*/
     /**/
/* Note:*/
/* - Set control bit init_base_en before updating so that a forced or automatic */
/*   update can take effect.*/
     /**/
/* Must be 64-bit aligned (bit 0, bit 1 and bit 2 are hard wired to "000")*/
#ifdef MRV_MI_SP_CR_BASE_AD_INIT
#define MRV_MI_SP_CR_BASE_AD_INIT_VALID_MASK    (MRV_MI_SP_CR_BASE_AD_INIT_MASK & ~0x00000007)
#endif /* MRV_MI_SP_CR_BASE_AD_INIT */
/*****************************************************************************/
/**
 * register: mi_sp_cr_size_init: Size of self picture Cr component ring buffer
 *           (0x00000064)
 *
 *****************************************************************************/
/* Slice: sp_cr_size_init:*/
/* Size of self picture Cr component ring buffer.*/
/* Programmed value becomes effective (visible in corresponding shadow register)*/
/* after a soft reset, a forced software update or an automatic config update.*/
     /**/
/* Note:*/
/* - Set control bit init_base_en before updating so that a forced or automatic */
/*   update can take effect.*/
     /**/
/* Must be 64-bit aligned (bit 0, bit 1 and bit 2 are hard wired to "000")*/
#ifdef MRV_MI_SP_CR_SIZE_INIT
#define MRV_MI_SP_CR_SIZE_INIT_VALID_MASK       (MRV_MI_SP_CR_SIZE_INIT_MASK & ~0x00000007)
#endif /* MRV_MI_SP_CR_SIZE_INIT */
/*****************************************************************************/
/**
 * register: mi_sp_cr_offs_cnt_init: Offset counter init value for self
 *           picture Cr component ring buffer (0x00000068)
 *
 *****************************************************************************/
/* Slice: sp_cr_offs_cnt_init:*/
/* Offset counter init value of self picture Cr component ring buffer.*/
     /**/
/* Programmed value becomes effective (visible in corresponding shadow register)*/
/* after a soft reset, a forced software update or an automatic config update.*/
     /**/
/* Note:*/
/* - Set control bit init_base_en before updating so that a forced or automatic */
/*   update can take effect.*/
     /**/
/* Must be 64-bit aligned (bit 0, bit 1 and bit 2 are hard wired to "000")*/
#ifdef MRV_MI_SP_CR_OFFS_CNT_INIT
#define MRV_MI_SP_CR_OFFS_CNT_INIT_VALID_MASK   (MRV_MI_SP_CR_OFFS_CNT_INIT_MASK & ~0x00000007)
#endif /* MRV_MI_SP_CR_OFFS_CNT_INIT */
/*****************************************************************************/
/**
 * register: mi_sp_cr_offs_cnt_start: Offset counter start value for self
 *           picture Cr component ring buffer (0x0000006c)
 *
 *****************************************************************************/
/* Slice: sp_cr_offs_cnt_start:*/
/* Offset counter value which points to the start address of the previously */
/* processed picture (self picture Cr component). Updated at frame end.*/
     /**/
/* Must be 64-bit aligned (bit 0, bit 1 and bit 2 are hard wired to "000")*/
#ifdef MRV_MI_SP_CR_OFFS_CNT_START
#define MRV_MI_SP_CR_OFFS_CNT_START_VALID_MASK  (MRV_MI_SP_CR_OFFS_CNT_START_MASK & ~0x00000007)
#endif /* MRV_MI_SP_CR_OFFS_CNT_START */
/*****************************************************************************/
/**
 * register: mi_byte_cnt: Counter value of JPEG or RAW data bytes (0x00000070)
 *
 *****************************************************************************/
/* Slice: byte_cnt:*/
/* Counter value specifies the number of JPEG or RAW data bytes of the last */
/* transmitted frame. Updated at frame end.*/
     /**/
/* A soft reset will set the byte counter to zero.*/
#ifdef MRV_MI_BYTE_CNT
#endif /* MRV_MI_BYTE_CNT */
/*****************************************************************************/
/**
 * register: mi_ctrl_shd: global control internal shadow register (0x00000074)
 *
 *****************************************************************************/
/* Slice: path_enable_out:*/
/* path_enable shadow register for module MI_OUT (former raw_enable_out,*/
/* jpeg_enable_out, sp_enable_out, mp_enable_out)*/
#ifdef MRV_MI_PATH_ENABLE_OUT
#endif /* MRV_MI_PATH_ENABLE_OUT */
/* Slice: path_enable_in:*/
/* path_enable shadow register for module MI_IN (former raw_enable_in,*/
/* jpeg_enable_in, sp_enable_in, mp_enable_in)*/
#ifdef MRV_MI_PATH_ENABLE_IN
#endif /* MRV_MI_PATH_ENABLE_IN */
/*****************************************************************************/
/**
 * register: mi_mp_y_base_ad_shd: Base address shadow register for main
 *           picture Y component, JPEG or raw data ring buffer (0x00000078)
 *
 *****************************************************************************/
/* Slice: mp_y_base_ad:*/
/* Base address of main picture Y component ring buffer, JPEG ring buffer or */
/* raw data ring buffer.*/
     /**/
/* Must be 64-bit aligned (bit 0, bit 1 and bit 2 are hard wired to "000")*/
#ifdef MRV_MI_MP_Y_BASE_AD
#define MRV_MI_MP_Y_BASE_AD_VALID_MASK          (MRV_MI_MP_Y_BASE_AD_MASK & ~0x00000007)
#endif /* MRV_MI_MP_Y_BASE_AD */
/*****************************************************************************/
/**
 * register: mi_mp_y_size_shd: Size shadow register of main picture Y component,
 *           JPEG or raw data (0x0000007c)
 *
 *****************************************************************************/
/* Slice: mp_y_size:*/
/* Size of main picture Y component ring buffer, JPEG ring buffer or raw data */
/* ring buffer.*/
     /**/
/* Must be 64-bit aligned (bit 0, bit 1 and bit 2 are hard wired to "000")*/
#ifdef MRV_MI_MP_Y_SIZE
#define MRV_MI_MP_Y_SIZE_VALID_MASK             (MRV_MI_MP_Y_SIZE_MASK & ~0x00000007)
#endif /* MRV_MI_MP_Y_SIZE */
/*****************************************************************************/
/**
 * register: mi_mp_y_offs_cnt_shd: Current offset counter of main picture Y
 *           component, JPEG or raw data ring buffer (0x00000080)
 *
 *****************************************************************************/
/* Slice: mp_y_offs_cnt:*/
/* Current offset counter of main picture Y component, JPEG or raw data ring */
/* buffer for address generation */
     /**/
/* Note:*/
/* - Soft reset will reset the contents to reset value.*/
     /**/
/* Must be 64-bit aligned (bit 0, bit 1 and bit 2 are hard wired to "000")*/
#ifdef MRV_MI_MP_Y_OFFS_CNT
#define MRV_MI_MP_Y_OFFS_CNT_VALID_MASK         (MRV_MI_MP_Y_OFFS_CNT_MASK & ~0x00000007)
#endif /* MRV_MI_MP_Y_OFFS_CNT */
/*****************************************************************************/
/**
 * register: mi_mp_y_irq_offs_shd: Shadow register of fill level interrupt
 *           offset value for main picture Y component, JPEG or raw data
 *           (0x00000084)
 *
 *****************************************************************************/
/* Slice: mp_y_irq_offs:*/
/* Reaching this offset value by the current offset counter for addressing */
/* main picture Y component, JPEG or raw data leads to generation of fill */
/* level interrupt fill_mp_y.*/
     /**/
/* Must be 64-bit aligned (bit 0, bit 1 and bit 2 are hard wired to "000")*/
#ifdef MRV_MI_MP_Y_IRQ_OFFS
#endif /* MRV_MI_MP_Y_IRQ_OFFS */
/*****************************************************************************/
/**
 * register: mi_mp_cb_base_ad_shd: Base address shadow register for main
 *           picture Cb component ring buffer (0x00000088)
 *
 *****************************************************************************/
/* Slice: mp_cb_base_ad:*/
/* Base address of main picture Cb component ring buffer.*/
     /**/
/* Must be 64-bit aligned (bit 0, bit 1 and bit 2 are hard wired to "000")*/
#ifdef MRV_MI_MP_CB_BASE_AD
#endif /* MRV_MI_MP_CB_BASE_AD */
/*****************************************************************************/
/**
 * register: mi_mp_cb_size_shd: Size shadow register of main picture Cb
 *           component ring buffer (0x0000008c)
 *
 *****************************************************************************/
/* Slice: mp_cb_size:*/
/* Size of main picture Cb component ring buffer.*/
     /**/
/* Must be 64-bit aligned (bit 0, bit 1 and bit 2 are hard wired to "000")*/
#ifdef MRV_MI_MP_CB_SIZE
#endif /* MRV_MI_MP_CB_SIZE */
/*****************************************************************************/
/**
 * register: mi_mp_cb_offs_cnt_shd: Current offset counter of main picture Cb
 *           component ring buffer (0x00000090)
 *
 *****************************************************************************/
/* Slice: mp_cb_offs_cnt:*/
/* Current offset counter of main picture Cb component ring buffer for address */
/* generation */
     /**/
/* Note:*/
/* - Soft reset will reset the contents to reset value.*/
     /**/
/* Must be 64-bit aligned (bit 0, bit 1 and bit 2 are hard wired to "000")*/
#ifdef MRV_MI_MP_CB_OFFS_CNT
#endif /* MRV_MI_MP_CB_OFFS_CNT */
/*****************************************************************************/
/**
 * register: mi_mp_cr_base_ad_shd: Base address shadow register for main
 *           picture Cr component ring buffer (0x00000094)
 *
 *****************************************************************************/
/* Slice: mp_cr_base_ad:*/
/* Base address of main picture Cr component ring buffer.*/
     /**/
/* Must be 64-bit aligned (bit 0, bit 1 and bit 2 are hard wired to "000")*/
#ifdef MRV_MI_MP_CR_BASE_AD
#endif /* MRV_MI_MP_CR_BASE_AD */
/*****************************************************************************/
/**
 * register: mi_mp_cr_size_shd: Size shadow register of main picture Cr
 *           component ring buffer (0x00000098)
 *
 *****************************************************************************/
/* Slice: mp_cr_size:*/
/* Size of main picture Cr component ring buffer.*/
     /**/
/* Must be 64-bit aligned (bit 0, bit 1 and bit 2 are hard wired to "000")*/
#ifdef MRV_MI_MP_CR_SIZE
#endif /* MRV_MI_MP_CR_SIZE */
/*****************************************************************************/
/**
 * register: mi_mp_cr_offs_cnt_shd: Current offset counter of main picture Cr
 *           component ring buffer (0x0000009c)
 *
 *****************************************************************************/
/* Slice: mp_cr_offs_cnt:*/
/* Current offset counter of main picture Cr component ring buffer for */
/* address generation */
     /**/
/* Note:*/
/* - Soft reset will reset the contents to reset value.*/
     /**/
/* Must be 64-bit aligned (bit 0, bit 1 and bit 2 are hard wired to "000")*/
#ifdef MRV_MI_MP_CR_OFFS_CNT
#endif /* MRV_MI_MP_CR_OFFS_CNT */
/*****************************************************************************/
/**
 * register: mi_sp_y_base_ad_shd: Base address shadow register for self
 *           picture Y component ring buffer (0x000000a0)
 *
 *****************************************************************************/
/* Slice: sp_y_base_ad:*/
/* Base address of self picture Y component ring buffer.*/
     /**/
/* Must be 64-bit aligned (bit 0, bit 1 and bit 2 are hard wired to "000")*/
#ifdef MRV_MI_SP_Y_BASE_AD
#endif /* MRV_MI_SP_Y_BASE_AD */
/*****************************************************************************/
/**
 * register: mi_sp_y_size_shd: Size shadow register of self picture Y
 *           component ring buffer (0x000000a4)
 *
 *****************************************************************************/
/* Slice: sp_y_size:*/
/* Size of self picture Y component ring buffer.*/
     /**/
/* Must be 64-bit aligned (bit 0, bit 1 and bit 2 are hard wired to "000")*/
#ifdef MRV_MI_SP_Y_SIZE
#endif /* MRV_MI_SP_Y_SIZE */
/*****************************************************************************/
/**
 * register: mi_sp_y_offs_cnt_shd: Current offset counter of self picture Y
 *           component ring buffer (0x000000a8)
 *
 *****************************************************************************/
/* Slice: sp_y_offs_cnt:*/
/* Current offset counter of self picture Y component ring buffer for address generation */
     /**/
/* Note:*/
/* - Soft reset will reset the contents to reset value.*/
     /**/
/* Must be 64-bit aligned (bit 0, bit 1 and bit 2 are hard wired to "000")*/
#ifdef MRV_MI_SP_Y_OFFS_CNT
#endif /* MRV_MI_SP_Y_OFFS_CNT */
/*****************************************************************************/
/**
 * register: mi_sp_cb_base_ad_shd: Base address shadow register for self
 *           picture Cb component ring buffer (0x000000b0)
 *
 *****************************************************************************/
/* Slice: sp_cb_base_ad:*/
/* Base address of self picture Cb component ring buffer.*/
     /**/
/* Must be 64-bit aligned (bit 0, bit 1 and bit 2 are hard wired to "000")*/
#ifdef MRV_MI_SP_CB_BASE_AD
#endif /* MRV_MI_SP_CB_BASE_AD */
/*****************************************************************************/
/**
 * register: mi_sp_cb_size_shd: Size shadow register of self picture Cb
 *           component ring buffer (0x000000b4)
 *
 *****************************************************************************/
/* Slice: sp_cb_size:*/
/* Size of self picture Cb component ring buffer.*/
     /**/
/* Must be 64-bit aligned (bit 0, bit 1 and bit 2 are hard wired to "000")*/
#ifdef MRV_MI_SP_CB_SIZE
#endif /* MRV_MI_SP_CB_SIZE */
/*****************************************************************************/
/**
 * register: mi_sp_cb_offs_cnt_shd: Current offset counter of self picture
 *           Cb component ring buffer (0x000000b8)
 *
 *****************************************************************************/
/* Slice: sp_cb_offs_cnt:*/
/* Current offset counter of self picture Cb component ring buffer for */
/* address generation */
     /**/
/* Note:*/
/* - Soft reset will reset the contents to reset value.*/
     /**/
/* Must be 64-bit aligned (bit 0, bit 1 and bit 2 are hard wired to "000")*/
#ifdef MRV_MI_SP_CB_OFFS_CNT
#endif /* MRV_MI_SP_CB_OFFS_CNT */
/*****************************************************************************/
/**
 * register: mi_sp_cr_base_ad_shd: Base address shadow register for self
 *           picture Cr component ring buffer (0x000000bc)
 *
 *****************************************************************************/
/* Slice: sp_cr_base_ad:*/
/* Base address of self picture Cr component ring buffer.*/
     /**/
/* Must be 64-bit aligned (bit 0, bit 1 and bit 2 are hard wired to "000")*/
#ifdef MRV_MI_SP_CR_BASE_AD
#endif /* MRV_MI_SP_CR_BASE_AD */
/*****************************************************************************/
/**
 * register: mi_sp_cr_size_shd: Size shadow register of self picture Cr
 *           component ring buffer (0x000000c0)
 *
 *****************************************************************************/
/* Slice: sp_cr_size:*/
/* Size of self picture Cr component ring buffer.*/
     /**/
/* Must be 64-bit aligned (bit 0, bit 1 and bit 2 are hard wired to "000")*/
#ifdef MRV_MI_SP_CR_SIZE
#endif /* MRV_MI_SP_CR_SIZE */
/*****************************************************************************/
/**
 * register: mi_sp_cr_offs_cnt_shd: Current offset counter of self picture Cr
 *           component ring buffer (0x000000c4)
 *
 *****************************************************************************/
/* Slice: sp_cr_offs_cnt:*/
/* Current offset counter of self picture Cr component ring buffer for */
/* address generation */
     /**/
/* Note:*/
/* - Soft reset will reset the contents to reset value.*/
     /**/
/* Must be 64-bit aligned (bit 0, bit 1 and bit 2 are hard wired to "000")*/
#ifdef MRV_MI_SP_CR_OFFS_CNT
#endif /* MRV_MI_SP_CR_OFFS_CNT */
/*****************************************************************************/
/**
 * register: mi_dma_y_pic_start_ad: Y component image start address (0x000000c8)
 *
 *****************************************************************************/
/* Slice: dma_y_pic_start_ad:*/
/* Image start address of the y component */
     /**/
/* Note:*/
/* - Must be multiple of 4 in interleaved mode.*/
#ifdef MRV_MI_DMA_Y_PIC_START_AD
#endif /* MRV_MI_DMA_Y_PIC_START_AD */
/*****************************************************************************/
/**
 * register: mi_dma_y_pic_width: Y component image width (0x000000cc)
 *
 *****************************************************************************/
/* Slice: dma_y_pic_width:*/
/* Image width of the Y component in pixel.*/
     /**/
/* For YCbCr 4:2:x the image width must be a multiple of 2.*/
     /**/
/* In planar mode the image width of the Cb and Cr component is assumed */
/* according to the YCbCr format, i.e. half for 4:2:x and the same size for 4:4:4.*/
     /**/
/* In semi planar 4:2:x mode the image width of the Cb component (which includes Cr)*/
/* is assumed the same size.*/
     /**/
/* In interleave mode no Cb/Cr image width is used.*/
#ifdef MRV_MI_DMA_Y_PIC_WIDTH
#endif /* MRV_MI_DMA_Y_PIC_WIDTH */
/*****************************************************************************/
/**
 * register: mi_dma_y_llength: Y component original line length (0x000000d0)
 *
 *****************************************************************************/
/* Slice: dma_y_llength:*/
/* Line length of the Y component of the original image in memory */
     /**/
/* For an uncropped image, where lines follow each other without offset */
/* (no line stride), line length must match image width.*/
     /**/
/* For Y component the line length in 4:2:x planar mode must be a multiple of 8,*/
/* for all other component modes a multiple of 4.*/
     /**/
/* In planar mode the line length of the Cb and Cr component is assumed according */
/* to the YCbCr format, i.e. half for 4:2:x and the same size for 4:4:4.*/
     /**/
/* In semi planar 4:2:x mode the line length of the Cb component (which includes Cr)*/
/* is assumed the same size.*/
     /**/
/* In interleave mode no Cb/Cr line length is used.*/
#ifdef MRV_MI_DMA_Y_LLENGTH
#endif /* MRV_MI_DMA_Y_LLENGTH */
/*****************************************************************************/
/**
 * register: mi_dma_y_pic_size: Y component image size (0x000000d4)
 *
 *****************************************************************************/
/* Slice: dma_y_pic_size:*/
/* Image size of the Y component in pixel which has to be the Y line length */
/* multiplied by the Y image height (dma_y_llength * dma_y_pic_height).*/
     /**/
/* In planar mode the image size of the Cb and Cr component is assumed according */
/* to the YCbCr format, i.e. a quarter for 4:2:0, half for 4:2:2 and the same */
/* for 4:4:4.*/
     /**/
/* In semi planar mode the image size of the Cb component (which includes Cr)*/
/* is assumed half for 4:2:0 and the same size for 4:2:2.*/
     /**/
/* In interleave mode no Cb/Cr image size is used.*/
#ifdef MRV_MI_DMA_Y_PIC_SIZE
#endif /* MRV_MI_DMA_Y_PIC_SIZE */
/*****************************************************************************/
/**
 * register: mi_dma_cb_pic_start_ad: Cb component image start address (0x000000d8)
 *
 *****************************************************************************/
/* Slice: dma_cb_pic_start_ad:*/
/* Image start address of the Cb component */
     /**/
/* Note:*/
/* - Must be multiple of 2 in semi-planar mode.*/
#ifdef MRV_MI_DMA_CB_PIC_START_AD
#endif /* MRV_MI_DMA_CB_PIC_START_AD */
/*****************************************************************************/
/**
 * register: mi_dma_cr_pic_start_ad: Cr component image start address (0x000000e8)
 *
 *****************************************************************************/
/* Slice: dma_cr_pic_start_ad:*/
/* Image start address of the Cr component */
#ifdef MRV_MI_DMA_CR_PIC_START_AD
#endif /* MRV_MI_DMA_CR_PIC_START_AD */
/*****************************************************************************/
/**
 * register: mi_imsc: Interrupt Mask Register           (0x000000f8)
 *           mi_ris : Raw Interrupt Status Register     (0x000000fc)
 *           mi_mis : Masked Interrupt Status Register  (0x00000100)
 *           mi_icr : Interrupt Clear Register          (0x00000104)
 *           mi_isr : Interrupt Set Register            (0x00000108)
 *
 *           ('1': interrupt active, '0': interrupt masked)
 *
 *****************************************************************************/
/* Slice: dma_ready:*/
/* Mask bit for dma ready interrupt */
#ifndef MRV_MI_DMA_READY
#define MRV_MI_DMA_READY_MASK                   0
#endif /* MRV_MI_DMA_READY */
/* Slice: wrap_sp_cr:*/
/* Mask bit for self picture Cr address wrap interrupt */
#ifndef MRV_MI_WRAP_SP_CR
#define MRV_MI_WRAP_SP_CR_MASK                  0
#endif /* MRV_MI_WRAP_SP_CR */
/* Slice: wrap_sp_cb:*/
/* Mask bit for self picture Cb address wrap interrupt */
#ifndef MRV_MI_WRAP_SP_CB
#define MRV_MI_WRAP_SP_CB_MASK                  0
#endif /* MRV_MI_WRAP_SP_CB */
/* Slice: wrap_sp_y:*/
/* Mask bit for self picture Y address wrap interrupt */
#ifndef MRV_MI_WRAP_SP_Y
#define MRV_MI_WRAP_SP_Y_MASK                   0
#endif /* MRV_MI_WRAP_SP_Y */
/* Slice: wrap_mp_cr:*/
/* Mask bit for main picture Cr address wrap interrupt */
#ifndef MRV_MI_WRAP_MP_CR
#define MRV_MI_WRAP_MP_CR_MASK                  0
#endif /* MRV_MI_WRAP_MP_CR */
/* Slice: wrap_mp_cb:*/
/* Mask bit for main picture Cb address wrap interrupt */
#ifndef MRV_MI_WRAP_MP_CB
#define MRV_MI_WRAP_MP_CB_MASK                  0
#endif /* MRV_MI_WRAP_MP_CB */
/* Slice: wrap_mp_y:*/
/* Mask bit for main picture Y address wrap interrupt */
#ifndef MRV_MI_WRAP_MP_Y
#define MRV_MI_WRAP_MP_Y_MASK                   0
#endif /* MRV_MI_WRAP_MP_Y */
/* Slice: fill_mp_y:*/
/* Mask bit for fill level interrupt of main picture Y,*/
/* JPEG or raw data */
#ifndef MRV_MI_FILL_MP_Y
#define MRV_MI_FILL_MP_Y_MASK                   0
#endif /* MRV_MI_FILL_MP_Y */
/* Slice: mblk_line:*/
/* Mask bit for makroblock line interrupt of main picture */
/* (16 lines of Y, 8 lines of Cb and 8 lines of Cr are written */
/* into RAM)*/
#ifndef MRV_MI_MBLK_LINE
#define MRV_MI_MBLK_LINE_MASK                   0
#endif /* MRV_MI_MBLK_LINE */
/* Slice: sp_frame_end:*/
/* Mask self picture end of frame interrupt */
#ifndef MRV_MI_SP_FRAME_END
#define MRV_MI_SP_FRAME_END_MASK                0
#endif /* MRV_MI_SP_FRAME_END */
/* Slice: mp_frame_end:*/
/* Mask main picture end of frame interrupt */
#ifndef MRV_MI_MP_FRAME_END
#define MRV_MI_MP_FRAME_END_MASK                0
#endif /* MRV_MI_MP_FRAME_END */
/* combination of all interrupt lines */
#define MRV_MI_ALL_IRQS
#define MRV_MI_ALL_IRQS_MASK \
(0 \
	| MRV_MI_DMA_READY_MASK \
	| MRV_MI_AHB_ERROR_MASK \
	| MRV_MI_WRAP_SP_CR_MASK \
	| MRV_MI_WRAP_SP_CB_MASK \
	| MRV_MI_WRAP_SP_Y_MASK \
	| MRV_MI_WRAP_MP_CR_MASK \
	| MRV_MI_WRAP_MP_CB_MASK \
	| MRV_MI_WRAP_MP_Y_MASK \
	| MRV_MI_FILL_MP_Y_MASK \
	| MRV_MI_MBLK_LINE_MASK \
	| MRV_MI_SP_FRAME_END_MASK \
	| MRV_MI_DMA_FRAME_END_MASK \
	| MRV_MI_MP_FRAME_END_MASK \
)
#define MRV_MI_ALL_IRQS_SHIFT                   0U
/*****************************************************************************/
/**
 * register: mi_status    : MI Status Register          (0x0000010c)
 *           mi_status_clr: MI Status Clear Register    (0x00000110)
 *
 *****************************************************************************/
/* Slice: sp_cr_fifo_full:*/
/* FIFO full flag of Cr FIFO in self path asserted since last clear */
#ifndef MRV_MI_SP_CR_FIFO_FULL
#define MRV_MI_SP_CR_FIFO_FULL_MASK             0U
#endif /* MRV_MI_SP_CR_FIFO_FULL */
/* Slice: sp_cb_fifo_full:*/
/* FIFO full flag of Cb FIFO in self path asserted since last clear */
#ifndef MRV_MI_SP_CB_FIFO_FULL
#define MRV_MI_SP_CB_FIFO_FULL_MASK             0U
#endif /* MRV_MI_SP_CB_FIFO_FULL */
/* Slice: sp_y_fifo_full:*/
/* FIFO full flag of Y FIFO in self path asserted since last clear */
#ifndef MRV_MI_SP_Y_FIFO_FULL
#define MRV_MI_SP_Y_FIFO_FULL_MASK              0U
#endif /* MRV_MI_SP_Y_FIFO_FULL */
/* Slice: mp_cr_fifo_full:*/
/* FIFO full flag of Cr FIFO in main path asserted since last clear */
#ifndef MRV_MI_MP_CR_FIFO_FULL
#define MRV_MI_MP_CR_FIFO_FULL_MASK             0U
#endif /* MRV_MI_MP_CR_FIFO_FULL */
/* Slice: mp_cb_fifo_full:*/
/* FIFO full flag of Cb FIFO in main path asserted since last clear */
#ifndef MRV_MI_MP_CB_FIFO_FULL
#define MRV_MI_MP_CB_FIFO_FULL_MASK             0U
#endif /* MRV_MI_MP_CB_FIFO_FULL */
/* Slice: mp_y_fifo_full:*/
/* FIFO full flag of Y FIFO in main path asserted since last clear */
#ifndef MRV_MI_MP_Y_FIFO_FULL
#define MRV_MI_MP_Y_FIFO_FULL_MASK              0U
#endif /* MRV_MI_MP_Y_FIFO_FULL */
/* combination of all MI status lines */
#define MRV_MI_ALL_STAT
#define MRV_MI_ALL_STAT_MASK \
(0 \
	| MRV_MI_SP_CR_FIFO_FULL_MASK \
	| MRV_MI_SP_CB_FIFO_FULL_MASK \
	| MRV_MI_SP_Y_FIFO_FULL_MASK  \
	| MRV_MI_MP_CR_FIFO_FULL_MASK \
	| MRV_MI_MP_CB_FIFO_FULL_MASK \
	| MRV_MI_MP_Y_FIFO_FULL_MASK  \
)
#define MRV_MI_ALL_STAT_SHIFT                   0U
/*****************************************************************************/
/**
 * register: mi_sp_y_pic_width: Y component image width (0x00000114)
 *
 *****************************************************************************/
/* Slice: sp_y_pic_width:*/
/* Image width of the self picture Y component or RGB picture in pixel.*/
     /**/
/* For YCbCr 4:2:x and RGB 565 the image width must be a multiple of 2.*/
/* If no line stride is used but flipping required, the image width must be */
/* a multiple of 8 for 4:2:x planar or 4 for 4:4:4 planar/4:2:x semi planar.*/
     /**/
/* There are no restrictions for RGB 888/666.*/
     /**/
/* In planar mode the image width of the Cb and Cr component is assumed according */
/* to the YCbCr format, i.e. half for 4:2:x and the same size for 4:4:4.*/
     /**/
/* In semi planar 4:2:x mode the image width of the Cb component (which includes Cr)*/
/* is assumed the same size.*/
     /**/
/* In interleave mode no Cb/Cr image width is used.*/
/* Note:*/
/* - Image width always refers to the picture width of the output image. This is */
/*   particularly important when rotating.*/
     /**/
/* Note:*/
/* - Programmed value becomes effective immediately. So write to the register */
/*   only if no picture data is sent to the self path.*/
#ifdef MRV_MI_SP_Y_PIC_WIDTH
#endif /* MRV_MI_SP_Y_PIC_WIDTH */
/*****************************************************************************/
/**
 * register: mi_sp_y_pic_height: Y component image height (0x00000118)
 *
 *****************************************************************************/
/* Slice: sp_y_pic_height:*/
/* Image height of the y component or RGB picture in pixel.*/
     /**/
/* In planar and semi planar mode the image width of the cb and cr component */
/* is assumed according to the YCbCr format, i.e. half for 4:2:0 and the same */
/* for 4:2:2 and 4:4:4.*/
     /**/
/* Note:*/
/* - Image height always refers to the picture height of the output image.*/
/*   This is particularly important when rotating.*/
     /**/
/* Note:*/
/* - Programmed value becomes effective immediately. So write to the register */
/*   only if no picture data is sent to the self path.*/
#ifdef MRV_MI_SP_Y_PIC_HEIGHT
#endif /* MRV_MI_SP_Y_PIC_HEIGHT */
/*****************************************************************************/
/**
 * register: mi_sp_y_pic_size: Y component image size (0x0000011c)
 *
 *****************************************************************************/
/* Slice: sp_y_pic_size:*/
/* Image size of the Y component or RGB picture in pixel which has to be the */
/* Y line length multiplied by the Y image height (sp_y_llength * sp_y_pic_height).*/
     /**/
/* In planar mode the image size of the Cb and Cr component is assumed according */
/* to the YCbCr format, i.e. a quarter for 4:2:0, half for 4:2:2 and the same for */
/* 4:4:4.*/
     /**/
/* In semi planar mode the image size of the Cb and Cr component is assumed half */
/* for 4:2:0 and the same size for 4:2:2.*/
     /**/
/* Note:*/
/* - Programmed value becomes effective immediately. So write to the register only */
/*   if no picture data is sent to the self path.*/
#ifdef MRV_MI_SP_Y_PIC_SIZE
#endif /* MRV_MI_SP_Y_PIC_SIZE */
/*****************************************************************************/
/**
 * register: mi_dma_ctrl: DMA control register (0x00000120)
 *
 *****************************************************************************/
/* Slice: dma_rgb_format:*/
/* Selects RGB Bayer data of read DMA picture */
     /**/
/* 00: no DMA RGB Bayer data */
/* 01: 8 bit RGB Bayer data */
/* 10: 16 bit RGB Bayer data (12 bit used)*/
     /**/
/* bytes are organized MSB first and 4 lower bits of LSB remain unused:*/
/* byte_even -> bayer[11:4], byte_odd[7:4] -> bayer[3:0]*/
     /**/
/* 11: reserved.*/
#ifdef MRV_MI_DMA_RGB_FORMAT
#define MRV_MI_DMA_RGB_FORMAT_NO_DATA           0
#define MRV_MI_DMA_RGB_FORMAT_8BIT_BAYER        1
#define MRV_MI_DMA_RGB_FORMAT_16BIT_BAYER       2
#endif /* MRV_MI_DMA_RGB_FORMAT */
/* Slice: dma_frame_end_disable:*/
/* Suppresses v_end so that no frame end can be detected by following */
/* instances. Note: The dma_ready interrupt is raised as usual, but the */
/* dma_frame_end interrupt will not be generated until v_end has been */
/* enabled again.*/
#ifdef MRV_MI_DMA_FRAME_END_DISABLE
#endif /* MRV_MI_DMA_FRAME_END_DISABLE */
/* Slice: dma_continuous_en:*/
/* Enables continuous mode. If set the same frame is read back over and */
/* over. A start pulse on dma_start is needed only for the first time.*/
/* To stop continuous mode reset this bit (takes effect after the next */
/* frame end) or execute a soft reset. This bit is intended to be used */
/* in conjunction with the Superimpose feature.*/
#ifdef MRV_MI_DMA_CONTINUOUS_EN
#endif /* MRV_MI_DMA_CONTINUOUS_EN */
/* Slice: dma_byte_swap:*/
/* Enables change of DMA byte order of the 32 bit input word at read port */
/* 1: byte order is mirrored but the bit order within one byte doesnt change */
/* 0: no byte mirroring */
#ifdef MRV_MI_DMA_BYTE_SWAP
#endif /* MRV_MI_DMA_BYTE_SWAP */
/* Slice: dma_inout_format:*/
/* Selects input/output format of DMA picture.*/
/* 11: YCbCr  4:4:4 */
/* 10: YCbCr  4:2:2 */
/* 01: YCbCr  4:2:0 */
/* 00: YCbCr  4:0:0 */
#ifdef MRV_MI_DMA_INOUT_FORMAT
#define MRV_MI_DMA_INOUT_FORMAT_YUV444          3	/* 11: YCbCr  4:4:4 */
#define MRV_MI_DMA_INOUT_FORMAT_YUV422          2	/* 10: YCbCr  4:2:2 */
#define MRV_MI_DMA_INOUT_FORMAT_YUV420          1	/* 01: YCbCr  4:2:0 */
#define MRV_MI_DMA_INOUT_FORMAT_YUV400          0	/* 00: YCbCr  4:0:0 */
#endif /* MRV_MI_DMA_INOUT_FORMAT */
/* Slice: dma_read_format:*/
/* Defines how YCbCr picture data is read from memory.*/
/* 00: planar */
/* 01: semi planar, for YCbCr 4:2:x */
/* 10: interleaved (combined), for YCbCr 4:2:2 and RGB only */
/* 11: reserved */
#ifdef MRV_MI_DMA_READ_FORMAT
#define MRV_MI_DMA_READ_FORMAT_PLANAR           0	/* 00: planar */
#define MRV_MI_DMA_READ_FORMAT_SEMIPLANAR       1	/* 01: semi planar, for YCbCr 4:2:x */
#define MRV_MI_DMA_READ_FORMAT_INTERLEAVED      2	/* 10: interleaved (combined), for YCbCr 4:2:2 only */
#endif /* MRV_MI_DMA_READ_FORMAT */
/* Slice: dma_burst_len_chrom:*/
/* Burst length for Cb or Cr data affecting DMA read port.*/
/* 00: 4-beat bursts */
/* 01: 8-beat bursts */
/* 10: 16-beat bursts */
/* 11: reserved */
/* Ignored if 8- or 16-beat bursts are not supported.*/
#ifdef MRV_MI_DMA_BURST_LEN_CHROM
#define MRV_MI_DMA_BURST_LEN_CHROM_4            0	/* 0: 4-beat bursts */
#define MRV_MI_DMA_BURST_LEN_CHROM_8            1	/* 1: 8-beat bursts */
#define MRV_MI_DMA_BURST_LEN_CHROM_16           2	/* 2: 16-beat bursts */
#endif /* MRV_MI_DMA_BURST_LEN_CHROM */
/* Slice: dma_burst_len_lum:*/
/* Burst length for Y data affecting DMA read port.*/
/* 00: 4-beat bursts */
/* 01: 8-beat bursts */
/* 10: 16-beat bursts */
/* 11: reserved */
/* Ignored if 8- or 16-beat bursts are not supported.*/
#ifdef MRV_MI_DMA_BURST_LEN_LUM
#define MRV_MI_DMA_BURST_LEN_LUM_4              0	/* 0: 4-beat bursts */
#define MRV_MI_DMA_BURST_LEN_LUM_8              1	/* 1: 8-beat bursts */
#define MRV_MI_DMA_BURST_LEN_LUM_16             2	/* 2: 16-beat bursts */
#endif /* MRV_MI_DMA_BURST_LEN_LUM */
/*****************************************************************************/
/**
 * register: mi_dma_start: DMA start register (0x00000124)
 *
 *****************************************************************************/
/* Slice: dma_start:*/
/* Enables DMA access. Additionally main or self path has to be enabled separately.*/
#ifdef MRV_MI_DMA_START
#endif /* MRV_MI_DMA_START */
/*****************************************************************************/
/**
 * register:  mi_dma_status: DMA status register (0x00000128)
 *
 *****************************************************************************/
/* Slice: dma_active:*/
/* If set DMA access is active.*/
#ifdef MRV_MI_DMA_ACTIVE
#endif /* MRV_MI_DMA_ACTIVE */
/*****************************************************************************/
/**
 * register: mi_pixel_cnt: Counter value for defect pixel list (0x0000012c)
 *
 *****************************************************************************/
/* Slice: pix_cnt:*/
/* Counter value specifies the number of pixels of the defect pixel list */
/* generated by DPCC of the last transmitted frame. Updated at frame end.*/
     /**/
/* A soft reset will set the counter to zero.*/
#ifdef MRV_MI_PIX_CNT
#endif /* MRV_MI_PIX_CNT */
#ifdef ISP_MI_HANDSHAKE_NANO
/* Nano handshake */
/*****************************************************************************/
/**
 * register:  isp_handshake_ctrl_0: Nano handshake functions (0x0000014C)
 *
 *****************************************************************************/
    /*! Slice: mp_handshake_en: */
/*! Enable mp handshake function for MI MP */
#ifdef MRV_MI_MP_HANDSHK_EN
#define MRV_MI_MP_HANDSHK_EN_DISABLE    0	/* HANDSHAKE disable */
#define MRV_MI_MP_HANDSHK_EN_ENABLE     1	/* HANDSHAKE enable, active high */
#endif
/*! Slice: mp_handshk_storage_format */
/*! Define how YCbCr picture data is stored in memory */
/*! 00: Planar */
/*! 01: Semi planar, for YCbCr4:2:x */
/*! 10: Interleaved(combiled), for YCbCr 4:2:2 only or RAW format.*/
/*! 11: not support */
#ifdef MRV_MI_MP_HANDSHK_STORAGE_FORMAT
#define MRV_MI_MP_HANDSHK_STORAGE_FORMAT_PLANAR        0	/* 00: Planar */
#define MRV_MI_MP_HANDSHK_STORAGE_FORMAT_SEMIPLANAR    1	/* 01: Semi-Planar */
#define MRV_MI_MP_HANDSHK_STORAGE_FORMAT_INTERLEAVED   2	/* 10: Interleaved */
#endif
/*! Slice: mp_handshk_data_format */
/*! Defines the video format */
/*! 00: RAW format */
/*! 01: reserved */
/*! 10: YUV 422 */
/*! 11: YUV 420 */
#ifdef MRV_MI_MP_HANDSHK_DATA_FORMAT
#define MRV_MI_MP_HANDSHK_DATA_FORMAT_RAW              0	/* 00: raw format */
#define MRV_MI_MP_HANDSHK_DATA_FORMAT_YUV422           2	/* 10: YUV422 */
#define MRV_MI_MP_HANDSHK_DATA_FORMAT_YUV420           3	/* 11: YUV420 */
#endif
/*! Slice: mp_handshk_slice_size */
/*! Defines the slice size to generate handshake signals, minus 1 is used */
#ifdef MRV_MI_MP_HANDSHK_SLICE_SIZE
#endif
/*! Slice: mp_handshk_slice_buf_size */
/*! Defines the circular buffer size in number of defined slices per buffer, minus 1 is used */
#ifdef MRV_MI_MP_HANDSHK_SLICE_BUF_SIZE
#endif
/*! Slice: mp_handshk_ack_count */
/*! Defines the acknowledage is not received in the defined cycles, it will generate handshake interrupt.*/
#ifdef MRV_MI_MP_HANDSHK_ACK_COUNT
#endif
#endif
#ifdef ISP_MI_ALIGN_NANO
/* MI output Alignment */
/*****************************************************************************/
/**
 * register:  mi_output_alignment: Nano MI output alignment (0x0000015C)
 *
 *****************************************************************************/
/* Slice: mp_lsb_alignment:*/
/*! msb/lsb align for raw 10 and raw 12 formats control */
/*! 0: MSB aligned for RAW10 and RAW12 formats */
/*! 1: LSB aligned for RAW10 and RAW12 formats */
#ifdef MRV_MI_LSB_ALIGNMENT
#define MRV_MI_LSB_ALIGNMENT_MSB               0	/* MSB aligned for raw 10 and raw 12 formats */
#define MRV_MI_LSB_ALIGNMENT_LSB               1	/* LSB aligned for raw 10 and raw 12 formats */
#endif
#endif
#ifdef ISP_MI_BYTESWAP
/*! Slice mp_byte_swap:*/
/*! swap bytes for ISP Nano */
/*! bit 0 to swap bytes */
/*! bit 1 to swap words */
/*! bit 2 to swap dwords */
/*! 3'b001: ABCDEFGH => BADCFEHG */
/*! 3'b000: ABCDEFGH => ABCDEFGH */
/*! 3'b010: ABCDEFGH => CDABGHEF */
/*! 3'b011: ABCDEFGH => DCBAHGFE */
/*! 3'b100: ABCDEFGH => EFGHABCD */
/*! 3'b101: ABCDEFGH => FEHGBADC */
/*! 3'b110: ABCDEFGH => GHEFCDAB */
/*! 3'b111: ABCDEFGH => HGFEDCBA */
#ifdef MRV_MI_MP_BYTE_SWAP
#define MRV_MI_MP_BYTE_SWAP_NORMAL           0x0	/* normal mode */
#define MRV_MI_MP_BYTE_SWAP_BYTE             0x1	/* bit 0 to swap bytes */
#define MRV_MI_MP_BYTE_SWAP_WORD             0x2	/* bit 1 to swap words */
#define MRV_MI_MP_BYTE_SWAP_DWORD            0x4	/* bit 2 to swap dwords */
#endif
#endif
#ifdef ISP_MI_FIFO_DEPTH_NANO
/*****************************************************************************/
/**
 * register:  mi_mp_output_fifo_size: Nano MI fifo control (0x00000160)
 *
 *****************************************************************************/
/*! Slice output_fifo_depth:*/
/*! Select output FIFO depth setting */
/*! 00: FULL(2KBytes)*/
/*! 01: HALF(1KBytes)*/
/*! 10: 1/4(512Bytes)*/
/*! 11: 1/8(256Bytes)*/
#ifdef MRV_MI_OUTOUT_FIFO_DEPTH
#define MRV_MI_OUTOUT_FIFO_DEPTH_FULL     0	/* FULL(2KBytes) */
#define MRV_MI_OUTOUT_FIFO_DEPTH_HALF     1	/* HALF(1KBytes) */
#define MRV_MI_OUTOUT_FIFO_DEPTH_1_4      2	/* 1/4(512Bytes) */
#define MRV_MI_OUTOUT_FIFO_DEPTH_1_8      3	/* 1/8(256Bytes) */
#endif
#endif
/*****************************************************************************/
/* JPEG Encoder Registers                                                    */
/*****************************************************************************/
/*****************************************************************************/
/**
 * register: jpe_gen_header: command to start stream header generation (0x0000)
 *
 *****************************************************************************/
/* Slice: gen_header:*/
/* "1" = Start command to generate stream header */
/* auto reset to zero after one clock cycle */
#ifdef MRV_JPE_GEN_HEADER
#endif /* MRV_JPE_GEN_HEADER */
/*****************************************************************************/
/**
 * register: jpe_encode: Start command to start JFIF stream encoding (0x0004)
 *
 *****************************************************************************/
/* Slice: encode:*/
/* "1" = Start command to start JFIF stream encoding;*/
/* auto reset to zero after one clock cycle.*/
/* This bit is write-only: reading result is always zero!*/
#ifdef MRV_JPE_ENCODE
#endif /* MRV_JPE_ENCODE */
/*****************************************************************************/
/**
 * register: jpe_init: Automatic configuration update (INIT) (0x0008)
 *
 *****************************************************************************/
/* Slice: JP_INIT:*/
/* "1" = Immediate start of JPEG encoder.*/
     /**/
/* This bit has to be set after "Encode" to start the JPEG encoder. The "Encode"*/
/* command becomes active either with JP_INIT or with the input signal "CFG_UPD".*/
/* auto reset to zero after one clock cycle !!!*/
#ifdef MRV_JPE_JP_INIT
#endif /* MRV_JPE_JP_INIT */
/*****************************************************************************/
/**
 * register: jpe_y_scale_en: Y value scaling control register (0x0000000c)
 *
 *****************************************************************************/
/* Slice: y_scale_en:*/
/* Y scale flag */
/* 1: scaling Y input from [16..235] to [0..255]*/
/* 0: no Y input scaling */
#ifdef MRV_JPE_Y_SCALE_EN
#endif /* MRV_JPE_Y_SCALE_EN */
/*****************************************************************************/
/**
 * register: jpe_cbcr_scale_en: Cb/Cr value scaling control register (0x00000010)
 *
 *****************************************************************************/
/* Slice: cbcr_scale_en:*/
/* Cb/Cr scale flag */
/* 1: scaling Cb/Cr input from [16..240] to [0..255]*/
/* 0: no Cb/Cr input scaling */
#ifdef MRV_JPE_CBCR_SCALE_EN
#endif /* MRV_JPE_CBCR_SCALE_EN */
/*****************************************************************************/
/**
 * register: jpe_table_flush: header generation debug register (0x00000014)
 *
 *****************************************************************************/
/* Slice: table_flush:*/
/* header generation debug control flag */
/* (controls transmission of last header bytes if the 64 bit output buffer */
/*  is not completely filled)*/
/* 1: immediately transmit last header bytes */
/* 0: wait for encoded image data to fill output buffer */
#ifdef MRV_JPE_TABLE_FLUSH
#endif /* MRV_JPE_TABLE_FLUSH */
/*****************************************************************************/
/**
 * register: jpe_enc_hsize: JPEG codec horizontal image size for encoding
 *           (0x00000018)
 *
 *****************************************************************************/
/* Slice: enc_hsize:*/
/* JPEG codec horizontal image size for R2B and SGEN blocks */
#ifdef MRV_JPE_ENC_HSIZE
#endif /* MRV_JPE_ENC_HSIZE */
/*****************************************************************************/
/**
 * register: jpe_enc_vsize: JPEG codec vertical image size for encoding
 *           (0x0000001c)
 *
 *****************************************************************************/
/* Slice: enc_vsize:*/
/* JPEG codec vertical image size for R2B and SGEN blocks */
#ifdef MRV_JPE_ENC_VSIZE
#endif /* MRV_JPE_ENC_VSIZE */
/*****************************************************************************/
/**
 * register: jpe_pic_format: JPEG picture encoding format (0x00000020)
 *
 *****************************************************************************/
/* Slice: enc_pic_format:*/
/* "0:0:1"  = 4:2:2 format */
/* "1:x:x"  = 4:0:0 format */
#ifdef MRV_JPE_ENC_PIC_FORMAT
#define MRV_JPE_ENC_PIC_FORMAT_422              1	/* "0:0:1"  = 4:2:2 format */
#define MRV_JPE_ENC_PIC_FORMAT_400              4	/* "1:x:x"  = 4:0:0 format */
#endif /* MRV_JPE_ENC_PIC_FORMAT */
/*****************************************************************************/
/**
 * register: jpe_restart_interval: restart marker insertion register (0x0024)
 *
 *****************************************************************************/
/* Slice: restart_interval:*/
/* No of MCU in  reset interval via host */
#ifdef MRV_JPE_RESTART_INTERVAL
#endif /* MRV_JPE_RESTART_INTERVAL */
/*****************************************************************************/
/**
 * register: jpe_tq_y_select: Q- table selector 0, quant. table for Y
 *           component (0x00000028)
 *
 *****************************************************************************/
/* Slice: tq0_select:*/
/* "00" = qtable 0 */
/* "01" = qtable 1 */
/* "10" = qtable 2 */
/* "11" = qtable 3 */
#ifdef MRV_JPE_TQ0_SELECT
#endif /* MRV_JPE_TQ0_SELECT */
/*****************************************************************************/
/**
 * register: jpe_tq_u_select: Q- table selector 1, quant. table for U
 *           component (0x0000002c)
 *
 *****************************************************************************/
/* Slice: tq1_select:*/
/* "00" = qtable 0 */
/* "01" = qtable 1 */
/* "10" = qtable 2 */
/* "11" = qtable 3 */
#ifdef MRV_JPE_TQ1_SELECT
#endif /* MRV_JPE_TQ1_SELECT */
/*****************************************************************************/
/**
 * register: jpe_tq_v_select: Q- table selector 2, quant. table for V
 *           component (0x00000030)
 *
 *****************************************************************************/
/* Slice: tq2_select:*/
/* "00" = qtable 0 */
/* "01" = qtable 1 */
/* "10" = qtable 2 */
/* "11" = qtable 3 */
#ifdef MRV_JPE_TQ2_SELECT
#endif /* MRV_JPE_TQ2_SELECT */
#define MRV_JPE_TQ_SELECT_TAB3                  3	/* "11": qtable 3 */
#define MRV_JPE_TQ_SELECT_TAB2                  2	/* "10": qtable 2 */
#define MRV_JPE_TQ_SELECT_TAB1                  1	/* "01": qtable 1 */
#define MRV_JPE_TQ_SELECT_TAB0                  0	/* "00": qtable 0 */
/*****************************************************************************/
/**
 * register: jpe_dc_table_select: Huffman table selector for DC values
 *           (0x00000034)
 *
 *****************************************************************************/
/* Slice: dc_table_select_v:*/
/* "0" = dc table 0; color component 2 (V)*/
/* "1" = dc table 1; color component 2 (V)*/
#ifdef MRV_JPE_DC_TABLE_SELECT_V
#endif /* MRV_JPE_DC_TABLE_SELECT_V */
/* Slice: dc_table_select_u:*/
/* "0" = dc table 0; color component 1 (U)*/
/* "1" = dc table 1; color component 1 (U)*/
#ifdef MRV_JPE_DC_TABLE_SELECT_U
#endif /* MRV_JPE_DC_TABLE_SELECT_U */
/* Slice: dc_table_select_y:*/
/* "0" = dc table 0; color component 0 (Y)*/
/* "1" = dc table 1; color component 0 (Y)*/
#ifdef MRV_JPE_DC_TABLE_SELECT_Y
#endif /* MRV_JPE_DC_TABLE_SELECT_Y */
/*****************************************************************************/
/**
 * register: jpe_ac_table_select: Huffman table selector for AC values
 *           (0x00000038)
 *
 *****************************************************************************/
/* Slice: ac_table_select_v:*/
/* "0" = ac table 0; component 2 (V)*/
/* "1" = ac table 1; component 2 (V)*/
#ifdef MRV_JPE_AC_TABLE_SELECT_V
#endif /* MRV_JPE_AC_TABLE_SELECT_V */
/* Slice: ac_table_select_u:*/
/* "0" = ac table 0; component 1 (U)*/
/* "1" = ac table 1; component 1 (U)*/
#ifdef MRV_JPE_AC_TABLE_SELECT_U
#endif /* MRV_JPE_AC_TABLE_SELECT_U */
/* Slice: ac_table_select_y:*/
/* "0" = ac table 0; component 0 (Y)*/
/* "1" = ac table 1; component 0 (Y)*/
#ifdef MRV_JPE_AC_TABLE_SELECT_Y
#endif /* MRV_JPE_AC_TABLE_SELECT_Y */
/*****************************************************************************/
/**
 * register: jpe_table_data: table programming register (0x0000003c)
 *
 *****************************************************************************/
/* Slice: table_wdata_h:*/
/* Table data MSB */
#ifdef MRV_JPE_TABLE_WDATA_H
#endif /* MRV_JPE_TABLE_WDATA_H */
/* Slice: table_wdata_l:*/
/* Table data LSB */
#ifdef MRV_JPE_TABLE_WDATA_L
#endif /* MRV_JPE_TABLE_WDATA_L */
/*****************************************************************************/
/**
 * register: jpe_table_id: table programming select register (0x00000040)
 *
 *****************************************************************************/
/* Slice: table_id:*/
/* select table */
/* "0000" : Q-table 0 */
/* "0001" : Q-table 1 */
/* "0010" : Q-table 2 */
/* "0011" : Q-table 3 */
/* "0100" : VLC DC-table 0 */
/* "0101" : VLC AC-table 0 */
/* "0110" : VLC DC-table 1 */
/* "0111" : VLC AC-table 1 */
/* "1xxx" : reserved for debug */
#ifdef MRV_JPE_TABLE_ID
#define MRV_JPE_TABLE_ID_QUANT0                 0	/* "0000" : Q-table 0 */
#define MRV_JPE_TABLE_ID_QUANT1                 1	/* "0001" : Q-table 1 */
#define MRV_JPE_TABLE_ID_QUANT2                 2	/* "0010" : Q-table 2 */
#define MRV_JPE_TABLE_ID_QUANT3                 3	/* "0011" : Q-table 3 */
#define MRV_JPE_TABLE_ID_VLC_DC0                4	/* "0100" : VLC DC-table 0 */
#define MRV_JPE_TABLE_ID_VLC_AC0                5	/* "0101" : VLC AC-table 0 */
#define MRV_JPE_TABLE_ID_VLC_DC1                6	/* "0110" : VLC DC-table 1 */
#define MRV_JPE_TABLE_ID_VLC_AC1                7	/* "0111" : VLC AC-table 1 */
#endif /* MRV_JPE_TABLE_ID */
/*****************************************************************************/
/**
 * register: jpe_tac0_len: Huffman AC table 0 length (0x0044)
 *
 *****************************************************************************/
/* Slice: tac0_len:*/
/* Huffman table length for ac0 table */
#ifdef MRV_JPE_TAC0_LEN
#endif /* MRV_JPE_TAC0_LEN */
/*****************************************************************************/
/**
 * register: jpe_tdc0_len: Huffman DC table 0 length (0x00000048)
 *
 *****************************************************************************/
/* Slice: tdc0_len:*/
/* Huffman table length for dc0 table */
#ifdef MRV_JPE_TDC0_LEN
#endif /* MRV_JPE_TDC0_LEN */
/*****************************************************************************/
/**
 * register: jpe_tac1_len: Huffman AC table 1 length (0x0000004c)
 *
 *****************************************************************************/
/* Slice: tac1_len:*/
/* Huffman table length for ac1 table */
#ifdef MRV_JPE_TAC1_LEN
#endif /* MRV_JPE_TAC1_LEN */
/*****************************************************************************/
/**
 * register: jpe_tdc1_len: Huffman DC table 1 length (0x00000050)
 *
 *****************************************************************************/
/* Slice: tdc1_len:*/
/* Huffman table length for dc1 table */
#ifdef MRV_JPE_TDC1_LEN
#endif /* MRV_JPE_TDC1_LEN */
/*****************************************************************************/
/**
 * register: jpe_encoder_busy: encoder status flag (0x00000058)
 *
 *****************************************************************************/
/* Slice: codec_busy:*/
/* Bit 0 = "1" : JPEG codec in process */
#ifdef MRV_JPE_CODEC_BUSY
#endif /* MRV_JPE_CODEC_BUSY */
/*****************************************************************************/
/**
 * register: jpe_header_mode: header mode definition (0x0000005c)
 *
 *****************************************************************************/
/* Slice: header_mode:*/
/* "00" = no header */
/* "01" = reserved */
/* "10" = JFIF 1.02 header */
/* "11" = reserved */
#ifdef MRV_JPE_HEADER_MODE
#define MRV_JPE_HEADER_MODE_NONE                0	/* "00" = no APPn header */
#define MRV_JPE_HEADER_MODE_JFIF                2	/* "10" = JFIF header */
#endif /* MRV_JPE_HEADER_MODE */
/*****************************************************************************/
/**
 * register: jpe_encode_mode: encode mode (0x00000060)
 *
 *****************************************************************************/
/* Slice: encode_mode:*/
/* Always  "1", because this is the encoder only edition */
#ifdef MRV_JPE_ENCODE_MODE
#endif /* MRV_JPE_ENCODE_MODE */
/*****************************************************************************/
/**
 * register: jpe_debug: debug information register (0x00000064)
 *
 *****************************************************************************/
/* Slice: deb_bad_table_access:*/
/* Debug signal only (set if an access to the TABLE_DATA or to the TABLE_ID */
/* register is performed, when the JPEG_ENCODER is busy. In this case a default */
/* PVCI Acknowledge is generated. Thus the configuration bus is not blocked)*/
#ifdef MRV_JPE_DEB_BAD_TABLE_ACCESS
#endif /* MRV_JPE_DEB_BAD_TABLE_ACCESS */
/* Slice: deb_vlc_table_busy:*/
/* Debug signal only (vlc access to huff-tables)*/
#ifdef MRV_JPE_DEB_VLC_TABLE_BUSY
#endif /* MRV_JPE_DEB_VLC_TABLE_BUSY */
/* Slice: deb_r2b_memory_full:*/
/* Debug signal only (line memory status of r2b)*/
#ifdef MRV_JPE_DEB_R2B_MEMORY_FULL
#endif /* MRV_JPE_DEB_R2B_MEMORY_FULL */
/* Slice: deb_vlc_encode_busy:*/
/* Debug signal only (vlc encode processing active)*/
#ifdef MRV_JPE_DEB_VLC_ENCODE_BUSY
#endif /* MRV_JPE_DEB_VLC_ENCODE_BUSY */
/* Slice: deb_qiq_table_acc:*/
/* Debug signal only (QIQ table access)*/
#ifdef MRV_JPE_DEB_QIQ_TABLE_ACC
#endif /* MRV_JPE_DEB_QIQ_TABLE_ACC */
/*****************************************************************************/
/**
 * register: jpe_error_imr: JPEG error interrupt mask register          (0x00000068)
 *           jpe_error_ris: JPEG error raw  interrupt status register   (0x0000006c)
 *           jpe_error_mis: JPEG error masked interrupt status register (0x00000070)
 *           jpe_error_icr: JPEG error interrupt set register           (0x00000074)
 *           jpe_error_isr: JPEG error interrupt clear register         (0x00000078)
 *
 *****************************************************************************/
/* Slice: vlc_table_err:*/
/* "1" = interrupt is  activated (masked in)*/
#ifdef MRV_JPE_VLC_TABLE_ERR
#endif /* MRV_JPE_VLC_TABLE_ERR */
/* Slice: r2b_IMG_size_err:*/
/* "1" = interrupt is  activated (masked in)*/
#ifdef MRV_JPE_R2B_IMG_SIZE_ERR
#endif /* MRV_JPE_R2B_IMG_SIZE_ERR */
/* Slice: DCT_ERR:*/
/* "1" = interrupt is  activated (masked in)*/
#ifdef MRV_JPE_DCT_ERR
#endif /* MRV_JPE_DCT_ERR */
/* Slice: vlc_symbol_err:*/
/* "1" = interrupt is  activated (masked in)*/
#ifdef MRV_JPE_VLC_SYMBOL_ERR
#endif /* MRV_JPE_VLC_SYMBOL_ERR */
/*****************************************************************************/
/**
 * register: jpe_status_imr: JPEG status interrupt mask register            (0x0000007c)
 *           jpe_status_ris: JPEG status raw interrupt status register      (0x00000080)
 *           jpe_status_mis: JPEG status masked interrupt status register   (0x00000084)
 *           jpe_status_icr: JPEG status interrupt clear register           (0x00000088)
 *           jpe_status_isr: JPEG status interrupt set register             (0x0000008c)
 *
 *****************************************************************************/
/* Slice: gen_header_done:*/
/* "1" = interrupt is activated (masked in)*/
#ifdef MRV_JPE_GEN_HEADER_DONE
#endif /* MRV_JPE_GEN_HEADER_DONE */
/* Slice: encode_done:*/
/* "1" = interrupt is activated (masked in)*/
#ifdef MRV_JPE_ENCODE_DONE
#endif /* MRV_JPE_ENCODE_DONE */
/*****************************************************************************/
/**
 * register: jpe_config: JPEG configuration register (0x00000090)
 *
 *****************************************************************************/
/* Slice: speedview_en:*/
/* 1: speed view enabled */
/* 0: speed view disabled */
#ifdef MRV_JPE_SPEEDVIEW_EN
#define MRV_JPE_SPEEDVIEW_EN_DISABLE            0	/* "0": JPEG Stream Encoding according to JPEG standard */
#define MRV_JPE_SPEEDVIEW_EN_ENABLE             1	/* "1": SpeedView JPEG Stream Encoding enabled */
#endif /* MRV_JPE_SPEEDVIEW_EN */
/* Slice: cont_mode:*/
/* Encoder continous mode */
/* "00": encoder stops at frame end (corresponds to former behavior)*/
/* "01": encoder starts automatically to encode the next frame */
/* "10": unused */
/* "11": encoder first generates next header and then encodes automatically the next frame */
/* These settings are checked after encoding one frame. They are not auto-reset by hardware.*/
#ifdef MRV_JPE_CONT_MODE
#define MRV_JPE_CONT_MODE_STOP                  0	/* "00": encoder stops at frame end (corresponds to former behavior) */
#define MRV_JPE_CONT_MODE_NEXT                  1	/* "01": encoder starts automatically to encode the next frame */
#define MRV_JPE_CONT_MODE_HEADER                3	/* "11": encoder first generates next header and then encodes automatically the next frame */
#endif /* MRV_JPE_CONT_MODE */
/*****************************************************************************/
/* MIPI Registers                                                            */
/*****************************************************************************/
/*****************************************************************************/
/**
 * register: mipi_ctrl: global control register (0x0000)
 *
 *****************************************************************************/
/* Slice: S_ENABLE_CLK */
/* 1: enable sensor clock lane (DEFAULT)*/
/* 0: disable sensor clock lane */
#ifdef MRV_MIPI_S_ENABLE_CLK
#endif /* MRV_MIPI_S_ENABLE_CLK */
/* Slice: ERR_SOT_SYNC_HS_SKIP:*/
/* 1: data within the current transmission is skipped if ErrSotSyncHS is detected (default)*/
/* 0: ErrSotSyncHS does not affect transmission */
#ifdef MRV_MIPI_ERR_SOT_SYNC_HS_SKIP
#endif /* MRV_MIPI_ERR_SOT_SYNC_HS_SKIP */
/* Slice: ERR_SOT_HS_SKIP:*/
/* 1: data within the current transmission is skipped if ErrSotHS is detected */
/* 0: ErrSotHS does not affect transmission (default)*/
#ifdef MRV_MIPI_ERR_SOT_HS_SKIP
#endif /* MRV_MIPI_ERR_SOT_HS_SKIP */
/* Slice: NUM_LANES:*/
/* 00: Lane 1 is used;*/
/* 01: Lanes 1 and 2 are used;*/
/* 10: Lanes 1...3 are used;*/
/* 11: Lanes 1...4 are used */
#ifdef MRV_MIPI_NUM_LANES
#define MRV_MIPI_NUM_LANES_1                0	/* 00: Lane 1 is used */
#define MRV_MIPI_NUM_LANES_2                1	/* 01: Lanes 1 and 2 are used */
#define MRV_MIPI_NUM_LANES_3                2	/* 10: Lanes 1...3 are used */
#define MRV_MIPI_NUM_LANES_4                3	/* 11: Lanes 1...4 are used */
#endif /* MRV_MIPI_NUM_LANES */
/* Slice: SHUTDOWN_LANE:*/
/* Shutdown Lane Module. Content of this register is directly connected to the output signal shutdown[n-1:0]*/
#ifdef MRV_MIPI_SHUTDOWN_LANE
#define MRV_MIPI_SHUTDOWN_LANE_1            1	/* 0001: shutdown lane 1 */
#define MRV_MIPI_SHUTDOWN_LANE_2            2	/* 0010: shutdown lane 1 */
#define MRV_MIPI_SHUTDOWN_LANE_3            4	/* 0100: shutdown lane 1 */
#define MRV_MIPI_SHUTDOWN_LANE_4            8	/* 1000: shutdown lane 1 */
#endif /* MRV_MIPI_SHUTDOWN_LANE */
/* Slice: FLUSH_FIFO:*/
/* writing '1' resets the write- and read pointers of the additional data fifo.*/
#ifdef MRV_MIPI_FLUSH_FIFO
#endif /* MRV_MIPI_FLUSH_FIFO */
/* Slice: OUTPUT_ENA:*/
/* 1: output to add data fifo and to output interface is enabled */
#ifdef MRV_MIPI_OUTPUT_ENA
#endif /* MRV_MIPI_OUTPUT_ENA */
/*****************************************************************************/
/**
 * register: mipi_status: global status register (0x0004)
 *
 *****************************************************************************/
/* Slice: S_ULP_ACTIVE_NOT_CLK:*/
/* sensor clock lane is in ULP state. This register is directly connected to the synchronized input signal "s_ulpsactivenotclk"*/
#ifdef MRV_MIPI_S_ULP_ACTIVE_NOT_CLK
#endif /* MRV_MIPI_S_ULP_ACTIVE_NOT_CLK */
/* Slice: S_STOPSTATE_CLK:*/
/* sensor clock lane is in stopstate. This register is directly connected to the synchronized input signal "s_stopstateclk"*/
#ifdef MRV_MIPI_S_STOPSTATE_CLK
#endif /* MRV_MIPI_S_STOPSTATE_CLK */
/* Slice: STOPSTATE:*/
/* Lane is in stopstate. This register is directly connected to the synchronized input signal stopstate[n-1:0]*/
#ifdef MRV_MIPI_STOPSTATE
#endif /* MRV_MIPI_STOPSTATE */
/* Slice: ADD_DATA_AVAIL:*/
/* 1: additional data fifo contains data */
/* 0: additional data fifo is empty */
#ifdef MRV_MIPI_ADD_DATA_AVAIL
#endif /* MRV_MIPI_ADD_DATA_AVAIL */
/*****************************************************************************/
/**
 * register: mipi_imsc: Interrupt mask (0x00000008)
 *
 *****************************************************************************/
/* Slice: IMSC_GEN_SHORT_PACK:*/
/* enable interrupt (1) or mask out (0)*/
#ifndef MRV_MIPI_IMSC_GEN_SHORT_PACK
#define MRV_MIPI_IMSC_GEN_SHORT_PACK_MASK           0
#endif /* MRV_MIPI_IMSC_GEN_SHORT_PACK */
/* Slice: IMSC_ADD_DATA_FILL_LEVEL:*/
/* enable interrupt (1) or mask out (0)*/
#ifndef MRV_MIPI_IMSC_ADD_DATA_FILL_LEVEL
#define MRV_MIPI_IMSC_ADD_DATA_FILL_LEVEL_MASK      0
#endif /* MRV_MIPI_IMSC_ADD_DATA_FILL_LEVEL */
/* Slice: IMSC_ADD_DATA_OVFLW:*/
/* enable interrupt (1) or mask out (0)*/
#ifndef MRV_MIPI_IMSC_ADD_DATA_OVFLW
#endif /* MRV_MIPI_IMSC_ADD_DATA_OVFLW */
/* Slice: IMSC_FRAME_END:*/
/* enable interrupt (1) or mask out (0)*/
#ifndef MRV_MIPI_IMSC_FRAME_END
#define MRV_MIPI_IMSC_FRAME_END_MASK                0
#endif /* MRV_MIPI_IMSC_ADD_DATA_OVFLW */
/* Slice: IMSC_ERR_CS:*/
/* enable interrupt (1) or mask out (0)*/
#ifndef MRV_MIPI_IMSC_ERR_CS
#define MRV_MIPI_IMSC_ERR_CS_MASK                   0
#endif /* MRV_MIPI_IMSC_ERR_CS */
/* Slice: IMSC_ERR_ECC1:*/
/* enable interrupt (1) or mask out (0)*/
#ifndef MRV_MIPI_IMSC_ERR_ECC1
#define MRV_MIPI_IMSC_ERR_ECC1_MASK                 0
#endif /* MRV_MIPI_IMSC_ERR_ECC1 */
/* Slice: IMSC_ERR_ECC2:*/
/* enable interrupt (1) or mask out (0)*/
#ifndef MRV_MIPI_IMSC_ERR_ECC2
#define MRV_MIPI_IMSC_ERR_ECC2_MASK                 0
#endif /* MRV_MIPI_IMSC_ERR_ECC2 */
/* Slice: IMSC_ERR_PROTOCOL:*/
/* enable interrupt (1) or mask out (0)*/
#ifndef MRV_MIPI_IMSC_ERR_PROTOCOL
#define MRV_MIPI_IMSC_ERR_PROTOCOL_MASK             0
#endif /* MRV_MIPI_IMSC_ERR_PROTOCOL */
/* Slice: IMSC_ERR_CONTROL:*/
/* enable interrupt (1) or mask out (0) (one bit for each lane)*/
#ifndef MRV_MIPI_IMSC_ERR_CONTROL
#define MRV_MIPI_IMSC_ERR_CONTROL_MASK              0
#endif /* MRV_MIPI_IMSC_ERR_CONTROL */
/* Slice: IMSC_ERR_EOT_SYNC:*/
/* enable interrupt (1) or mask out (0) (one bit for each lane)*/
#ifndef MRV_MIPI_IMSC_ERR_EOT_SYNC
#define MRV_MIPI_IMSC_ERR_EOT_SYNC_MASK             0
#endif /* MRV_MIPI_IMSC_ERR_EOT_SYNC */
/* Slice: IMSC_ERR_SOT_SYNC:*/
/* enable interrupt (1) or mask out (0) (one bit for each lane)*/
#ifndef MRV_MIPI_IMSC_ERR_SOT_SYNC
#define MRV_MIPI_IMSC_ERR_SOT_SYNC_MASK             0
#endif /* MRV_MIPI_IMSC_ERR_SOT_SYNC */
/* Slice: IMSC_ERR_SOT:*/
/* enable interrupt (1) or mask out (0) (one bit for each lane)*/
#ifndef MRV_MIPI_IMSC_ERR_SOT
#define MRV_MIPI_IMSC_ERR_SOT_MASK                  0
#endif /* MRV_MIPI_IMSC_ERR_SOT */
/* Slice: IMSC_SYNC_FIFO_OVFLW:*/
/* enable interrupt (1) or mask out (0) (one bit for each lane)*/
#ifndef MRV_MIPI_IMSC_SYNC_FIFO_OVFLW
#define MRV_MIPI_IMSC_SYNC_FIFO_OVFLW_MASK          0
#endif /* MRV_MIPI_IMSC_SYNC_FIFO_OVFLW */
/* combination of all interrupt lines */
#define MRV_MIPI_IMSC_ALL_IRQS
#define MRV_MIPI_IMSC_ALL_IRQS_MASK \
(MRV_MIPI_IMSC_ADD_DATA_FILL_LEVEL_MASK \
	| MRV_MIPI_IMSC_ADD_DATA_OVFLW_MASK \
	| MRV_MIPI_IMSC_FRAME_END_MASK \
	| MRV_MIPI_IMSC_ERR_CS_MASK \
	| MRV_MIPI_IMSC_ERR_ECC1_MASK \
	| MRV_MIPI_IMSC_ERR_ECC2_MASK \
	| MRV_MIPI_IMSC_ERR_PROTOCOL_MASK \
	| MRV_MIPI_IMSC_ERR_CONTROL_MASK \
	| MRV_MIPI_IMSC_ERR_EOT_SYNC_MASK \
	| MRV_MIPI_IMSC_ERR_SOT_SYNC_MASK \
	| MRV_MIPI_IMSC_ERR_SOT_MASK \
	| MRV_MIPI_IMSC_SYNC_FIFO_OVFLW_MASK \
)
#define MRV_MIPI_IMSC_ALL_IRQS_SHIFT                0
/*****************************************************************************/
/**
 * register: mipi_ris: Raw interrupt status (0x0000000c)
 *
 *****************************************************************************/
/* Slice: RIS_GEN_SHORT_PACK:*/
/* enable interrupt (1) or mask out (0)*/
#ifndef MRV_MIPI_RIS_GEN_SHORT_PACK
#define MRV_MIPI_RIS_GEN_SHORT_PACK_MASK            0
#endif /* MRV_MIPI_RIS_GEN_SHORT_PACK */
/* Slice: RIS_ADD_DATA_FILL_LEVEL:*/
/* enable interrupt (1) or mask out (0)*/
#ifndef MRV_MIPI_RIS_ADD_DATA_FILL_LEVEL
#define MRV_MIPI_RIS_ADD_DATA_FILL_LEVEL_MASK       0
#endif /* MRV_MIPI_RIS_ADD_DATA_FILL_LEVEL */
/* Slice: RIS_ADD_DATA_OVFLW:*/
/* enable interrupt (1) or mask out (0)*/
#ifndef MRV_MIPI_RIS_ADD_DATA_OVFLW
#endif /* MRV_MIPI_RIS_ADD_DATA_OVFLW */
/* Slice: RIS_FRAME_END:*/
/* enable interrupt (1) or mask out (0)*/
#ifndef MRV_MIPI_RIS_FRAME_END
#define MRV_MIPI_RIS_FRAME_END_MASK                 0
#endif /* MRV_MIPI_RIS_ADD_DATA_OVFLW */
/* Slice: RIS_ERR_CS:*/
/* enable interrupt (1) or mask out (0)*/
#ifndef MRV_MIPI_RIS_ERR_CS
#define MRV_MIPI_RIS_ERR_CS_MASK                    0
#endif /* MRV_MIPI_RIS_ERR_CS */
/* Slice: RIS_ERR_ECC1:*/
/* enable interrupt (1) or mask out (0)*/
#ifndef MRV_MIPI_RIS_ERR_ECC1
#define MRV_MIPI_RIS_ERR_ECC1_MASK                  0
#endif /* MRV_MIPI_RIS_ERR_ECC1 */
/* Slice: RIS_ERR_ECC2:*/
/* enable interrupt (1) or mask out (0)*/
#ifndef MRV_MIPI_RIS_ERR_ECC2
#define MRV_MIPI_RIS_ERR_ECC2_MASK                  0
#endif /* MRV_MIPI_RIS_ERR_ECC2 */
/* Slice: RIS_ERR_PROTOCOL:*/
/* enable interrupt (1) or mask out (0)*/
#ifndef MRV_MIPI_RIS_ERR_PROTOCOL
#define MRV_MIPI_RIS_ERR_PROTOCOL_MASK              0
#endif /* MRV_MIPI_RIS_ERR_PROTOCOL */
/* Slice: RIS_ERR_CONTROL:*/
/* enable interrupt (1) or mask out (0) (one bit for each lane)*/
#ifndef MRV_MIPI_RIS_ERR_CONTROL
#define MRV_MIPI_RIS_ERR_CONTROL_MASK               0
#endif /* MRV_MIPI_RIS_ERR_CONTROL */
/* Slice: RIS_ERR_EOT_SYNC:*/
/* enable interrupt (1) or mask out (0) (one bit for each lane)*/
#ifndef MRV_MIPI_RIS_ERR_EOT_SYNC
#define MRV_MIPI_RIS_ERR_EOT_SYNC_MASK              0
#endif /* MRV_MIPI_RIS_ERR_EOT_SYNC */
/* Slice: RIS_ERR_SOT_SYNC:*/
/* enable interrupt (1) or mask out (0) (one bit for each lane)*/
#ifndef MRV_MIPI_RIS_ERR_SOT_SYNC
#define MRV_MIPI_RIS_ERR_SOT_SYNC_MASK              0
#endif /* MRV_MIPI_RIS_ERR_SOT_SYNC */
/* Slice: RIS_ERR_SOT:*/
/* enable interrupt (1) or mask out (0) (one bit for each lane)*/
#ifndef MRV_MIPI_RIS_ERR_SOT
#define MRV_MIPI_RIS_ERR_SOT_MASK                   0
#endif /* MRV_MIPI_RIS_ERR_SOT */
/* Slice: RIS_SYNC_FIFO_OVFLW:*/
/* enable interrupt (1) or mask out (0) (one bit for each lane)*/
#ifndef MRV_MIPI_RIS_SYNC_FIFO_OVFLW
#define MRV_MIPI_RIS_SYNC_FIFO_OVFLW_MASK           0
#endif /* MRV_MIPI_RIS_SYNC_FIFO_OVFLW */
/* combination of all interrupt lines */
#define MRV_MIPI_RIS_ALL_IRQS
#define MRV_MIPI_RIS_ALL_IRQS_MASK \
(MRV_MIPI_RIS_ADD_DATA_FILL_LEVEL_MASK \
	| MRV_MIPI_RIS_ADD_DATA_OVFLW_MASK \
	| MRV_MIPI_RIS_FRAME_END_MASK \
	| MRV_MIPI_RIS_ERR_CS_MASK \
	| MRV_MIPI_RIS_ERR_ECC1_MASK \
	| MRV_MIPI_RIS_ERR_ECC2_MASK \
	| MRV_MIPI_RIS_ERR_PROTOCOL_MASK \
	| MRV_MIPI_RIS_ERR_CONTROL_MASK \
	| MRV_MIPI_RIS_ERR_EOT_SYNC_MASK \
	| MRV_MIPI_RIS_ERR_SOT_SYNC_MASK \
	| MRV_MIPI_RIS_ERR_SOT_MASK \
	| MRV_MIPI_RIS_SYNC_FIFO_OVFLW_MASK \
)
#define MRV_MIPI_RIS_ALL_IRQS_SHIFT                 0
/*****************************************************************************/
/**
 * register: mipi_mis: Masked interrupt status (0x00000010)
 *
 *****************************************************************************/
/* Slice: MIS_GEN_SHORT_PACK:*/
/* enable interrupt (1) or mask out (0)*/
#ifndef MRV_MIPI_MIS_GEN_SHORT_PACK
#define MRV_MIPI_MIS_GEN_SHORT_PACK_MASK            0
#endif /* MRV_MIPI_MIS_GEN_SHORT_PACK */
/* Slice: MIS_ADD_DATA_FILL_LEVEL:*/
/* enable interrupt (1) or mask out (0)*/
#ifndef MRV_MIPI_MIS_ADD_DATA_FILL_LEVEL
#define MRV_MIPI_MIS_ADD_DATA_FILL_LEVEL_MASK       0
#endif /* MRV_MIPI_MIS_ADD_DATA_FILL_LEVEL */
/* Slice: MIS_ADD_DATA_OVFLW:*/
/* enable interrupt (1) or mask out (0)*/
#ifndef MRV_MIPI_MIS_ADD_DATA_OVFLW
#endif /* MRV_MIPI_MIS_ADD_DATA_OVFLW */
/* Slice: MIS_FRAME_END:*/
/* enable interrupt (1) or mask out (0)*/
#ifndef MRV_MIPI_MIS_FRAME_END
#define MRV_MIPI_MIS_FRAME_END_MASK                 0
#endif /* MRV_MIPI_MIS_ADD_DATA_OVFLW */
/* Slice: MIS_ERR_CS:*/
/* enable interrupt (1) or mask out (0)*/
#ifndef MRV_MIPI_MIS_ERR_CS
#define MRV_MIPI_MIS_ERR_CS_MASK                    0
#endif /* MRV_MIPI_MIS_ERR_CS */
/* Slice: MIS_ERR_ECC1:*/
/* enable interrupt (1) or mask out (0)*/
#ifndef MRV_MIPI_MIS_ERR_ECC1
#define MRV_MIPI_MIS_ERR_ECC1_MASK                  0
#endif /* MRV_MIPI_MIS_ERR_ECC1 */
/* Slice: MIS_ERR_ECC2:*/
/* enable interrupt (1) or mask out (0)*/
#ifndef MRV_MIPI_MIS_ERR_ECC2
#define MRV_MIPI_MIS_ERR_ECC2_MASK                  0
#endif /* MRV_MIPI_MIS_ERR_ECC2 */
/* Slice: MIS_ERR_PROTOCOL:*/
/* enable interrupt (1) or mask out (0)*/
#ifndef MRV_MIPI_MIS_ERR_PROTOCOL
#define MRV_MIPI_MIS_ERR_PROTOCOL_MASK              0
#endif /* MRV_MIPI_MIS_ERR_PROTOCOL */
/* Slice: MIS_ERR_CONTROL:*/
/* enable interrupt (1) or mask out (0) (one bit for each lane)*/
#ifndef MRV_MIPI_MIS_ERR_CONTROL
#define MRV_MIPI_MIS_ERR_CONTROL_MASK               0
#endif /* MRV_MIPI_MIS_ERR_CONTROL */
/* Slice: MIS_ERR_EOT_SYNC:*/
/* enable interrupt (1) or mask out (0) (one bit for each lane)*/
#ifndef MRV_MIPI_MIS_ERR_EOT_SYNC
#define MRV_MIPI_MIS_ERR_EOT_SYNC_MASK              0
#endif /* MRV_MIPI_MIS_ERR_EOT_SYNC */
/* Slice: MIS_ERR_SOT_SYNC:*/
/* enable interrupt (1) or mask out (0) (one bit for each lane)*/
#ifndef MRV_MIPI_MIS_ERR_SOT_SYNC
#define MRV_MIPI_MIS_ERR_SOT_SYNC_MASK              0
#endif /* MRV_MIPI_MIS_ERR_SOT_SYNC */
/* Slice: MIS_ERR_SOT:*/
/* enable interrupt (1) or mask out (0) (one bit for each lane)*/
#ifndef MRV_MIPI_MIS_ERR_SOT
#define MRV_MIPI_MIS_ERR_SOT_MASK                   0
#endif /* MRV_MIPI_MIS_ERR_SOT */
/* Slice: MIS_SYNC_FIFO_OVFLW:*/
/* enable interrupt (1) or mask out (0) (one bit for each lane)*/
#ifndef MRV_MIPI_MIS_SYNC_FIFO_OVFLW
#define MRV_MIPI_MIS_SYNC_FIFO_OVFLW_MASK           0
#endif /* MRV_MIPI_MIS_SYNC_FIFO_OVFLW */
/* combination of all interrupt lines */
#define MRV_MIPI_MIS_ALL_IRQS
#define MRV_MIPI_MIS_ALL_IRQS_MASK \
(MRV_MIPI_MIS_ADD_DATA_FILL_LEVEL_MASK \
	| MRV_MIPI_MIS_ADD_DATA_OVFLW_MASK \
	| MRV_MIPI_MIS_FRAME_END_MASK \
	| MRV_MIPI_MIS_ERR_CS_MASK \
	| MRV_MIPI_MIS_ERR_ECC1_MASK \
	| MRV_MIPI_MIS_ERR_ECC2_MASK \
	| MRV_MIPI_MIS_ERR_PROTOCOL_MASK \
	| MRV_MIPI_MIS_ERR_CONTROL_MASK \
	| MRV_MIPI_MIS_ERR_EOT_SYNC_MASK \
	| MRV_MIPI_MIS_ERR_SOT_SYNC_MASK \
	| MRV_MIPI_MIS_ERR_SOT_MASK \
	| MRV_MIPI_MIS_SYNC_FIFO_OVFLW_MASK \
)
#define MRV_MIPI_MIS_ALL_IRQS_SHIFT                 0
/*****************************************************************************/
/**
 * register: mipi_icr: Interrupt clear register (0x00000014)
 *
 *****************************************************************************/
/* Slice: ICR_GEN_SHORT_PACK:*/
/* enable interrupt (1) or mask out (0)*/
#ifndef MRV_MIPI_ICR_GEN_SHORT_PACK
#define MRV_MIPI_ICR_GEN_SHORT_PACK_MASK            0
#endif /* MRV_MIPI_ICR_GEN_SHORT_PACK */
/* Slice: ICR_ADD_DATA_FILL_LEVEL:*/
/* enable interrupt (1) or mask out (0)*/
#ifndef MRV_MIPI_ICR_ADD_DATA_FILL_LEVEL
#define MRV_MIPI_ICR_ADD_DATA_FILL_LEVEL_MASK       0
#endif /* MRV_MIPI_ICR_ADD_DATA_FILL_LEVEL */
/* Slice: ICR_ADD_DATA_OVFLW:*/
/* enable interrupt (1) or mask out (0)*/
#ifndef MRV_MIPI_ICR_ADD_DATA_OVFLW
#endif /* MRV_MIPI_ICR_ADD_DATA_OVFLW */
/* Slice: ICR_FRAME_END:*/
/* enable interrupt (1) or mask out (0)*/
#ifndef MRV_MIPI_ICR_FRAME_END
#define MRV_MIPI_ICR_FRAME_END_MASK                 0
#endif /* MRV_MIPI_ICR_ADD_DATA_OVFLW */
/* Slice: ICR_ERR_CS:*/
/* enable interrupt (1) or mask out (0)*/
#ifndef MRV_MIPI_ICR_ERR_CS
#define MRV_MIPI_ICR_ERR_CS_MASK                    0
#endif /* MRV_MIPI_ICR_ERR_CS */
/* Slice: ICR_ERR_ECC1:*/
/* enable interrupt (1) or mask out (0)*/
#ifndef MRV_MIPI_ICR_ERR_ECC1
#define MRV_MIPI_ICR_ERR_ECC1_MASK                  0
#endif /* MRV_MIPI_ICR_ERR_ECC1 */
/* Slice: ICR_ERR_ECC2:*/
/* enable interrupt (1) or mask out (0)*/
#ifndef MRV_MIPI_ICR_ERR_ECC2
#define MRV_MIPI_ICR_ERR_ECC2_MASK                  0
#endif /* MRV_MIPI_ICR_ERR_ECC2 */
/* Slice: ICR_ERR_PROTOCOL:*/
/* enable interrupt (1) or mask out (0)*/
#ifndef MRV_MIPI_ICR_ERR_PROTOCOL
#define MRV_MIPI_ICR_ERR_PROTOCOL_MASK              0
#endif /* MRV_MIPI_ICR_ERR_PROTOCOL */
/* Slice: ICR_ERR_CONTROL:*/
/* enable interrupt (1) or mask out (0) (one bit for each lane)*/
#ifndef MRV_MIPI_ICR_ERR_CONTROL
#define MRV_MIPI_ICR_ERR_CONTROL_MASK               0
#endif /* MRV_MIPI_ICR_ERR_CONTROL */
/* Slice: ICR_ERR_EOT_SYNC:*/
/* enable interrupt (1) or mask out (0) (one bit for each lane)*/
#ifndef MRV_MIPI_ICR_ERR_EOT_SYNC
#define MRV_MIPI_ICR_ERR_EOT_SYNC_MASK              0
#endif /* MRV_MIPI_ICR_ERR_EOT_SYNC */
/* Slice: ICR_ERR_SOT_SYNC:*/
/* enable interrupt (1) or mask out (0) (one bit for each lane)*/
#ifndef MRV_MIPI_ICR_ERR_SOT_SYNC
#define MRV_MIPI_ICR_ERR_SOT_SYNC_MASK              0
#endif /* MRV_MIPI_ICR_ERR_SOT_SYNC */
/* Slice: ICR_ERR_SOT:*/
/* enable interrupt (1) or mask out (0) (one bit for each lane)*/
#ifndef MRV_MIPI_ICR_ERR_SOT
#define MRV_MIPI_ICR_ERR_SOT_MASK                   0
#endif /* MRV_MIPI_ICR_ERR_SOT */
/* Slice: ICR_SYNC_FIFO_OVFLW:*/
/* enable interrupt (1) or mask out (0) (one bit for each lane)*/
#ifndef MRV_MIPI_ICR_SYNC_FIFO_OVFLW
#define MRV_MIPI_ICR_SYNC_FIFO_OVFLW_MASK           0
#endif /* MRV_MIPI_ICR_SYNC_FIFO_OVFLW */
/* combination of all interrupt lines */
#define MRV_MIPI_ICR_ALL_IRQS
#define MRV_MIPI_ICR_ALL_IRQS_MASK \
(MRV_MIPI_ICR_ADD_DATA_FILL_LEVEL_MASK \
	| MRV_MIPI_ICR_ADD_DATA_OVFLW_MASK \
	| MRV_MIPI_ICR_FRAME_END_MASK \
	| MRV_MIPI_ICR_ERR_CS_MASK \
	| MRV_MIPI_ICR_ERR_ECC1_MASK \
	| MRV_MIPI_ICR_ERR_ECC2_MASK \
	| MRV_MIPI_ICR_ERR_PROTOCOL_MASK \
	| MRV_MIPI_ICR_ERR_CONTROL_MASK \
	| MRV_MIPI_ICR_ERR_EOT_SYNC_MASK \
	| MRV_MIPI_ICR_ERR_SOT_SYNC_MASK \
	| MRV_MIPI_ICR_ERR_SOT_MASK \
	| MRV_MIPI_ICR_SYNC_FIFO_OVFLW_MASK \
)
#define MRV_MIPI_ICR_ALL_IRQS_SHIFT                 0
/*****************************************************************************/
/**
 * register: mipi_isr: Interrupt set register (0x00000018)
 *
 *****************************************************************************/
/* Slice: ISR_GEN_SHORT_PACK:*/
/* enable interrupt (1) or mask out (0)*/
#ifndef MRV_MIPI_ISR_GEN_SHORT_PACK
#define MRV_MIPI_ISR_GEN_SHORT_PACK_MASK            0
#endif /* MRV_MIPI_ISR_GEN_SHORT_PACK */
/* Slice: ISR_ADD_DATA_FILL_LEVEL:*/
/* enable interrupt (1) or mask out (0)*/
#ifndef MRV_MIPI_ISR_ADD_DATA_FILL_LEVEL
#define MRV_MIPI_ISR_ADD_DATA_FILL_LEVEL_MASK       0
#endif /* MRV_MIPI_ISR_ADD_DATA_FILL_LEVEL */
/* Slice: ISR_ADD_DATA_OVFLW:*/
/* enable interrupt (1) or mask out (0)*/
#ifndef MRV_MIPI_ISR_ADD_DATA_OVFLW
#endif /* MRV_MIPI_ISR_ADD_DATA_OVFLW */
/* Slice: ISR_FRAME_END:*/
/* enable interrupt (1) or mask out (0)*/
#ifndef MRV_MIPI_ISR_FRAME_END
#define MRV_MIPI_ISR_FRAME_END_MASK                 0
#endif /* MRV_MIPI_ISR_ADD_DATA_OVFLW */
/* Slice: ISR_ERR_CS:*/
/* enable interrupt (1) or mask out (0)*/
#ifndef MRV_MIPI_ISR_ERR_CS
#define MRV_MIPI_ISR_ERR_CS_MASK                    0
#endif /* MRV_MIPI_ISR_ERR_CS */
/* Slice: ISR_ERR_ECC1:*/
/* enable interrupt (1) or mask out (0)*/
#ifndef MRV_MIPI_ISR_ERR_ECC1
#define MRV_MIPI_ISR_ERR_ECC1_MASK                  0
#endif /* MRV_MIPI_ISR_ERR_ECC1 */
/* Slice: ISR_ERR_ECC2:*/
/* enable interrupt (1) or mask out (0)*/
#ifndef MRV_MIPI_ISR_ERR_ECC2
#define MRV_MIPI_ISR_ERR_ECC2_MASK                  0
#endif /* MRV_MIPI_ISR_ERR_ECC2 */
/* Slice: ISR_ERR_PROTOCOL:*/
/* enable interrupt (1) or mask out (0)*/
#ifndef MRV_MIPI_ISR_ERR_PROTOCOL
#define MRV_MIPI_ISR_ERR_PROTOCOL_MASK              0
#endif /* MRV_MIPI_ISR_ERR_PROTOCOL */
/* Slice: ISR_ERR_CONTROL:*/
/* enable interrupt (1) or mask out (0) (one bit for each lane)*/
#ifndef MRV_MIPI_ISR_ERR_CONTROL
#define MRV_MIPI_ISR_ERR_CONTROL_MASK               0
#endif /* MRV_MIPI_ISR_ERR_CONTROL */
/* Slice: ISR_ERR_EOT_SYNC:*/
/* enable interrupt (1) or mask out (0) (one bit for each lane)*/
#ifndef MRV_MIPI_ISR_ERR_EOT_SYNC
#define MRV_MIPI_ISR_ERR_EOT_SYNC_MASK              0
#endif /* MRV_MIPI_ISR_ERR_EOT_SYNC */
/* Slice: ISR_ERR_SOT_SYNC:*/
/* enable interrupt (1) or mask out (0) (one bit for each lane)*/
#ifndef MRV_MIPI_ISR_ERR_SOT_SYNC
#define MRV_MIPI_ISR_ERR_SOT_SYNC_MASK              0
#endif /* MRV_MIPI_ISR_ERR_SOT_SYNC */
/* Slice: ISR_ERR_SOT:*/
/* enable interrupt (1) or mask out (0) (one bit for each lane)*/
#ifndef MRV_MIPI_ISR_ERR_SOT
#define MRV_MIPI_ISR_ERR_SOT_MASK                   0
#endif /* MRV_MIPI_ISR_ERR_SOT */
/* Slice: ISR_SYNC_FIFO_OVFLW:*/
/* enable interrupt (1) or mask out (0) (one bit for each lane)*/
#ifndef MRV_MIPI_ISR_SYNC_FIFO_OVFLW
#define MRV_MIPI_ISR_SYNC_FIFO_OVFLW_MASK           0
#endif /* MRV_MIPI_ISR_SYNC_FIFO_OVFLW */
/* combination of all interrupt lines */
#define MRV_MIPI_ISR_ALL_IRQS
#define MRV_MIPI_ISR_ALL_IRQS_MASK \
(MRV_MIPI_ISR_ADD_DATA_FILL_LEVEL_MASK \
	| MRV_MIPI_ISR_ADD_DATA_OVFLW_MASK \
	| MRV_MIPI_ISR_FRAME_END_MASK \
	| MRV_MIPI_ISR_ERR_CS_MASK \
	| MRV_MIPI_ISR_ERR_ECC1_MASK \
	| MRV_MIPI_ISR_ERR_ECC2_MASK \
	| MRV_MIPI_ISR_ERR_PROTOCOL_MASK \
	| MRV_MIPI_ISR_ERR_CONTROL_MASK \
	| MRV_MIPI_ISR_ERR_EOT_SYNC_MASK \
	| MRV_MIPI_ISR_ERR_SOT_SYNC_MASK \
	| MRV_MIPI_ISR_ERR_SOT_MASK \
	| MRV_MIPI_ISR_SYNC_FIFO_OVFLW_MASK \
)
#define MRV_MIPI_ISR_ALL_IRQS_SHIFT                 0
/*****************************************************************************/
/**
 * register: mipi_cur_data_id: Current Data Identifier (0x0000001c)
 *
 *****************************************************************************/
/* Slice: VIRTUAL_CHANNEL:*/
/* virtual channel of currently received packet */
#ifdef MRV_MIPI_VIRTUAL_CHANNEL
#endif /* MRV_MIPI_VIRTUAL_CHANNEL */
/* Slice: DATA_TYPE:*/
/* data type of currently received packet */
#ifdef MRV_MIPI_DATA_TYPE
#endif /* MRV_MIPI_DATA_TYPE */
/*****************************************************************************/
/**
 * register: mipi_img_data_sel: Image Data Selector (0x00000020)
 *
 *****************************************************************************/
/* Slice: VIRTUAL_CHANNEL_SEL:*/
/* virtual channel selector for image data output */
#ifdef MRV_MIPI_VIRTUAL_CHANNEL_SEL
#endif /* MRV_MIPI_VIRTUAL_CHANNEL_SEL */
/* Slice: DATA_TYPE_SEL:*/
/* data type selector for image data output:*/
/* 0x08...0x0F: generic short packets */
/* 0x12: embedded 8-bit data */
/* 0x18: YUV 420 8-bit */
/* 0x19: YUV 420 10-bit */
/* 0x1A: Legacy YUV 420 8-bit */
/* 0x1C: YUV 420 8-bit (CSPS)*/
/* 0x1D: YUV 420 10-bit (CSPS)*/
/* 0x1E: YUV 422 8-bit */
/* 0x1F: YUV 422 10-bit */
/* 0x20: RGB 444 */
/* 0x21: RGB 555 */
/* 0x22: RGB 565 */
/* 0x23: RGB 666 */
/* 0x24: RGB 888 */
/* 0x28: RAW 6 */
/* 0x29: RAW 7 */
/* 0x2A: RAW 8 */
/* 0x2B: RAW 10 */
/* 0x2C: RAW 12 */
/* 0x30...0x37: User Defined Byte-based data */
#ifdef MRV_MIPI_DATA_TYPE_SEL
#define MRV_MIPI_DATA_TYPE_SEL_YUV420_8BIT          24	/* 0x18    YUV 420 8-bit */
#define MRV_MIPI_DATA_TYPE_SEL_YUV420_10BIT         25	/* 0x19    YUV 420 10-bit */
#define MRV_MIPI_DATA_TYPE_SEL_YUV420_8BIT_LEGACY   26	/* 0x1A    Legacy YUV 420 8-bit */
#define MRV_MIPI_DATA_TYPE_SEL_YUV420_8BIT_CSPS     28	/* 0x1C    YUV 420 8-bit (CSPS) */
#define MRV_MIPI_DATA_TYPE_SEL_YUV420_10BIT_CSPS    29	/* 0x1D    YUV 420 10-bit (CSPS) */
#define MRV_MIPI_DATA_TYPE_SEL_YUV422_8BIT          30	/* 0x1E    YUV 422 8-bit */
#define MRV_MIPI_DATA_TYPE_SEL_YUV422_10BIT         31	/* 0x1F    YUV 422 10-bit */
#define MRV_MIPI_DATA_TYPE_SEL_RGB444               32	/* 0x20    RGB 444 */
#define MRV_MIPI_DATA_TYPE_SEL_RGB555               33	/* 0x21    RGB 555 */
#define MRV_MIPI_DATA_TYPE_SEL_RGB565               34	/* 0x22    RGB 565 */
#define MRV_MIPI_DATA_TYPE_SEL_RGB666               35	/* 0x23    RGB 666 */
#define MRV_MIPI_DATA_TYPE_SEL_RGB888               36	/* 0x24    RGB 888 */
#define MRV_MIPI_DATA_TYPE_SEL_RAW6                 40	/* 0x28    RAW 6 */
#define MRV_MIPI_DATA_TYPE_SEL_RAW7                 41	/* 0x29    RAW 7 */
#define MRV_MIPI_DATA_TYPE_SEL_RAW8                 42	/* 0x2A    RAW 8 */
#define MRV_MIPI_DATA_TYPE_SEL_RAW10                43	/* 0x2B    RAW 10 */
#define MRV_MIPI_DATA_TYPE_SEL_RAW12                44	/* 0x2C    RAW 12 */
#define MRV_MIPI_DATA_TYPE_SEL_USER1                48	/* 0x30...0x37 User Defined Byte-based data */
#define MRV_MIPI_DATA_TYPE_SEL_USER2                49	/* 0x30...0x37 User Defined Byte-based data */
#define MRV_MIPI_DATA_TYPE_SEL_USER3                50	/* 0x30...0x37 User Defined Byte-based data */
#define MRV_MIPI_DATA_TYPE_SEL_USER4                51	/* 0x30...0x37 User Defined Byte-based data */
#define MRV_MIPI_DATA_TYPE_SEL_USER5                52	/* 0x30...0x37 User Defined Byte-based data */
#define MRV_MIPI_DATA_TYPE_SEL_USER6                53	/* 0x30...0x37 User Defined Byte-based data */
#define MRV_MIPI_DATA_TYPE_SEL_USER7                54	/* 0x30...0x37 User Defined Byte-based data */
#define MRV_MIPI_DATA_TYPE_SEL_USER8                55	/* 0x30...0x37 User Defined Byte-based data */
#endif /* MRV_MIPI_DATA_TYPE_SEL */
/*****************************************************************************/
/**
 * register: mipi_add_data_sel_1: Additional Data Selector 1 (0x00000024)
 *
 *****************************************************************************/
/* Slice: ADD_DATA_VC_1:*/
/* virtual channel selector for additional data output */
#ifdef MRV_MIPI_ADD_DATA_VC_1
#endif /* MRV_MIPI_ADD_DATA_VC_1 */
/* Slice: ADD_DATA_TYPE_1:*/
/* data type selector for additional data output */
#ifdef MRV_MIPI_ADD_DATA_TYPE_1
#endif /* MRV_MIPI_ADD_DATA_TYPE_1 */
/*****************************************************************************/
/**
 * register: mipi_add_data_sel_2: Additional Data Selector 2 (0x00000028)
 *
 *****************************************************************************/
/* Slice: ADD_DATA_VC_2:*/
/* virtual channel selector for additional data output */
#ifdef MRV_MIPI_ADD_DATA_VC_2
#endif /* MRV_MIPI_ADD_DATA_VC_2 */
/* Slice: ADD_DATA_TYPE_2:*/
/* data type selector for additional data output */
#ifdef MRV_MIPI_ADD_DATA_TYPE_2
#endif /* MRV_MIPI_ADD_DATA_TYPE_2 */
/*****************************************************************************/
/**
 * register: mipi_add_data_sel_3: Additional Data Selector 3 (0x0000002c)
 *
 *****************************************************************************/
/* Slice: ADD_DATA_VC_3:*/
/* virtual channel selector for additional data output */
#ifdef MRV_MIPI_ADD_DATA_VC_3
#endif /* MRV_MIPI_ADD_DATA_VC_3 */
/* Slice: ADD_DATA_TYPE_3:*/
/* data type selector for additional data output */
#ifdef MRV_MIPI_ADD_DATA_TYPE_3
#endif /* MRV_MIPI_ADD_DATA_TYPE_3 */
/*****************************************************************************/
/**
 * register: mipi_add_data_sel_4: Additional Data Selector 4 (0x00000030)
 *
 *****************************************************************************/
/* Slice: ADD_DATA_VC_4:*/
/* virtual channel selector for additional data output */
#ifdef MRV_MIPI_ADD_DATA_VC_4
#endif /* MRV_MIPI_ADD_DATA_VC_4 */
/* Slice: ADD_DATA_TYPE_4:*/
/* data type selector for additional data output */
#ifdef MRV_MIPI_ADD_DATA_TYPE_4
#endif /* MRV_MIPI_ADD_DATA_TYPE_4 */
/*****************************************************************************/
/**
 * register: mipi_add_data_fifo: Additional Data Fifo (0x00000034)
 *
 *****************************************************************************/
/* Slice: ADD_DATA_FIFO:*/
/* lowest 4 bytes in additional data fifo;*/
/* reading increments fifo read pointer.*/
/* First embedded data byte will be written to bits 7:0 of 32-bit data word, second data byte written to 15:8 etc.*/
#ifdef MRV_MIPI_ADD_DATA_FIFO
#endif /* MRV_MIPI_ADD_DATA_FIFO */
/*****************************************************************************/
/**
 * register: mipi_add_data_fill_level: additional data fifo fill level
 *           (0x00000038)
 *
 *****************************************************************************/
/* Slice: ADD_DATA_FILL_LEVEL:*/
/* FIFO level in dwords for triggering the FILL_LEVEL interrupt,*/
/* must be 32-bit aligned (bit 0 and bit 1 are hard wired to "00")*/
#ifdef MRV_MIPI_ADD_DATA_FILL_LEVEL
#endif /* MRV_MIPI_ADD_DATA_FILL_LEVEL */
/*****************************************************************************/
/**
 * register: mipi_compressed_mode: controls processing of compressed raw data
 *           types (0x0000003c)
 *
 *****************************************************************************/
/* Slice: predictor_sel:*/
/* predictor to be used:*/
/* 0: predictor 1 */
/* 1: predictor 2 */
#ifdef MRV_MIPI_PREDICTOR_SEL
#define MRV_MIPI_PREDICTOR_SEL_1            0	/* 0: predictor 1 */
#define MRV_MIPI_PREDICTOR_SEL_2            1	/* 1: predictor 2 */
#endif /* MRV_MIPI_PREDICTOR_SEL */
/* Slice: MRV_MIPI_COMP_SCHEME:*/
/* Compressed raw data types */
/* 000: 12-8-12 */
/* 001: 12-8-12 */
/* 010: 12-8-12 */
/* 011: 10-8-10 */
/* 100: 10-7-10 */
/* 101: 10-6-10 */
#ifdef MRV_MIPI_COMP_SCHEME
#define MRV_MIPI_COMP_SCHEME_12_8_12        0	/* 000: 12-8-12 */
#define MRV_MIPI_COMP_SCHEME_12_7_12        1	/* 001: 12-8-12 */
#define MRV_MIPI_COMP_SCHEME_12_6_12        2	/* 010: 12-8-12 */
#define MRV_MIPI_COMP_SCHEME_10_8_10        3	/* 011: 10-8-10 */
#define MRV_MIPI_COMP_SCHEME_10_7_10        4	/* 100: 10-7-10 */
#define MRV_MIPI_COMP_SCHEME_10_6_10        5	/* 101: 10-6-10 */
#endif /* MRV_MIPI_COMP_SCHEME */
/* Slice: compress_en:*/
/* 1: enable compressed mode processing */
/* 0: disable compressed mode */
#ifdef MRV_MIPI_COMPRESS_EN
#endif /* MRV_MIPI_COMPRESS_EN */
/*****************************************************************************/
/* ISP  Image Stabilization Registers                                        */
/*****************************************************************************/
/*****************************************************************************/
/**
 * register: isp_is_ctrl: Image Stabilization Control Register (0x00000000)
 *
 *****************************************************************************/
/* Slice: is_en:*/
/* 1: image stabilization switched on */
/* 0: image stabilization switched off */
#ifdef MRV_IS_IS_EN
#define MRV_IS_IS_EN_PROCESS                    1
#define MRV_IS_IS_EN_BYPASS                     0
#endif /* MRV_IS_IS_EN */
/*****************************************************************************/
/**
 * register: isp_is_recenter: Recenter register (0x00000004)
 *
 *****************************************************************************/
/* Slice: is_recenter:*/
/*  000: recenter feature switched off */
/* 1..7: recentering by (cur_h/v_offs-H/V_OFFS)/2^RECENTER */
#ifdef MRV_IS_IS_RECENTER
#define MRV_IS_IS_RECENTER_MAX                  (MRV_IS_IS_RECENTER_MASK >> MRV_IS_IS_RECENTER_SHIFT)
#endif /* MRV_IS_IS_RECENTER */
/*****************************************************************************/
/**
 * register: isp_is_h_offs: Horizontal offset of output window (0x00000008)
 *
 *****************************************************************************/
/* Slice: is_h_offs:*/
/* horizontal picture offset in pixel */
#ifdef MRV_IS_IS_H_OFFS
#define MRV_IS_IS_H_OFFS_MAX  (MRV_IS_IS_H_OFFS_MASK >> MRV_IS_IS_H_OFFS_SHIFT)
#endif /* MRV_IS_IS_H_OFFS */
/*****************************************************************************/
/**
 * register: isp_is_v_offs: Vertical offset of output window (0x0000000c)
 *
 *****************************************************************************/
/* Slice: is_v_offs:*/
/* vertical picture offset in lines */
#ifdef MRV_IS_IS_V_OFFS
#define MRV_IS_IS_V_OFFS_MAX  (MRV_IS_IS_V_OFFS_MASK >> MRV_IS_IS_V_OFFS_SHIFT)
#endif /* MRV_IS_IS_V_OFFS */
/*****************************************************************************/
/**
 * register: isp_is_h_size: Output horizontal picture size (0x00000010)
 *
 *****************************************************************************/
/* Slice: is_h_size:*/
/* horizontal picture size in pixel */
/* if ISP_MODE is set to */
/* 001-(ITU-R BT.656 YUV),*/
/* 010-(ITU-R BT.601 YUV),*/
/* 011-(ITU-R BT.601 Bayer RGB),*/
/* 101-(ITU-R BT.656 Bayer RGB)*/
/* only even numbers are accepted, because complete quadruples of YUYV(YCbYCr)*/
/* are needed for the following modules. If an odd size is programmed the value */
/* will be truncated to even size.*/
#ifdef MRV_IS_IS_H_SIZE
#define MRV_IS_IS_H_SIZE_MAX  (MRV_IS_IS_H_SIZE_MASK >> MRV_IS_IS_H_SIZE_SHIFT)
#endif /* MRV_IS_IS_H_SIZE */
/*****************************************************************************/
/**
 * register: isp_is_v_size: Output vertical picture size (0x00000014)
 *
 *****************************************************************************/
/* Slice: is_v_size:*/
/* vertical picture size in lines */
#ifdef MRV_IS_IS_V_SIZE
#define MRV_IS_IS_V_SIZE_MAX  (MRV_IS_IS_V_SIZE_MASK >> MRV_IS_IS_V_SIZE_SHIFT)
#endif /* MRV_IS_IS_V_SIZE */
/*****************************************************************************/
/**
 * register: isp_is_max_dx: Maximum Horizontal Displacement (0x00000018)
 *
 *****************************************************************************/
/* Slice: is_max_dx:*/
/* maximum allowed accumulated horizontal displacement in pixels */
#ifdef MRV_IS_IS_MAX_DX
#define MRV_IS_IS_MAX_DX_MAX                    (MRV_IS_IS_MAX_DX_MASK >> MRV_IS_IS_MAX_DX_SHIFT)
#endif /* MRV_IS_IS_MAX_DX */
/*****************************************************************************/
/**
 * register: isp_is_max_dy: Maximum Vertical Displacement (0x0000001c)
 *
 *****************************************************************************/
/* Slice: is_max_dy:*/
/* maximum allowed accumulated vertical displacement in lines */
#ifdef MRV_IS_IS_MAX_DY
#define MRV_IS_IS_MAX_DY_MAX                    (MRV_IS_IS_MAX_DY_MASK >> MRV_IS_IS_MAX_DY_SHIFT)
#endif /* MRV_IS_IS_MAX_DY */
/*****************************************************************************/
/**
 * register: isp_is_displace: Camera displacement (0x00000020)
 *
 *****************************************************************************/
/* Slice: dy:*/
/* ISP_IS will compensate for vertical camera displacement of DY lines in the next frame */
#ifdef MRV_IS_DY
#define MRV_IS_DY_MAX                           0x000007FF
#define MRV_IS_DY_MIN                           (~MRV_IS_DY_MAX)
#endif /* MRV_IS_DY */
/* Slice: dx:*/
/* ISP_IS will compensate for horizontal camera displacement of DX pixels in the next frame */
#ifdef MRV_IS_DX
#define MRV_IS_DX_MAX                           0x000007FF
#define MRV_IS_DX_MIN                           (~MRV_IS_DX_MAX)
#endif /* MRV_IS_DX */
/*****************************************************************************/
/**
 * register: isp_is_h_offs_shd: current horizontal offset of output window
 *           (shadow register) (0x00000024)
 *
 *****************************************************************************/
/* Slice: is_h_offs_shd:*/
/* current horizonatl picture offset in lines */
#ifdef MRV_IS_IS_H_OFFS_SHD
#endif /* MRV_IS_IS_H_OFFS_SHD */
/*****************************************************************************/
/**
 * register: isp_is_v_offs_shd: current vertical offset of output window
 *           (shadow register) (0x00000028)
 *
 *****************************************************************************/
/* Slice: is_v_offs_shd:*/
/* current vertical picture offset in lines */
#ifdef MRV_IS_IS_V_OFFS_SHD
#endif /* MRV_IS_IS_V_OFFS_SHD */
/*****************************************************************************/
/**
 * register: isp_is_h_size_shd: current output horizontal picture size
 *           (shadow register) (0x0000002c)
 *
 *****************************************************************************/
/* Slice: isp_h_size_shd:*/
/* current horizontal picture size in pixel */
#ifdef MRV_IS_ISP_H_SIZE_SHD
#endif /* MRV_IS_ISP_H_SIZE_SHD */
/*****************************************************************************/
/**
 * register: isp_is_v_size_shd: current output vertical picture size
 *           (shadow register) (0x00000030)
 *
 *****************************************************************************/
/* Slice: isp_v_size_shd:*/
/* vertical picture size in lines */
#ifdef MRV_IS_ISP_V_SIZE_SHD
#endif /* MRV_IS_ISP_V_SIZE_SHD */
/*****************************************************************************/
/* ISP Histogram Module Registers                                            */
/*****************************************************************************/
/*****************************************************************************/
/**
 * register: isp_hist_prop: Histogram properties (0x00000000)
 *
 *****************************************************************************/
/* Slice: stepsize:*/
/* histogram predivider, process every (stepsize)th pixel, all other pixels are skipped */
/* 0,1,2: not allowed */
/* 3: process every third input pixel */
/* 4: process every fourth input pixel */
/* ...*/
/* 7FH: process every 127th pixel */
#ifdef MRV_HIST_STEPSIZE
#define MRV_HIST_STEPSIZE_MIN                   0x00000003
#define MRV_HIST_STEPSIZE_MAX                   0x0000007F
#endif /* MRV_HIST_STEPSIZE */
/* Slice: hist_mode:*/
/* histogram mode, luminance is taken at ISP output before output formatter,*/
/* RGB is taken at xtalk output */
     /**/
/* 7, 6: must not be used */
/* 5: Y (luminance) histogram */
/* 4: B histogram */
/* 3: G histogram */
/* 2: R histogram */
/* 1: RGB combined histogram */
/* 0: disable, no measurements */
#ifdef MRV_HIST_MODE
#define MRV_HIST_MODE_MAX                  5	/* because 6 and 7 are reserved */
#define MRV_HIST_MODE_LUM                  5	/* 5: Y (luminance) histogram */
#define MRV_HIST_MODE_B                    4	/* 4: B histogram */
#define MRV_HIST_MODE_G                    3	/* 3: G histogram */
#define MRV_HIST_MODE_R                    2	/* 2: R histogram */
#define MRV_HIST_MODE_RGB                  1	/* 1: RGB combined histogram */
#define MRV_HIST_MODE_NONE                 0	/* 0: disable, no measurements */
#endif /* MRV_HIST_MODE */
/*****************************************************************************/
/**
 * register: isp_hist_h_offs: Histogram window horizontal offset for first
 *           window of 25 sub-windows (0x00000004)
 *
 *****************************************************************************/
/* Slice: hist_h_offset:*/
/* Horizontal offset of first window in pixels.*/
#ifdef MRV_HIST_H_OFFSET
#endif /* MRV_HIST_H_OFFSET */
/*****************************************************************************/
/**
 * register: isp_hist_v_offs: Histogram window vertical offset for first
 *           window of 25 sub-windows (0x00000008)
 *
 *****************************************************************************/
/* Slice: hist_v_offset:*/
/* Vertical offset of first window in pixels.*/
#ifdef MRV_HIST_V_OFFSET
#endif /* MRV_HIST_V_OFFSET */
/*****************************************************************************/
/**
 * register: isp_hist_h_size: Horizontal (sub-)window size (0x0000000c)
 *
 *****************************************************************************/
/* Slice: hist_h_size:*/
/* Horizontal size in pixels of one sub-window, if histogram version 3 is implemented.*/
#ifdef MRV_HIST_H_SIZE
#endif /* MRV_HIST_H_SIZE */
/*****************************************************************************/
/**
 * register: isp_hist_v_size: Vertical (sub-)window size (0x00000010)
 *
 *****************************************************************************/
/* Slice: hist_v_size:*/
/* Vertical size in lines of one sub-window, if histogram version 3 is implemented.*/
#ifdef MRV_HIST_V_SIZE
#endif /* MRV_HIST_V_SIZE */
/*****************************************************************************/
/**
 * register array: isp_hist_bin: histogram measurement result bin
 *                 (0x028 + n*0x4 (n=0..15))
 *
 *****************************************************************************/
/* Slice: hist_bin_n:*/
/* measured bin count as 16-bit unsigned integer value plus 4 bit fractional part */
#ifdef MRV_HIST_BIN_N
#define MRV_HIST_BIN_N_MAX                 (MRV_HIST_BIN_N_MASK >> MRV_HIST_BIN_N_SHIFT)
#endif /* MRV_HIST_BIN_N */
/*****************************************************************************/
/**
 * register: isp_hist_weight_00to30: Weighting factor for sub-windows
 *           (0x00000054)
 *
 *****************************************************************************/
/* Slice: hist_weight_30:*/
/* weighting factor for sub-window 30 */
#ifdef MRV_HIST_WEIGHT_30
#endif /* MRV_HIST_WEIGHT_30 */
/* Slice: hist_weight_20:*/
/* weighting factor for sub-window 20 */
#ifdef MRV_HIST_WEIGHT_20
#endif /* MRV_HIST_WEIGHT_20 */
/* Slice: hist_weight_10:*/
/* weighting factor for sub-window 10 */
#ifdef MRV_HIST_WEIGHT_10
#endif /* MRV_HIST_WEIGHT_10 */
/* Slice: hist_weight_00:*/
/* weighting factor for sub-window 00 */
#ifdef MRV_HIST_WEIGHT_00
#endif /* MRV_HIST_WEIGHT_00 */
/*****************************************************************************/
/**
 * register: isp_hist_weight_40to21: Weighting factor for sub-windows
 *           (0x00000058)
 *
 *****************************************************************************/
/* Slice: hist_weight_21:*/
/* weighting factor for sub-window 21 */
#ifdef MRV_HIST_WEIGHT_21
#endif /* MRV_HIST_WEIGHT_21 */
/* Slice: hist_weight_11:*/
/* weighting factor for sub-window 11 */
#ifdef MRV_HIST_WEIGHT_11
#endif /* MRV_HIST_WEIGHT_11 */
/* Slice: hist_weight_01:*/
/* weighting factor for sub-window 01 */
#ifdef MRV_HIST_WEIGHT_01
#endif /* MRV_HIST_WEIGHT_01 */
/* Slice: hist_weight_40:*/
/* weighting factor for sub-window 40 */
#ifdef MRV_HIST_WEIGHT_40
#endif /* MRV_HIST_WEIGHT_40 */
/*****************************************************************************/
/**
 * register: isp_hist_weight_31to12: Weighting factor for sub-windows
 *           (0x0000005c)
 *
 *****************************************************************************/
/* Slice: hist_weight_12:*/
/* weighting factor for sub-window 12 */
#ifdef MRV_HIST_WEIGHT_12
#endif /* MRV_HIST_WEIGHT_12 */
/* Slice: hist_weight_02:*/
/* weighting factor for sub-window 02 */
#ifdef MRV_HIST_WEIGHT_02
#endif /* MRV_HIST_WEIGHT_02 */
/* Slice: hist_weight_41:*/
/* weighting factor for sub-window 41 */
#ifdef MRV_HIST_WEIGHT_41
#endif /* MRV_HIST_WEIGHT_41 */
/* Slice: hist_weight_31:*/
/* weighting factor for sub-window 31 */
#ifdef MRV_HIST_WEIGHT_31
#endif /* MRV_HIST_WEIGHT_31 */
/*****************************************************************************/
/**
 * register: isp_hist_weight_22to03: Weighting factor for sub-windows
 *           (0x00000060)
 *
 *****************************************************************************/
/* Slice: hist_weight_03:*/
/* weighting factor for sub-window 03 */
#ifdef MRV_HIST_WEIGHT_03
#endif /* MRV_HIST_WEIGHT_03 */
/* Slice: hist_weight_42:*/
/* weighting factor for sub-window 42 */
#ifdef MRV_HIST_WEIGHT_42
#endif /* MRV_HIST_WEIGHT_42 */
/* Slice: hist_weight_32:*/
/* weighting factor for sub-window 32 */
#ifdef MRV_HIST_WEIGHT_32
#endif /* MRV_HIST_WEIGHT_32 */
/* Slice: hist_weight_22:*/
/* weighting factor for sub-window 22 */
#ifdef MRV_HIST_WEIGHT_22
#endif /* MRV_HIST_WEIGHT_22 */
/*****************************************************************************/
/**
 * register: isp_hist_weight_13to43: Weighting factor for sub-windows
 *           (0x00000064)
 *
 *****************************************************************************/
/* Slice: hist_weight_43:*/
/* weighting factor for sub-window 43 */
#ifdef MRV_HIST_WEIGHT_43
#endif /* MRV_HIST_WEIGHT_43 */
/* Slice: hist_weight_33:*/
/* weighting factor for sub-window 33 */
#ifdef MRV_HIST_WEIGHT_33
#endif /* MRV_HIST_WEIGHT_33 */
/* Slice: hist_weight_23:*/
/* weighting factor for sub-window 23 */
#ifdef MRV_HIST_WEIGHT_23
#endif /* MRV_HIST_WEIGHT_23 */
/* Slice: hist_weight_13:*/
/* weighting factor for sub-window 13 */
#ifdef MRV_HIST_WEIGHT_13
#endif /* MRV_HIST_WEIGHT_13 */
/*****************************************************************************/
/**
 * register: isp_hist_weight_04to34: Weighting factor for sub-windows
 *           (0x00000068)
 *
 *****************************************************************************/
/* Slice: hist_weight_34:*/
/* weighting factor for sub-window 34 */
#ifdef MRV_HIST_WEIGHT_34
#endif /* MRV_HIST_WEIGHT_34 */
/* Slice: hist_weight_24:*/
/* weighting factor for sub-window 24 */
#ifdef MRV_HIST_WEIGHT_24
#endif /* MRV_HIST_WEIGHT_24 */
/* Slice: hist_weight_14:*/
/* weighting factor for sub-window 14 */
#ifdef MRV_HIST_WEIGHT_14
#endif /* MRV_HIST_WEIGHT_14 */
/* Slice: hist_weight_04:*/
/* weighting factor for sub-window 04 */
#ifdef MRV_HIST_WEIGHT_04
#endif /* MRV_HIST_WEIGHT_04 */
/*****************************************************************************/
/**
 * register: isp_hist_weight_44: Weighting factor for sub-windows (0x0000006c)
 *
 *****************************************************************************/
/* Slice: hist_weight_44:*/
/* weighting factor for sub-window 44 */
#ifdef MRV_HIST_WEIGHT_44
#endif /* MRV_HIST_WEIGHT_44 */
#define MRV_HIST_WEIGHT_MAX                     0x10
/*****************************************************************************/
/* ISP Filter Module Registers                                               */
/*****************************************************************************/
/*****************************************************************************/
/**
 * register: isp_filt_mode: mode control register for the filter block
 *           (0x00000000)
 *
 *****************************************************************************/
/* Slice: stage1_select:*/
/* Green filter stage 1 select (range 0x0...0x8)*/
/* 0x0 maximum blurring */
/* 0x4 Default */
/* 0x7 minimum blurring */
/* 0x8 filter stage1 bypass */
/* For a detailed description refer to chapter "ISP Filter Programming" of user manual */
#ifdef MRV_FILT_STAGE1_SELECT
#define MRV_FILT_STAGE1_SELECT_MAX_BLUR         0U	/* 0x0 maximum blurring */
#define MRV_FILT_STAGE1_SELECT_DEFAULT          4U	/* 0x4 Default */
#define MRV_FILT_STAGE1_SELECT_MIN_BLUR         7U	/* 0x7 minimum blurring */
#define MRV_FILT_STAGE1_SELECT_BYPASS           8U	/* 0x8 filter stage1 bypass */
#endif /* MRV_FILT_STAGE1_SELECT */
/* Slice: filt_chr_h_mode:*/
/* Chroma filter horizontal mode */
/* 00 horizontal chroma filter bypass */
/* 01 horizontal chroma filter 1 static mask = [10 12 10]*/
/* 10 horizontal chroma filter 2 (dynamic blur1)*/
/* 11 horizontal chroma filter 3 (dynamic blur2) Default */
#ifdef MRV_FILT_FILT_CHR_H_MODE
#define MRV_FILT_FILT_CHR_H_MODE_BYPASS         0U	/* 00 horizontal chroma filter bypass */
#define MRV_FILT_FILT_CHR_H_MODE_STATIC         1U	/* 01 horizontal chroma filter 1 static mask = [10 12 10] */
#define MRV_FILT_FILT_CHR_H_MODE_DYN_1          2U	/* 10 horizontal chroma filter 2 (dynamic blur1) */
#define MRV_FILT_FILT_CHR_H_MODE_DYN_2          3U	/* 11 horizontal chroma filter 3 (dynamic blur2) Default */
#endif /* MRV_FILT_FILT_CHR_H_MODE */
/* Slice: filt_chr_v_mode:*/
/* Chroma filter vertical mode */
/* 00 vertical chroma filter bypass */
/* 01 vertical chroma filter 1 static [8 16 8]*/
/* 10 vertical chroma filter 2 static [10 12 10]*/
/* 11 vertical chroma filter 3 static [12 8 12] Default */
#ifdef MRV_FILT_FILT_CHR_V_MODE
#define MRV_FILT_FILT_CHR_V_MODE_BYPASS         0U	/* 00 vertical chroma filter bypass */
#define MRV_FILT_FILT_CHR_V_MODE_STATIC8        1U	/* 01 vertical chroma filter 1 static [8 16 8] */
#define MRV_FILT_FILT_CHR_V_MODE_STATIC10       2U	/* 10 vertical chroma filter 2 static [10 12 10] */
#define MRV_FILT_FILT_CHR_V_MODE_STATIC12       3U	/* 11 vertical chroma filter 3 static [12 8 12] Default */
#endif /* MRV_FILT_FILT_CHR_V_MODE */
/* Slice: filt_mode:*/
/* 0 green filter static mode (active filter factor = FILT_FAC_MID)*/
/* 1 dynamic noise reduction/sharpen Default */
#ifdef MRV_FILT_FILT_MODE
#define MRV_FILT_FILT_MODE_STATIC               0U	/* 0 green filter static mode (active filter factor = FILT_FAC_MID) */
#define MRV_FILT_FILT_MODE_DYNAMIC              1U	/* 1 dynamic noise reduction/sharpen Default */
#endif /* MRV_FILT_FILT_MODE */
/* Slice: filt_enable:*/
/* 1 enable filter */
/* 0 bypass filter Default */
#ifdef MRV_FILT_FILT_ENABLE
#define MRV_FILT_FILT_ENABLE_PROCESS            1U
#define MRV_FILT_FILT_ENABLE_BYPASS             0U
#endif /* MRV_FILT_FILT_ENABLE */
/*****************************************************************************/
/**
 * register: isp_filt_thresh_bl0: Blurring threshold 0 (0x00000028)
 *
 *****************************************************************************/
/* Slice: filt_thresh_bl0:*/
/* If filt_thresh_bl1 < sum_grad < filt_thresh_bl0 then filt_fac_bl0 is selected */
#ifdef MRV_FILT_FILT_THRESH_BL0
#endif /* MRV_FILT_FILT_THRESH_BL0 */
/*****************************************************************************/
/**
 * register: isp_filt_thresh_bl1: Blurring threshold 1 (0x0000002c)
 *
 *****************************************************************************/
/* Slice: filt_thresh_bl1:*/
/* If sum_grad < filt_thresh_bl1 then filt_fac_bl1 is selected */
#ifdef MRV_FILT_FILT_THRESH_BL1
#endif /* MRV_FILT_FILT_THRESH_BL1 */
/*****************************************************************************/
/**
 * register: isp_filt_thresh_sh0: Sharpening threshold 0 (0x00000030)
 *
 *****************************************************************************/
/* Slice: filt_thresh_sh0:*/
/* If filt_thresh_sh0 < sum_grad < filt_thresh_sh1 then filt_thresh_sh0 is selected */
#ifdef MRV_FILT_FILT_THRESH_SH0
#endif /* MRV_FILT_FILT_THRESH_SH0 */
/*****************************************************************************/
/**
 * register: isp_filt_thresh_sh1: Sharpening threshold 1 (0x00000034)
 *
 *****************************************************************************/
/* Slice: filt_thresh_sh1:*/
/* If filt_thresh_sh1 < sum_grad then filt_thresh_sh1 is selected */
#ifdef MRV_FILT_FILT_THRESH_SH1
#endif /* MRV_FILT_FILT_THRESH_SH1 */
/*****************************************************************************/
/**
 * register: isp_filt_lum_weight: Parameters for luminance weight function
 *           (0x00000038)
 *
 *****************************************************************************/
/* Slice: lum_weight_gain:*/
/* Gain select of luminance weight function */
#ifdef MRV_FILT_LUM_WEIGHT_GAIN
#endif /* MRV_FILT_LUM_WEIGHT_GAIN */
/* Slice: lum_weight_kink:*/
/* Kink position of luminance weight function */
#ifdef MRV_FILT_LUM_WEIGHT_KINK
#endif /* MRV_FILT_LUM_WEIGHT_KINK */
/* Slice: lum_weight_min:*/
/* Minimum value of luminance weight function */
#ifdef MRV_FILT_LUM_WEIGHT_MIN
#endif /* MRV_FILT_LUM_WEIGHT_MIN */
/*****************************************************************************/
/**
 * register: isp_filt_fac_sh1: filter factor sharp1 (0x0000003c)
 *
 *****************************************************************************/
/* Slice: filt_fac_sh1:*/
/* Filter factor for sharp1 level */
#ifdef MRV_FILT_FILT_FAC_SH1
#endif /* MRV_FILT_FILT_FAC_SH1 */
/*****************************************************************************/
/**
 * register: isp_filt_fac_sh0: filter factor sharp0 (0x00000040)
 *
 *****************************************************************************/
/* Slice: filt_fac_sh0:*/
/* Filter factor for sharp0 level */
#ifdef MRV_FILT_FILT_FAC_SH0
#endif /* MRV_FILT_FILT_FAC_SH0 */
/*****************************************************************************/
/**
 * register: isp_filt_fac_mid: filter factor middle (0x00000044)
 *
 *****************************************************************************/
/* Slice: filt_fac_mid:*/
/* Filter factor for mid level and for static filter mode */
#ifdef MRV_FILT_FILT_FAC_MID
#endif /* MRV_FILT_FILT_FAC_MID */
/*****************************************************************************/
/**
 * register: isp_filt_fac_bl0: Parameter for blur 0 filter (0x00000048)
 *
 *****************************************************************************/
/* Slice: filt_fac_bl0:*/
/* Filter factor for blur 0 level */
#ifdef MRV_FILT_FILT_FAC_BL0
#endif /* MRV_FILT_FILT_FAC_BL0 */
/*****************************************************************************/
/**
 * register: isp_filt_fac_bl1: Parameter for blur 1 filter (0x0000004c)
 *
 *****************************************************************************/
/* Slice: filt_fac_bl1:*/
/* Filter factor for blur 1 level (max blur)*/
#ifdef MRV_FILT_FILT_FAC_BL1
#endif /* MRV_FILT_FILT_FAC_BL1 */
/*****************************************************************************/
/* ISP Auto Focus Measurement Registers                                      */
/*****************************************************************************/
/*****************************************************************************/
/**
 * register: isp_afm_ctrl: This is the control register for AF measurement
 *           unit (0x00000000)
 *
 *****************************************************************************/
/* Slice: afm_en:*/
/* AF measurement enable */
/* 0: AF measurement is disabled */
/* 1: AF measurement is enabled */
/* Writing a 1 to this register starts a new measurement and resets the afm_fin (measurement finished) interrupt to 0.*/
/* As long as the afm_en is 1, the AFM unit calculates new sharpness values for each frame.*/
#ifdef MRV_AFM_AFM_EN
#define MRV_AFM_AFM_EN_ENABLE           1	/* 1: enable AF measurment */
#define MRV_AFM_AFM_EN_DISABLE          0	/* 0: processing is deactivated, bypass mode is selected */
#endif /* MRV_AFM_AFM_EN */
/*****************************************************************************/
/**
 * register: isp_afm_lt_a: Top Left corner of measure window A (0x00000004)
 *
 *****************************************************************************/
/* Slice: a_h_l:*/
/* first pixel of window A (horizontal left row), value must be greater or equal 5 */
#ifdef MRV_AFM_A_H_L
#define MRV_AFM_A_H_L_MIN                       (5U)
#define MRV_AFM_A_H_L_MAX   (MRV_AFM_A_H_L_MASK >> MRV_AFM_A_H_L_SHIFT)
#endif /* MRV_AFM_A_H_L */
/* Slice: a_v_t:*/
/* first line of window A (vertical top line), value must be greater or equal 2 */
#ifdef MRV_AFM_A_V_T
#define MRV_AFM_A_V_T_MIN                       (2U)
#define MRV_AFM_A_V_T_MAX   (MRV_AFM_A_V_T_MASK >> MRV_AFM_A_V_T_SHIFT)
#endif /* MRV_AFM_A_V_T */
/*****************************************************************************/
/**
 * register: isp_afm_rb_a: Bottom right corner of measure window A (0x00000008)
 *
 *****************************************************************************/
/* Slice: a_h_r:*/
/* last pixel of window A (horizontal right row)*/
#ifdef MRV_AFM_A_H_R
#define MRV_AFM_A_H_R_MIN                       (5U)
#define MRV_AFM_A_H_R_MAX   (MRV_AFM_A_H_R_MASK >> MRV_AFM_A_H_R_SHIFT)
#endif /* MRV_AFM_A_H_R */
/* Slice: a_v_b:*/
/* last line of window A (vertical bottom line), value must be lower than */
/* (number of lines -2)*/
#ifdef MRV_AFM_A_V_B
#define MRV_AFM_A_V_B_MIN                       (2U)
#define MRV_AFM_A_V_B_MAX   (MRV_AFM_A_V_B_MASK >> MRV_AFM_A_V_B_SHIFT)
#endif /* MRV_AFM_A_V_B */
/*****************************************************************************/
/**
 * register: isp_afm_lt_b: Top left corner of measure window B (0x0000000c)
 *
 *****************************************************************************/
/* Slice: b_h_l:*/
/* first pixel of window B (horizontal left row), value must be greater or equal 5 */
#ifdef MRV_AFM_B_H_L
#define MRV_AFM_B_H_L_MIN                       (5U)
#define MRV_AFM_B_H_L_MAX   (MRV_AFM_B_H_L_MASK >> MRV_AFM_B_H_L_SHIFT)
#endif /* MRV_AFM_B_H_L */
/* Slice: b_v_t:*/
/* first line of window B (vertical top line), value must be greater or equal 2 */
#ifdef MRV_AFM_B_V_T
#define MRV_AFM_B_V_T_MIN                       (2U)
#define MRV_AFM_B_V_T_MAX   (MRV_AFM_B_V_T_MASK >> MRV_AFM_B_V_T_SHIFT)
#endif /* MRV_AFM_B_V_T */
/*****************************************************************************/
/**
 * register: isp_afm_rb_b: Bottom right corner of measure window B (0x00000010)
 *
 *****************************************************************************/
/* Slice: b_h_r:*/
/* last pixel of window B (horizontal right row)*/
#ifdef MRV_AFM_B_H_R
#define MRV_AFM_B_H_R_MIN                       (5U)
#define MRV_AFM_B_H_R_MAX   (MRV_AFM_B_H_R_MASK >> MRV_AFM_B_H_R_SHIFT)
#endif /* MRV_AFM_B_H_R */
/* Slice: b_v_b:*/
/* last line of window B (vertical bottom line), value must be lower than */
/* (number of lines -2)*/
#ifdef MRV_AFM_B_V_B
#define MRV_AFM_B_V_B_MIN                       (2U)
#define MRV_AFM_B_V_B_MAX   (MRV_AFM_B_V_B_MASK >> MRV_AFM_B_V_B_SHIFT)
#endif /* MRV_AFM_B_V_B */
/*****************************************************************************/
/**
 * register: isp_afm_lt_c: Top left corner of measure window C (0x00000014)
 *
 *****************************************************************************/
/* Slice: c_h_l:*/
/* first pixel of window C (horizontal left row), value must be greater or equal 5 */
#ifdef MRV_AFM_C_H_L
#define MRV_AFM_C_H_L_MIN                       (5U)
#define MRV_AFM_C_H_L_MAX   (MRV_AFM_C_H_L_MASK >> MRV_AFM_C_H_L_SHIFT)
#endif /* MRV_AFM_C_H_L */
/* Slice: c_v_t:*/
/* first line of window C (vertical top line), value must be greater or equal 2 */
#ifdef MRV_AFM_C_V_T
#define MRV_AFM_C_V_T_MIN                       (2U)
#define MRV_AFM_C_V_T_MAX   (MRV_AFM_C_V_T_MASK >> MRV_AFM_C_V_T_SHIFT)
#endif /* MRV_AFM_C_V_T */
/*****************************************************************************/
/**
 * register: isp_afm_rb_c: Bottom right corner of measure window C (0x00000018)
 *
 *****************************************************************************/
/* Slice: c_h_r:*/
/* last pixel of window C (horizontal right row)*/
#ifdef MRV_AFM_C_H_R
#define MRV_AFM_C_H_R_MIN                       (5U)
#define MRV_AFM_C_H_R_MAX   (MRV_AFM_C_H_R_MASK >> MRV_AFM_C_H_R_SHIFT)
#endif /* MRV_AFM_C_H_R */
/* Slice: c_v_b:*/
/* last line of window C (vertical bottom line), value must be lower than */
/* (number of lines -2)*/
#ifdef MRV_AFM_C_V_B
#define MRV_AFM_C_V_B_MIN                       (2U)
#define MRV_AFM_C_V_B_MAX   (MRV_AFM_C_V_B_MASK >> MRV_AFM_C_V_B_SHIFT)
#endif /* MRV_AFM_C_V_B */
/*****************************************************************************/
/**
 * register: isp_afm_thres: Threshold register (0x0000001c)
 *
 *****************************************************************************/
/* Slice: afm_thres:*/
/* AF measurement threshold */
/* This register defines a threshold which can be used for minimizing the */
/* influence of noise in the measurement result.*/
#ifdef MRV_AFM_AFM_THRES
#endif /* MRV_AFM_AFM_THRES */
/*****************************************************************************/
/**
 * register: isp_afm_var_shift: Variable shift register (0x00000020)
 *
 *****************************************************************************/
/* Slice: lum_var_shift:*/
/* variable shift for luminance summation */
/* The lum_var_shift defines the number of bits for the shift operation of the */
/* value of the current pixel before summation. The shift operation is used to */
/* avoid a luminance sum overflow.*/
#ifdef MRV_AFM_LUM_VAR_SHIFT
#endif /* MRV_AFM_LUM_VAR_SHIFT */
/* Slice: afm_var_shift:*/
/* variable shift for AF measurement */
/* The afm_var_shift defines the number of bits for the shift operation at the */
/* end of the calculation chain. The shift operation is used to avoid an AF */
/* measurement sum overflow.*/
#ifdef MRV_AFM_AFM_VAR_SHIFT
#endif /* MRV_AFM_AFM_VAR_SHIFT */
/*****************************************************************************/
/**
 * register: isp_afm_sum_a: Sharpness Value Status Register of Window A (0x0024)
 *
 *****************************************************************************/
/* Slice: afm_sum_a:*/
/* sharpness value of window A */
#ifdef MRV_AFM_AFM_SUM_A
#endif /* MRV_AFM_AFM_SUM_A */
/*****************************************************************************/
/**
 * register: isp_afm_sum_b: Sharpness Value Status Register of Window B (0x0028)
 *
 *****************************************************************************/
/* Slice: afm_sum_b:*/
/* sharpness value of window B */
#ifdef MRV_AFM_AFM_SUM_B
#endif /* MRV_AFM_AFM_SUM_B */
/*****************************************************************************/
/**
 * register: isp_afm_sum_c: Sharpness Value Status Register of Window C (0x002c)
 *
 *****************************************************************************/
/* Slice: afm_sum_c:*/
/* sharpness value of window C */
#ifdef MRV_AFM_AFM_SUM_C
#endif /* MRV_AFM_AFM_SUM_C */
/*****************************************************************************/
/**
 * register: isp_afm_lum_a: Luminance Value Status Register of Window A (0x0030)
 *
 *****************************************************************************/
/* Slice: afm_lum_a:*/
/* luminance value of window A */
#ifdef MRV_AFM_AFM_LUM_A
#endif /* MRV_AFM_AFM_LUM_A */
/*****************************************************************************/
/**
 * register: isp_afm_lum_b: Luminance Value Status Register of Window B (0x0034)
 *
 *****************************************************************************/
/* Slice: afm_lum_b:*/
/* luminance value of window B */
#ifdef MRV_AFM_AFM_LUM_B
#endif /* MRV_AFM_AFM_LUM_B */
/*****************************************************************************/
/**
 * register: isp_afm_lum_c: Luminance Value Status Register of Window C (0x0038)
 *
 *****************************************************************************/
/* Slice: afm_lum_c:*/
/* luminance value of window C */
#ifdef MRV_AFM_AFM_LUM_C
#endif /* MRV_AFM_AFM_LUM_C */
/*****************************************************************************/
/* ISP Lens Shade Correction Registers                                       */
/*****************************************************************************/
/*****************************************************************************/
/**
 * register: isp_lsc_ctrl: Lens shade control (0x00000000)
 *
 *****************************************************************************/
/* Slice: lsc_en:*/
/* 0: activation request for lens shading correction */
/* 1: deactivation reqeust for lens shading correction */
/* Activation/Deactivation is object of a shadowing mechnism. The current */
/* status is visible at ISP_LSC_STATUS::lsc_enable_status */
#ifdef MRV_LSC_LSC_EN
#define MRV_LSC_LSC_EN_ENABLE                   1U
#define MRV_LSC_LSC_EN_DISABLE                  0U
#endif /* MRV_LSC_LSC_EN */
/*****************************************************************************/
/**
 * register: isp_lsc_r_table_addr: Table RAM Address for red component (0x00000004)
 *
 *****************************************************************************/
/* Slice: r_ram_addr:*/
/* table address in RAM for samples of the R color component.*/
/* Will be automatically incremented by each read or write access to the table.*/
/* Valid addresses are in the range 0 to 152 for Bank0 and 153 to 305 for Bank1 */
/* (if available).*/
#ifdef MRV_LSC_R_RAM_ADDR
#define MRV_LSC_R_RAM_ADDR_MIN_BANK0            (0x00000000U)
#define MRV_LSC_R_RAM_ADDR_MAX_BANK0            (0x00000098U)
#define MRV_LSC_R_RAM_ADDR_MIN_BANK1            (0x00000099U)
#define MRV_LSC_R_RAM_ADDR_MAX_BANK1            (0x00000132U)
#endif /* MRV_LSC_R_RAM_ADDR */
/*****************************************************************************/
/**
 * register: isp_lsc_gr_table_addr: Table RAM Address for green (red) component
 *           (0x00000008)
 *
 *****************************************************************************/
/* Slice: gr_ram_addr:*/
/* table address in RAM for samples of the G_R color component.*/
/* Will be automatically incremented by each read or write access to the table.*/
/* Valid addresses are in the range 0 to 152 for Bank0 and 153 to 305 for Bank1 */
/* (if available).*/
#ifdef MRV_LSC_GR_RAM_ADDR
#define MRV_LSC_GR_RAM_ADDR_MIN_BANK0           (0x00000000U)
#define MRV_LSC_GR_RAM_ADDR_MAX_BANK0           (0x00000098U)
#define MRV_LSC_GR_RAM_ADDR_MIN_BANK1           (0x00000099U)
#define MRV_LSC_GR_RAM_ADDR_MAX_BANK1           (0x00000131U)
#endif /* MRV_LSC_GR_RAM_ADDR */
/*****************************************************************************/
/**
 * register: isp_lsc_b_table_addr: Table RAM Address for blue component
 *           (0x0000000c)
 *
 *****************************************************************************/
/* Slice: b_ram_addr:*/
/* table address in RAM for samples of the B color component.*/
/* Will be automatically incremented by each read or write access to the table.*/
/* Valid addresses are in the range 0 to 152 for Bank0 and 153 to 305 for Bank1 */
/* (if available).*/
#ifdef MRV_LSC_B_RAM_ADDR
#define MRV_LSC_B_RAM_ADDR_MIN_BANK0            (0x00000000U)
#define MRV_LSC_B_RAM_ADDR_MAX_BANK0            (0x00000098U)
#define MRV_LSC_B_RAM_ADDR_MIN_BANK1            (0x00000099U)
#define MRV_LSC_B_RAM_ADDR_MAX_BANK1            (0x00000132U)
#endif /* MRV_LSC_B_RAM_ADDR */
/*****************************************************************************/
/**
 * register: isp_lsc_gb_table_addr: Table RAM Address for green (blue) component
 *           (0x00000010)
 *
 *****************************************************************************/
/* Slice: gb_ram_addr:*/
/* table address in RAM for samples of the G_B color component.*/
/* Will be automatically incremented by each read or write access to the table.*/
/* Valid addresses are in the range 0 to 152 for Bank0 and 153 to 305 for Bank1 */
/* (if available).*/
#ifdef MRV_LSC_GB_RAM_ADDR
#define MRV_LSC_GB_RAM_ADDR_MIN_BANK0           (0x00000000U)
#define MRV_LSC_GB_RAM_ADDR_MAX_BANK0           (0x00000098U)
#define MRV_LSC_GB_RAM_ADDR_MIN_BANK1           (0x00000099U)
#define MRV_LSC_GB_RAM_ADDR_MAX_BANK1           (0x00000132U)
#endif /* MRV_LSC_GB_RAM_ADDR */
/*****************************************************************************/
/**
 * register: isp_lsc_r_table_data: Sample table red (0x00000014)
 *
 *****************************************************************************/
/* Slice: r_sample_1:*/
/* correction factor at sample point (fixed point number: 2 bits integer with */
/* 10-bit fractional part, range 1..3.999)*/
#ifdef MRV_LSC_R_SAMPLE_1
#endif /* MRV_LSC_R_SAMPLE_1 */
/* Slice: r_sample_0:*/
/* correction factor at sample point (fixed point number: 2 bits integer with */
/* 10-bit fractional part, range 1..3.999)*/
#ifdef MRV_LSC_R_SAMPLE_0
#endif /* MRV_LSC_R_SAMPLE_0 */
/*****************************************************************************/
/**
 * register: isp_lsc_gr_table_data: Sample table green (red) (0x00000018)
 *
 *****************************************************************************/
/* Slice: gr_sample_1:*/
/* correction factor at sample point (fixed point number: 2 bits integer with */
/* 10-bit fractional part, range 1..3.999)*/
#ifdef MRV_LSC_GR_SAMPLE_1
#endif /* MRV_LSC_GR_SAMPLE_1 */
/* Slice: gr_sample_0:*/
/* correction factor at sample point (fixed point number: 2 bits integer with */
/* 10-bit fractional part, range 1..3.999)*/
#ifdef MRV_LSC_GR_SAMPLE_0
#endif /* MRV_LSC_GR_SAMPLE_0 */
/*****************************************************************************/
/**
 * register: Register: isp_lsc_b_table_data: Sample table blue (0x0000001c)
 *
 *****************************************************************************/
/* Slice: b_sample_1:*/
/* correction factor at sample point (fixed point number: 2 bits integer with */
/* 10-bit fractional part, range 1..3.999)*/
#ifdef MRV_LSC_B_SAMPLE_1
#endif /* MRV_LSC_B_SAMPLE_1 */
/* Slice: b_sample_0:*/
/* correction factor at sample point (fixed point number: 2 bits integer with */
/* 10-bit fractional part, range 1..3.999)*/
#ifdef MRV_LSC_B_SAMPLE_0
#endif /* MRV_LSC_B_SAMPLE_0 */
/*****************************************************************************/
/**
 * register: isp_lsc_gb_table_data: Sample table green (blue) (0x00000020)
 *
 *****************************************************************************/
/* Slice: gb_sample_1:*/
/* correction factor at sample point (fixed point number: 2 bits integer with */
/* 10-bit fractional part, range 1..3.999)*/
#ifdef MRV_LSC_GB_SAMPLE_1
#endif /* MRV_LSC_GB_SAMPLE_1 */
/* Slice: gb_sample_0:*/
/* correction factor at sample point (fixed point number: 2 bits integer with */
/* 10-bit fractional part, range 1..3.999)*/
#ifdef MRV_LSC_GB_SAMPLE_0
#endif /* MRV_LSC_GB_SAMPLE_0 */
/*****************************************************************************/
/**
 * register: isp_lsc_xgrad_01: Gradient table x (0x00000024)
 *
 *****************************************************************************/
/* Slice: xgrad_1:*/
/* factor for x-gradient calculation of sector 1 */
#ifdef MRV_LSC_XGRAD_1
#endif /* MRV_LSC_XGRAD_1 */
/* Slice: xgrad_0:*/
/* factor for x-gradient calculation of sector 0 */
#ifdef MRV_LSC_XGRAD_0
#endif /* MRV_LSC_XGRAD_0 */
/*****************************************************************************/
/**
 * register: isp_lsc_xgrad_23: Gradient table x (0x00000028)
 *
 *****************************************************************************/
/* Slice: xgrad_3:*/
/* factor for x-gradient calculation of sector 3 */
#ifdef MRV_LSC_XGRAD_3
#endif /* MRV_LSC_XGRAD_3 */
/* Slice: xgrad_2:*/
/* factor for x-gradient calculation of sector 2 */
#ifdef MRV_LSC_XGRAD_2
#endif /* MRV_LSC_XGRAD_2 */
/*****************************************************************************/
/**
 * register: isp_lsc_xgrad_45: Gradient table x (0x0000002c)
 *
 *****************************************************************************/
/* Slice: xgrad_5:*/
/* factor for x-gradient calculation of sector 5 */
#ifdef MRV_LSC_XGRAD_5
#endif /* MRV_LSC_XGRAD_5 */
/* Slice: xgrad_4:*/
/* factor for x-gradient calculation of sector 4 */
#ifdef MRV_LSC_XGRAD_4
#endif /* MRV_LSC_XGRAD_4 */
/*****************************************************************************/
/**
 * register: isp_lsc_xgrad_67: Gradient table x (0x00000030)
 *
 *****************************************************************************/
/* Slice: xgrad_7:*/
/* factor for x-gradient calculation of sector 7 */
#ifdef MRV_LSC_XGRAD_7
#endif /* MRV_LSC_XGRAD_7 */
/* Slice: xgrad_6:*/
/* factor for x-gradient calculation of sector 6 */
#ifdef MRV_LSC_XGRAD_6
#endif /* MRV_LSC_XGRAD_6 */
/*****************************************************************************/
/**
 * register: isp_lsc_ygrad_01: Gradient table y (0x00000034)
 *
 *****************************************************************************/
/* Slice: ygrad_1:*/
/* factor for y-gradient calculation of sector 1 */
#ifdef MRV_LSC_YGRAD_1
#endif /* MRV_LSC_YGRAD_1 */
/* Slice: ygrad_0:*/
/* factor for y-gradient calculation of sector 0 */
#ifdef MRV_LSC_YGRAD_0
#endif /* MRV_LSC_YGRAD_0 */
/*****************************************************************************/
/**
 * register: isp_lsc_ygrad_23: Gradient table y (0x00000038)
 *
 *****************************************************************************/
/* Slice: ygrad_3:*/
/* factor for y-gradient calculation of sector 3 */
#ifdef MRV_LSC_YGRAD_3
#endif /* MRV_LSC_YGRAD_3 */
/* Slice: ygrad_2:*/
/* factor for y-gradient calculation of sector 2 */
#ifdef MRV_LSC_YGRAD_2
#endif /* MRV_LSC_YGRAD_2 */
/*****************************************************************************/
/**
 * register: isp_lsc_ygrad_45: Gradient table y (0x0000003c)
 *
 *****************************************************************************/
/* Slice: ygrad_5:*/
/* factor for y-gradient calculation of sector 5 */
#ifdef MRV_LSC_YGRAD_5
#endif /* MRV_LSC_YGRAD_5 */
/* Slice: ygrad_4:*/
/* factor for y-gradient calculation of sector 4 */
#ifdef MRV_LSC_YGRAD_4
#endif /* MRV_LSC_YGRAD_4 */
/*****************************************************************************/
/**
 * register: isp_lsc_ygrad_67: Gradient table y (0x00000040)
 *
 *****************************************************************************/
/* Slice: ygrad_7:*/
/* factor for y-gradient calculation of sector 7 */
#ifdef MRV_LSC_YGRAD_7
#endif /* MRV_LSC_YGRAD_7 */
/* Slice: ygrad_6:*/
/* factor for y-gradient calculation of sector 6 */
#ifdef MRV_LSC_YGRAD_6
#endif /* MRV_LSC_YGRAD_6 */
/*****************************************************************************/
/**
 * register: isp_lsc_xsize_01: Size table (0x00000044)
 *
 *****************************************************************************/
/* Slice: x_sect_size_1:*/
/* sector size 1 in x-direction */
#ifdef MRV_LSC_X_SECT_SIZE_1
#endif /* MRV_LSC_X_SECT_SIZE_1 */
/* Slice: x_sect_size_0:*/
/* sector size 0 in x-direction */
#ifdef MRV_LSC_X_SECT_SIZE_0
#endif /* MRV_LSC_X_SECT_SIZE_0 */
/*****************************************************************************/
/**
 * register: isp_lsc_xsize_23: Size table (0x00000048)
 *
 *****************************************************************************/
/* Slice: x_sect_size_3:*/
/* sector size 3 in x-direction */
#ifdef MRV_LSC_X_SECT_SIZE_3
#endif /* MRV_LSC_X_SECT_SIZE_3 */
/* Slice: x_sect_size_2:*/
/* sector size 2 in x-direction */
#ifdef MRV_LSC_X_SECT_SIZE_2
#endif /* MRV_LSC_X_SECT_SIZE_2 */
/*****************************************************************************/
/**
 * register: isp_lsc_xsize_45: Size table (0x0000004c)
 *
 *****************************************************************************/
/* Slice: x_sect_size_5:*/
/* sector size 5 in x-direction */
#ifdef MRV_LSC_X_SECT_SIZE_5
#endif /* MRV_LSC_X_SECT_SIZE_5 */
/* Slice: x_sect_size_4:*/
/* sector size 4in x-direction */
#ifdef MRV_LSC_X_SECT_SIZE_4
#endif /* MRV_LSC_X_SECT_SIZE_4 */
/*****************************************************************************/
/**
 * register: isp_lsc_xsize_67: Size table (0x00000050)
 *
 *****************************************************************************/
/* Slice: x_sect_size_7:*/
/* sector size 7 in x-direction */
#ifdef MRV_LSC_X_SECT_SIZE_7
#endif /* MRV_LSC_X_SECT_SIZE_7 */
/* Slice: x_sect_size_6:*/
/* sector size 6 in x-direction */
#ifdef MRV_LSC_X_SECT_SIZE_6
#endif /* MRV_LSC_X_SECT_SIZE_6 */
/*****************************************************************************/
/**
 * register: isp_lsc_ysize_01: Size table (0x00000054)
 *
 *****************************************************************************/
/* Slice: y_sect_size_1:*/
/* sector size 1 in y-direction */
#ifdef MRV_LSC_Y_SECT_SIZE_1
#endif /* MRV_LSC_Y_SECT_SIZE_1 */
/* Slice: y_sect_size_0:*/
/* sector size 0 in y-direction */
#ifdef MRV_LSC_Y_SECT_SIZE_0
#endif /* MRV_LSC_Y_SECT_SIZE_0 */
/*****************************************************************************/
/**
 * register: isp_lsc_ysize_23: Size table (0x00000058)
 *
 *****************************************************************************/
/* Slice: y_sect_size_3:*/
/* sector size 3 in y-direction */
#ifdef MRV_LSC_Y_SECT_SIZE_3
#endif /* MRV_LSC_Y_SECT_SIZE_3 */
/* Slice: y_sect_size_2:*/
/* sector size 2 in y-direction */
#ifdef MRV_LSC_Y_SECT_SIZE_2
#endif /* MRV_LSC_Y_SECT_SIZE_2 */
/*****************************************************************************/
/**
 * register: isp_lsc_ysize_45: Size table (0x0000005c)
 *
 *****************************************************************************/
/* Slice: y_sect_size_5:*/
/* sector size 5 in y-direction */
#ifdef MRV_LSC_Y_SECT_SIZE_5
#endif /* MRV_LSC_Y_SECT_SIZE_5 */
/* Slice: y_sect_size_4:*/
/* sector size 4 in y-direction */
#ifdef MRV_LSC_Y_SECT_SIZE_4
#endif /* MRV_LSC_Y_SECT_SIZE_4 */
/*****************************************************************************/
/**
 * register: isp_lsc_ysize_67: Size table (0x00000060)
 *
 *****************************************************************************/
/* Slice: y_sect_size_7:*/
/* sector size 7 in y-direction */
#ifdef MRV_LSC_Y_SECT_SIZE_7
#endif /* MRV_LSC_Y_SECT_SIZE_7 */
/* Slice: y_sect_size_6:*/
/* sector size 6 in y-direction */
#ifdef MRV_LSC_Y_SECT_SIZE_6
#endif /* MRV_LSC_Y_SECT_SIZE_6 */
/*****************************************************************************/
/**
 * register: isp_lsc_table_sel: Lens shade table set selection (0x00000064)
 *
 *****************************************************************************/
/* Slice: table_sel:*/
/* 0: next active tables set is table set 0.*/
/* 1: next active tables set is table set 1.*/
/* Table selection is object of a shadowing mechnism. The current status is */
/* visible at ISP_LSC_STATUS::active_table.*/
#ifdef MRV_LSC_TABLE_SEL
#define MRV_LSC_TABLE_SEL_BANK0                 (0U)
#define MRV_LSC_TABLE_SEL_BANK1                 (1U)
#endif /* MRV_LSC_TABLE_SEL */
/*****************************************************************************/
/**
 * register: isp_lsc_status: Lens shade status (0x00000068)
 *
 *****************************************************************************/
/* Slice: active_table:*/
/* 0: currently active tables set is table set 0 */
/* 1: currently active tables set is table set 1 */
#ifdef MRV_LSC_ACTIVE_TABLE
#define MRV_LSC_ACTIVE_TABLE_BANK0              (0U)
#define MRV_LSC_ACTIVE_TABLE_BANK1              (1U)
#endif /* MRV_LSC_ACTIVE_TABLE */
/* Slice: lsc_en_status:*/
/* 0: lens shading correction is currently off */
/* 1: lens shading correction is currently on */
#ifdef MRV_LSC_LSC_EN_STATUS
#endif /* MRV_LSC_LSC_EN_STATUS */
/*****************************************************************************/
/* ISP Chromatic Aberration Correction Registers                             */
/*****************************************************************************/
/*****************************************************************************/
/**
 * register: isp_cac_ctrl: Control register for chromatic aberration
 *           correction (0x00000000)
 *
 *****************************************************************************/
/* Slice: h_clip_mode:*/
/* Defines the maximum red/blue pixel shift in horizontal direction at pixel */
/* positions, that require a larger displacement, the maximum shift value is */
/* used instead (vector clipping)*/
     /**/
/* 0: Set horizontal vector clipping to +/-4 pixel displacement (Default)*/
/* 1: Set horizontal vector clipping to +/-4 or +/-5 pixel displacement */
/*    depending on pixel position inside the Bayer raster (dynamic switching */
/*    between +/-4 and +/-5)*/
#ifdef MRV_CAC_H_CLIP_MODE
#define MRV_CAC_H_CLIP_MODE_FIX4            0	/* 0: Set horizontal vector clipping */
    /*    to +/-4 pixel displacement (Default) */
#define MRV_CAC_H_CLIP_MODE_DYN5            1	/* 1: Set horizontal vector clipping */
    /*    to +/-4 or +/-5 pixel displacement depending on */
    /*    pixel position inside the Bayer raster */
    /*    (dynamic switching between +/-4 and +/-5) */
#endif /* MRV_CAC_H_CLIP_MODE */
/* Slice: v_clip_mode:*/
/* Defines the maximum red/blue pixel shift in vertical direction */
/* 00: Set vertical vector clipping to +/-2 pixel ; fix filter_enable (Default)*/
/* 01: Set vertical vector clipping to +/-3 pixel; dynamic filter_enable for */
/*     chroma low pass filter */
/* 10: Set vertical vector clipping +/-3 or +/-4 pixel displacement depending */
/*     on pixel position inside the Bayer raster (dynamic switching between +/-3 and +/-4)*/
/* 11: reserved */
#ifdef MRV_CAC_V_CLIP_MODE
#define MRV_CAC_V_CLIP_MODE_FIX2            0	/* 00: Set vertical vector clipping to +/-2 pixel; */
    /*     fix filter_enable (Default) */
#define MRV_CAC_V_CLIP_MODE_FIX3            1	/* 01: Set vertical vector clipping to +/-3 pixel; */
    /*     dynamic filter_enable for chroma low pass filter */
#define MRV_CAC_V_CLIP_MODE_DYN4            2	/* 10: Set vertical vector clipping +/-3 or +/-4 pixel */
    /*     displacement depending on pixel position inside */
    /*     the Bayer raster (dynamic switching between +/-3 and +/-4) */
#endif /* MRV_CAC_V_CLIP_MODE */
/* Slice: cac_en:*/
/* 0: chromatic aberration correction off */
/* 1: chromatic aberration correction on */
#ifdef MRV_CAC_CAC_EN
#define MRV_CAC_CAC_EN_PROCESS                  1
#define MRV_CAC_CAC_EN_BYPASS                   0
#endif /* MRV_CAC_CAC_EN */
/*****************************************************************************/
/**
 * register: isp_cac_count_start: Preload values for CAC pixel and line
 *           counter (0x00000004)
 *
 *****************************************************************************/
/* Slice: v_count_start:*/
/* 12 bit v_count preload value (range 4095 ... 1) of the vertical CAC line */
/* counter. Before frame start v_count has to be preloaded with */
/* (v_size/2 + v_center_offset), with v_size the image height and v_center_offset */
/* the vertical distance between image center and optical center.*/
     /**/
/* After frame start the v_count decrements with every line until a value of zero */
/* is reached for the line in the optical center. Than the v_sign bit toggles and */
/* the v_counter decrements with every line until end of frame.*/
#ifdef MRV_CAC_V_COUNT_START
#define MRV_CAC_V_COUNT_START_MIN               1
#define MRV_CAC_V_COUNT_START_MAX               (MRV_CAC_V_COUNT_START_MASK >> MRV_CAC_V_COUNT_START_SHIFT)
#endif /* MRV_CAC_V_COUNT_START */
/* Slice: h_count_start:*/
/* 12 bit h_count preload value (range 4095 .. 1) of the horizontal CAC pixel */
/* counter. Before line start h_count has to be preloaded with (h_size/2 + h_center_offset),*/
/* with h_size the image width and h_center_offset the horizontal distance between image */
/* center and optical center.*/
     /**/
/* After line start the h_count decrements with every pixel until a value of zero is */
/* reached for the column in the optical center. Than the h_sign bit toggles and the */
/* h_counter increments with every pixel until end of line.*/
#ifdef MRV_CAC_H_COUNT_START
#define MRV_CAC_H_COUNT_START_MIN               1
#define MRV_CAC_H_COUNT_START_MAX               (MRV_CAC_H_COUNT_START_MASK >> MRV_CAC_H_COUNT_START_SHIFT)
#endif /* MRV_CAC_H_COUNT_START */
/*****************************************************************************/
/**
 * register: isp_cac_a: Linear Parameters for radial shift calculation (0x00000008)
 *
 *****************************************************************************/
/* Slice: A_Blue:*/
/* Parameter A_Blue for radial blue shift calculation, according to */
/* (A_Blue * r  + B_Blue * r^2 + C_Blue * r^3).*/
/* It is a 9 bit twos complement integer with 4 fractional digits value and */
/* value range from -16 up to 15.9375.*/
#ifdef MRV_CAC_A_BLUE
#define MRV_CAC_A_BLUE_MAX                      (MRV_CAC_A_BLUE_MASK >> (MRV_CAC_A_BLUE_SHIFT + 1))
#define MRV_CAC_A_BLUE_MIN                      (~MRV_CAC_A_BLUE_MAX)
#endif /* MRV_CAC_A_BLUE */
/* Slice: A_Red:*/
/* Parameter A_Red for radial red shift calculation, according to */
/* (A_Red * r + B_Red * r^2 + C_Red * r^3).*/
/* It is a 9 bit twos complement integer with 4 fractional digits value and */
/* value range from -16 up to 15.9375.*/
#ifdef MRV_CAC_A_RED
#define MRV_CAC_A_RED_MAX                       (MRV_CAC_A_RED_MASK >> (MRV_CAC_A_RED_SHIFT + 1))
#define MRV_CAC_A_RED_MIN                       (~MRV_CAC_A_RED_MAX)
#endif /* MRV_CAC_A_RED */
/*****************************************************************************/
/**
 * register: isp_cac_b: Square Parameters for radial shift calculation (0x0000000c)
 *
 *****************************************************************************/
/* Slice: B_Blue:*/
/* Parameter B_Blue for radial blue shift calculation, according to */
/* (A_Blue * r  + B_Blue * r^2 + C_Blue * r^3).*/
/* It is a 9 bit twos complement integer with 4 fractional digits value and */
/* value range from -16 up to 15.9375.*/
#ifdef MRV_CAC_B_BLUE
#define MRV_CAC_B_BLUE_MAX                      (MRV_CAC_B_BLUE_MASK >> (MRV_CAC_B_BLUE_SHIFT + 1))
#define MRV_CAC_B_BLUE_MIN                      (~MRV_CAC_B_BLUE_MAX)
#endif /* MRV_CAC_B_BLUE */
/* Slice: B_Red:*/
/* Parameter B_Red for radial red shift calculation, according to */
/* (A_Red * r + B_Red * r^2 + C_Red * r^3).*/
/* It is a 9 bit twos complement integer with 4 fractional digits value and */
/* value range from -16 up to 15.9375.*/
#ifdef MRV_CAC_B_RED
#define MRV_CAC_B_RED_MAX                       (MRV_CAC_B_RED_MASK >> (MRV_CAC_B_RED_SHIFT + 1))
#define MRV_CAC_B_RED_MIN                       (~MRV_CAC_B_RED_MAX)
#endif /* MRV_CAC_B_RED */
/*****************************************************************************/
/**
 * register: isp_cac_c: Cubical Parameters for radial shift calculation (0x00000010)
 *
 *****************************************************************************/
/* Slice: C_Blue:*/
/* Parameter C_Blue for radial blue shift calculation, according to */
/* (A_Blue * r  + B_Blue * r^2 + C_Blue * r^3).*/
/* It is a 9 bit twos complement integer with 4 fractional digits value and */
/* value range from -16 up to 15.9375.*/
#ifdef MRV_CAC_C_BLUE
#define MRV_CAC_C_BLUE_MAX                      (MRV_CAC_C_BLUE_MASK >> (MRV_CAC_C_BLUE_SHIFT + 1))
#define MRV_CAC_C_BLUE_MIN                      (~MRV_CAC_C_BLUE_MAX)
#endif /* MRV_CAC_C_BLUE */
/* Slice: C_Red:*/
/* Parameter C_Red for radial red shift calculation, according to */
/* (A_Red * r + B_Red * r^2 + C_Red * r^3).*/
/* It is a 9 bit twos complement integer with 4 fractional digits value and */
/* value range from -16 up to 15.9375.*/
#ifdef MRV_CAC_C_RED
#define MRV_CAC_C_RED_MAX                       (MRV_CAC_C_RED_MASK >> (MRV_CAC_C_RED_SHIFT + 1))
#define MRV_CAC_C_RED_MIN                       (~MRV_CAC_C_RED_MAX)
#endif /* MRV_CAC_C_RED */
/*****************************************************************************/
/**
 * register: isp_cac_x_norm: Normalization parameters for calculation of image
 *           coordinate x_d relative to optical center (0x00000014)
 *
 *****************************************************************************/
/* Slice: x_ns:*/
/* Horizontal normalization shift parameter x_ns (4 bit unsigned integer)*/
/* in equation x_d[7:0] = (((h_count <% 4) %> x_ns) * x_nf) >> 5 */
#ifdef MRV_CAC_X_NS
#define MRV_CAC_X_NS_MIN                        0
#define MRV_CAC_X_NS_MAX                        (MRV_CAC_X_NS_MASK >> MRV_CAC_X_NS_SHIFT)
#endif /* MRV_CAC_X_NS */
/* Slice: x_nf:*/
/* Horizontal scaling or normalization factor x_nf (5 bit unsigned integer)*/
/* range 0 .. 31 in equation x_d[7:0] = (((h_count <% 4) %> x_ns) * x_nf) >> 5 */
#ifdef MRV_CAC_X_NF
#define MRV_CAC_X_NF_MIN                        0
#define MRV_CAC_X_NF_MAX                        31
#endif /* MRV_CAC_X_NF */
/*****************************************************************************/
/**
 * register: isp_cac_y_norm: Normalization parameters for calculation of image
 *           coordinate y_d relative to optical center (0x00000018)
 *
 *****************************************************************************/
/* Slice: y_ns:*/
/* Vertical normalization shift parameter y_ns (4 bit unsigned integer)*/
/* in equation y_d[7:0] = (((v_count <% 4) %> y_ns) * y_nf) >> 5 */
#ifdef MRV_CAC_Y_NS
#define MRV_CAC_Y_NS_MIN                        0
#define MRV_CAC_Y_NS_MAX                        (MRV_CAC_Y_NS_MASK >> MRV_CAC_Y_NS_SHIFT)
#endif /* MRV_CAC_Y_NS */
/* Slice: y_nf:*/
/* Vertical scaling or normalization factor y_nf (5 bit unsigned integer)*/
/* range 0 .. 31 in equation y_d[7:0] = (((v_count <% 4) %> y_ns) * y_nf) >> 5 */
#ifdef MRV_CAC_Y_NF
#define MRV_CAC_Y_NF_MIN                        0
#define MRV_CAC_Y_NF_MAX                        31
#endif /* MRV_CAC_Y_NF */
/*****************************************************************************/
/* ISP Exposure Measurement Registers                                        */
/*****************************************************************************/
/*****************************************************************************/
/**
 * register: isp_exp_ctrl: Exposure control (0x00000000)
 *
 *****************************************************************************/
/* Slice: exp_meas_mode:*/
/* '1' luminance calculation according to Y=(R+G+B) x 0.332 (85/256)*/
/* '0' luminance calculation according to Y=16+0.25R+0.5G+0.1094B */
#ifdef MRV_AE_EXP_MEAS_MODE
#define MRV_AE_EXP_MEAS_MODE_1                  1	/* '1' luminance calculation according to Y=(R+G+B) x 0.332 (85/256) */
#define MRV_AE_EXP_MEAS_MODE_0                  0	/* '0' luminance calculation according to Y=16+0.25R+0.5G+0.1094B */
#endif /* MRV_AE_EXP_MEAS_MODE */
/* Slice: autostop:*/
/* '1' stop measuring after a complete frame */
/* '0' continous measurement */
#ifdef MRV_AE_AUTOSTOP
#define MRV_AE_AUTOSTOP_STOP_MEASURING          1	/* stop measuring after a complete frame */
#define MRV_AE_AUTOSTOP_CONTINOUS_MEASURING     0	/* don't stop measurement, continoue with next frame */
#endif /* MRV_AE_AUTOSTOP */
/* Slice: exp_start:*/
/* '1' start measuring a frame. The exp block will reset this bit and halt */
/* after completing one frame, if bit "autostop" is set to '1'.*/
#ifdef MRV_AE_EXP_START
#define MRV_AE_EXP_START_PROCESS                1	/* 1: processing is activated */
#define MRV_AE_EXP_START_BYPASS                 0	/* 0: processing is deactivated, bypass mode is selected */
#endif /* MRV_AE_EXP_START */
/*****************************************************************************/
/**
 * register: isp_exp_h_offset: Horizontal offset for first block (0x00000004)
 *
 *****************************************************************************/
/* Slice: isp_exp_h_offset:*/
/* Horizontal offset of first block in pixels.*/
/* 0 <= value <= 3920 */
#ifdef MRV_AE_ISP_EXP_H_OFFSET
#define MRV_AE_ISP_EXP_H_OFFSET_MIN             0x00000000
#define MRV_AE_ISP_EXP_H_OFFSET_MAX             0x00000F50	/* 4096-176 */
#endif /* MRV_AE_ISP_EXP_H_OFFSET */
/*****************************************************************************/
/**
 * register: isp_exp_v_offset: Vertical offset for first block (0x00000008)
 *
 *****************************************************************************/
/* Slice: isp_exp_v_offset:*/
/* Vertical offset of first block in pixels.*/
/* 0 <= value <= 1806 */
#ifdef MRV_AE_ISP_EXP_V_OFFSET
#define MRV_AE_ISP_EXP_V_OFFSET_MIN             0x00000000
#define MRV_AE_ISP_EXP_V_OFFSET_MAX             0x00000B74	/* 3072-140 */
#endif /* MRV_AE_ISP_EXP_V_OFFSET */
/*****************************************************************************/
/**
 * register: isp_exp_h_size: Horizontal size of one block (0x0000000c)
 *
 *****************************************************************************/
/* Slice: isp_exp_h_size:*/
/* Horizontal size in pixels of one block.*/
/* 35 <= value <= 516 */
#ifdef MRV_AE_ISP_EXP_H_SIZE
#define MRV_AE_ISP_EXP_H_SIZE_MIN               0x00000023
#define MRV_AE_ISP_EXP_H_SIZE_MAX               0x00000333
#endif /* MRV_AE_ISP_EXP_H_SIZE */
/*****************************************************************************/
/**
 * register: isp_exp_v_size: Vertical size of one block (0x00000010)
 *
 *****************************************************************************/
/* Slice: isp_exp_v_size:*/
/* Vertical size in pixels of one block.*/
/* 28 <= value <= 390 */
#ifdef MRV_AE_ISP_EXP_V_SIZE
#define MRV_AE_ISP_EXP_V_SIZE_VALID_MASK        (MRV_AE_ISP_EXP_V_SIZE_MASK & ~0x00000001)
#define MRV_AE_ISP_EXP_V_SIZE_MIN               0x0000001C
#define MRV_AE_ISP_EXP_V_SIZE_MAX               0x00000266
#endif /* MRV_AE_ISP_EXP_V_SIZE */
/*****************************************************************************/
/**
 * register: isp_exp_mean_00: Mean luminance value of block 00 (0x00000014)
 *
 *****************************************************************************/
/* Slice: isp_exp_mean_00:*/
/* Mean luminance value of block 00 (x,y)*/
#ifdef MRV_AE_ISP_EXP_MEAN_00
#endif /* MRV_AE_ISP_EXP_MEAN_00 */
/*****************************************************************************/
/**
 * register: isp_exp_mean_10: Mean luminance value of block 10 (0x00000018)
 *
 *****************************************************************************/
/* Slice: isp_exp_mean_10:*/
/* Mean luminance value of block 10 (x,y)*/
#ifdef MRV_AE_ISP_EXP_MEAN_10
#endif /* MRV_AE_ISP_EXP_MEAN_10 */
/*****************************************************************************/
/**
 * register: isp_exp_mean_20: Mean luminance value of block 20 (0x0000001c)
 *
 *****************************************************************************/
/* Slice: isp_exp_mean_20:*/
/* Mean luminance value of block 20 (x,y)*/
#ifdef MRV_AE_ISP_EXP_MEAN_20
#endif /* MRV_AE_ISP_EXP_MEAN_20 */
/*****************************************************************************/
/**
 * register: isp_exp_mean_30: Mean luminance value of block 30 (0x00000020)
 *
 *****************************************************************************/
/* Slice: isp_exp_mean_30:*/
/* Mean luminance value of block 30 (x,y)*/
#ifdef MRV_AE_ISP_EXP_MEAN_30
#endif /* MRV_AE_ISP_EXP_MEAN_30 */
/*****************************************************************************/
/**
 * register: isp_exp_mean_40: Mean luminance value of block 40 (0x00000024)
 *
 *****************************************************************************/
/* Slice: isp_exp_mean_40:*/
/* Mean luminance value of block 40 (x,y)*/
#ifdef MRV_AE_ISP_EXP_MEAN_40
#endif /* MRV_AE_ISP_EXP_MEAN_40 */
/*****************************************************************************/
/**
 * register: isp_exp_mean_01: Mean luminance value of block 01 (0x00000028)
 *
 *****************************************************************************/
/* Slice: isp_exp_mean_01:*/
/* Mean luminance value of block 01 (x,y)*/
#ifdef MRV_AE_ISP_EXP_MEAN_01
#endif /* MRV_AE_ISP_EXP_MEAN_01 */
/*****************************************************************************/
/**
 * register: isp_exp_mean_11: Mean luminance value of block 11 (0x0000002c)
 *
 *****************************************************************************/
/* Register: isp_exp_mean_11: Mean luminance value of block 11 (0x0000002c)*/
/* Slice: isp_exp_mean_11:*/
/* Mean luminance value of block 11 (x,y)*/
#ifdef MRV_AE_ISP_EXP_MEAN_11
#endif /* MRV_AE_ISP_EXP_MEAN_11 */
/*****************************************************************************/
/**
 * register: isp_exp_mean_21: Mean luminance value of block 21 (0x00000030)
 *
 *****************************************************************************/
/* Slice: isp_exp_mean_21:*/
/* Mean luminance value of block 21 (x,y)*/
#ifdef MRV_AE_ISP_EXP_MEAN_21
#endif /* MRV_AE_ISP_EXP_MEAN_21 */
/*****************************************************************************/
/**
 * register: isp_exp_mean_31: Mean luminance value of block 31 (0x00000034)
 *
 *****************************************************************************/
/* Slice: isp_exp_mean_31:*/
/* Mean luminance value of block 31 (x,y)*/
#ifdef MRV_AE_ISP_EXP_MEAN_31
#endif /* MRV_AE_ISP_EXP_MEAN_31 */
/*****************************************************************************/
/**
 * register: isp_exp_mean_41: Mean luminance value of block 41 (0x00000038)
 *
 *****************************************************************************/
/* Slice: isp_exp_mean_41:*/
/* Mean luminance value of block 41 (x,y)*/
#ifdef MRV_AE_ISP_EXP_MEAN_41
#endif /* MRV_AE_ISP_EXP_MEAN_41 */
/*****************************************************************************/
/**
 * register: isp_exp_mean_02: Mean luminance value of block 02 (0x0000003c)
 *
 *****************************************************************************/
/* Slice: isp_exp_mean_02:*/
/* Mean luminance value of block 02 (x,y)*/
#ifdef MRV_AE_ISP_EXP_MEAN_02
#endif /* MRV_AE_ISP_EXP_MEAN_02 */
/*****************************************************************************/
/**
 * register: isp_exp_mean_12: Mean luminance value of block 12 (0x00000040)
 *
 *****************************************************************************/
/* Slice: isp_exp_mean_12:*/
/* Mean luminance value of block 12 (x,y)*/
#ifdef MRV_AE_ISP_EXP_MEAN_12
#endif /* MRV_AE_ISP_EXP_MEAN_12 */
/*****************************************************************************/
/**
 * register: isp_exp_mean_22: Mean luminance value of block 22 (0x00000044)
 *
 *****************************************************************************/
/* Slice: isp_exp_mean_22:*/
/* Mean luminance value of block 22 (x,y)*/
#ifdef MRV_AE_ISP_EXP_MEAN_22
#endif /* MRV_AE_ISP_EXP_MEAN_22 */
/*****************************************************************************/
/**
 * register: isp_exp_mean_32: Mean luminance value of block 32 (0x00000048)
 *
 *****************************************************************************/
/* Slice: isp_exp_mean_32:*/
/* Mean luminance value of block 32 (x,y)*/
#ifdef MRV_AE_ISP_EXP_MEAN_32
#endif /* MRV_AE_ISP_EXP_MEAN_32 */
/*****************************************************************************/
/**
 * register: isp_exp_mean_42: Mean luminance value of block 42 (0x0000004c)
 *
 *****************************************************************************/
/* Slice: isp_exp_mean_42:*/
/* Mean luminance value of block 42 (x,y)*/
#ifdef MRV_AE_ISP_EXP_MEAN_42
#endif /* MRV_AE_ISP_EXP_MEAN_42 */
/*****************************************************************************/
/**
 * register: isp_exp_mean_03: Mean luminance value of block 03 (0x00000050)
 *
 *****************************************************************************/
/* Slice: isp_exp_mean_03:*/
/* Mean luminance value of block 03 (x,y)*/
#ifdef MRV_AE_ISP_EXP_MEAN_03
#endif /* MRV_AE_ISP_EXP_MEAN_03 */
/*****************************************************************************/
/**
 * register: isp_exp_mean_13: Mean luminance value of block 13 (0x00000054)
 *
 *****************************************************************************/
/* Slice: isp_exp_mean_13:*/
/* Mean luminance value of block 13 (x,y)*/
#ifdef MRV_AE_ISP_EXP_MEAN_13
#endif /* MRV_AE_ISP_EXP_MEAN_13 */
/*****************************************************************************/
/**
 * register: isp_exp_mean_23: Mean luminance value of block 23 (0x00000058)
 *
 *****************************************************************************/
/* Slice: isp_exp_mean_23:*/
/* Mean luminance value of block 23 (x,y)*/
#ifdef MRV_AE_ISP_EXP_MEAN_23
#endif /* MRV_AE_ISP_EXP_MEAN_23 */
/*****************************************************************************/
/**
 * register: isp_exp_mean_33: Mean luminance value of block 33 (0x0000005c)
 *
 *****************************************************************************/
/* Slice: isp_exp_mean_33:*/
/* Mean luminance value of block 33 (x,y)*/
#ifdef MRV_AE_ISP_EXP_MEAN_33
#endif /* MRV_AE_ISP_EXP_MEAN_33 */
/*****************************************************************************/
/**
 * register: isp_exp_mean_43: Mean luminance value of block 43 (0x00000060)
 *
 *****************************************************************************/
/* Slice: isp_exp_mean_43:*/
/* Mean luminance value of block 43 (x,y)*/
#ifdef MRV_AE_ISP_EXP_MEAN_43
#endif /* MRV_AE_ISP_EXP_MEAN_43 */
/*****************************************************************************/
/**
 * register: isp_exp_mean_04: Mean luminance value of block 04 (0x00000064)
 *
 *****************************************************************************/
/* Slice: isp_exp_mean_04:*/
/* Mean luminance value of block 04 (x,y)*/
#ifdef MRV_AE_ISP_EXP_MEAN_04
#endif /* MRV_AE_ISP_EXP_MEAN_04 */
/*****************************************************************************/
/**
 * register: isp_exp_mean_14: Mean luminance value of block 14 (0x00000068)
 *
 *****************************************************************************/
/* Slice: isp_exp_mean_14:*/
/* Mean luminance value of block 14 (x,y)*/
#ifdef MRV_AE_ISP_EXP_MEAN_14
#endif /* MRV_AE_ISP_EXP_MEAN_14 */
/*****************************************************************************/
/**
 * register: isp_exp_mean_24: Mean luminance value of block 24 (0x0000006c)
 *
 *****************************************************************************/
/* Slice: isp_exp_mean_24:*/
/* Mean luminance value of block 24 (x,y)*/
#ifdef MRV_AE_ISP_EXP_MEAN_24
#endif /* MRV_AE_ISP_EXP_MEAN_24 */
/*****************************************************************************/
/**
 * register: isp_exp_mean_34: Mean luminance value of block 34 (0x00000070)
 *
 *****************************************************************************/
/* Slice: isp_exp_mean_34:*/
/* Mean luminance value of block 34 (x,y)*/
#ifdef MRV_AE_ISP_EXP_MEAN_34
#endif /* MRV_AE_ISP_EXP_MEAN_34 */
/*****************************************************************************/
/**
 * register: isp_exp_mean_44: Mean luminance value of block 44 (0x00000074)
 *
 *****************************************************************************/
/* Slice: isp_exp_mean_44:*/
/* Mean luminance value of block 44 (x,y)*/
#ifdef MRV_AE_ISP_EXP_MEAN_44
#endif /* MRV_AE_ISP_EXP_MEAN_44 */
/*****************************************************************************/
/* ISP Black Level Subtraction Registers                                     */
/*****************************************************************************/
/*****************************************************************************/
/**
 * register: isp_bls_ctrl: global control register (0x00000000)
 *
 *****************************************************************************/
/* Slice: WINDOW_ENABLE:*/
/* 0: no measuring is performed */
/* 1: only window 1 is measured */
/* 2: only window 2 is measured */
/* 3: both windows are measured */
#ifdef MRV_BLS_WINDOW_ENABLE
#define MRV_BLS_WINDOW_ENABLE_NONE              0U	/* 0: no measuring is performed */
#define MRV_BLS_WINDOW_ENABLE_WND1              1U	/* 1: only window 1 is measured */
#define MRV_BLS_WINDOW_ENABLE_WND2              2U	/* 2: only window 2 is measured */
#define MRV_BLS_WINDOW_ENABLE_BOTH              3U	/* 3: both windows are measured */
#define MRV_BLS_WINDOW_ENABLE_WND1_MASK         0x00000004U
#define MRV_BLS_WINDOW_ENABLE_WND1_SHIFT        2U
#define MRV_BLS_WINDOW_ENABLE_WND2_MASK         0x00000008U
#define MRV_BLS_WINDOW_ENABLE_WND2_SHIFT        3U
#endif /* MRV_BLS_WINDOW_ENABLE */
/* Slice: BLS_MODE:*/
/* 1: subtract measured values */
/* 0: subtract fixed values */
#ifdef MRV_BLS_BLS_MODE
#define MRV_BLS_BLS_MODE_MEAS                   1U	/* 1: subtract measured values */
#define MRV_BLS_BLS_MODE_FIX                    0U	/* 0: subtract fixed values */
#endif /* MRV_BLS_BLS_MODE */
/* Slice: BLS_ENABLE:*/
/* 1: black level subtraction is enabled */
/* 0: bypass the black level processing */
#ifdef MRV_BLS_BLS_ENABLE
#define MRV_BLS_BLS_ENABLE_PROCESS              1U	/* 1: black level subtraction is enabled */
#define MRV_BLS_BLS_ENABLE_BYPASS               0U	/* 0: bypass the black level processing */
#endif /* MRV_BLS_BLS_ENABLE */
/*****************************************************************************/
/**
 * register: isp_bls_samples: samples register (0x00000004)
 *
 *****************************************************************************/
/* Slice: BLS_SAMPLES:*/
/* This number to the power of two gives the number of measure samples for */
/* each Bayer position. Range 0x00: 2^0=1  to  0x12: 2^18=262144. This number */
/* is also the divider for the accumulator for each Bayer position.*/
     /**/
/* The accumulation will be stopped, if the number of measured pixels for the */
/* current Bayer position is equal to the number of samples.*/
     /**/
/* The measure windows must be positioned that way that the number of included */
/* pixels of each Bayer position included by both windows is equal or greater */
/* than the number of measure samples calculated by 2^BLS_SAMPLES !*/
     /**/
/* NOTE:*/
/* - The number of pixels of one Bayer position is 1/4 of the number of all */
/*   Pixels included by the measure windows.*/
#ifdef MRV_BLS_BLS_SAMPLES
#define MRV_BLS_BLS_SAMPLES_MAX                 (0x00000014U)	/* maximum is 2^20 = 1048576 */
#endif /* MRV_BLS_BLS_SAMPLES */
/*****************************************************************************/
/**
 * register: isp_bls_h1_start: window 1 horizontal start (0x00000008)
 *
 *****************************************************************************/
/* Slice: BLS_H1_START:*/
/* Black pixel window 1 horizontal start position */
#ifdef MRV_BLS_BLS_H1_START
#define MRV_BLS_BLS_H1_START_MAX                (MRV_BLS_BLS_H1_START_MASK >> MRV_BLS_BLS_H1_START_SHIFT)
#endif /* MRV_BLS_BLS_H1_START */
/*****************************************************************************/
/**
 * register: isp_bls_h1_stop: window 1 horizontal stop (0x0000000c)
 *
 *****************************************************************************/
/* Slice: BLS_H1_STOP:*/
/* Black pixel window 1 horizontal stop position */
#ifdef MRV_BLS_BLS_H1_STOP
#define MRV_BLS_BLS_H1_STOP_MAX                (MRV_BLS_BLS_H1_STOP_MASK >> MRV_BLS_BLS_H1_STOP_SHIFT)
#endif /* MRV_BLS_BLS_H1_STOP */
/*****************************************************************************/
/**
 * register: isp_bls_v1_start: window 1 vertical start (0x00000010)
 *
 *****************************************************************************/
/* Slice: BLS_V1_START:*/
/* Black pixel window 1 vertical start position */
#ifdef MRV_BLS_BLS_V1_START
#define MRV_BLS_BLS_V1_START_MAX                (MRV_BLS_BLS_V1_START_MASK >> MRV_BLS_BLS_V1_START_SHIFT)
#endif /* MRV_BLS_BLS_V1_START */
/*****************************************************************************/
/**
 * register: isp_bls_v1_stop: window 1 vertical stop (0x00000014)
 *
 *****************************************************************************/
/* Slice: BLS_V1_STOP:*/
/* Black pixel window 1 vertical stop position */
#ifdef MRV_BLS_BLS_V1_STOP
#define MRV_BLS_BLS_V1_STOP_MAX                 (MRV_BLS_BLS_V1_STOP_MASK >> MRV_BLS_BLS_V1_STOP_SHIFT)
#endif /* MRV_BLS_BLS_V1_STOP */
/*****************************************************************************/
/**
 * register: isp_bls_h2_start: window 2 horizontal start (0x00000018)
 *
 *****************************************************************************/
/* Slice: BLS_H2_START:*/
/* Black pixel window 2 horizontal start position */
#ifdef MRV_BLS_BLS_H2_START
#define MRV_BLS_BLS_H2_START_MAX                (MRV_BLS_BLS_H2_START_MASK >> MRV_BLS_BLS_H2_START_SHIFT)
#endif /* MRV_BLS_BLS_H2_START */
/*****************************************************************************/
/**
 * register: isp_bls_h2_stop: window 2 horizontal stop (0x0000001c)
 *
 *****************************************************************************/
/* Slice: BLS_H2_STOP:*/
/* Black pixel window 2 horizontal stop position */
#ifdef MRV_BLS_BLS_H2_STOP
#define MRV_BLS_BLS_H2_STOP_MAX                 (MRV_BLS_BLS_H2_STOP_MASK >> MRV_BLS_BLS_H2_STOP_SHIFT)
#endif /* MRV_BLS_BLS_H2_STOP */
/*****************************************************************************/
/**
 * register: isp_bls_v2_start: window 2 vertical start (0x00000020)
 *
 *****************************************************************************/
/* Slice: BLS_V2_START:*/
/* Black pixel window 2 vertical start position */
#ifdef MRV_BLS_BLS_V2_START
#define MRV_BLS_BLS_V2_START_MAX                (MRV_BLS_BLS_V2_START_MASK >> MRV_BLS_BLS_V2_START_SHIFT)
#endif /* MRV_BLS_BLS_V2_START */
/*****************************************************************************/
/**
 * register: isp_bls_v2_stop: window 2 vertical stop (0x00000024)
 *
 *****************************************************************************/
/* Slice: BLS_V2_STOP:*/
/* Black pixel window 2 vertical stop position */
#ifdef MRV_BLS_BLS_V2_STOP
#define MRV_BLS_BLS_V2_STOP_MAX                 (MRV_BLS_BLS_V2_STOP_MASK >> MRV_BLS_BLS_V2_STOP_SHIFT)
#endif /* MRV_BLS_BLS_V2_STOP */
/*****************************************************************************/
/**
 * register: isp_bls_a_fixed: fixed black level A (0x00000028)
 *
 *****************************************************************************/
/* Slice: BLS_A_FIXED:*/
/* Fixed black level for A pixels  signed */
/* two's complement, value range from -4096 to +4095,*/
/* a positive value will be subtracted from the pixel values */
#ifdef MRV_BLS_BLS_A_FIXED
#endif /* MRV_BLS_BLS_A_FIXED */
/*****************************************************************************/
/**
 * register: isp_bls_b_fixed: fixed black level B (0x0000002c)
 *
 *****************************************************************************/
/* Slice: BLS_B_FIXED:*/
/* Fixed black level for B pixels  signed */
/* two's complement, value range from -4096 to +4095 */
#ifdef MRV_BLS_BLS_B_FIXED
#endif /* MRV_BLS_BLS_B_FIXED */
/*****************************************************************************/
/**
 * register: isp_bls_c_fixed: fixed black level C (0x00000030)
 *
 *****************************************************************************/
/* Slice: BLS_C_FIXED:*/
/* Fixed black level for C pixels  signed */
/* two's complement, value range from -4096 to +4095 */
#ifdef MRV_BLS_BLS_C_FIXED
#endif /* MRV_BLS_BLS_C_FIXED */
/*****************************************************************************/
/**
 * register: isp_bls_d_fixed: fixed black level D (0x00000034)
 *
 *****************************************************************************/
/* Slice: BLS_D_FIXED:*/
/* Fixed black level for D pixels  - signed */
/* two's complement, value range from -4096 to +4095 */
#ifdef MRV_BLS_BLS_D_FIXED
#endif /* MRV_BLS_BLS_D_FIXED */
/*****************************************************************************/
/**
 * register: isp_bls_a_measured: measured black level A (0x00000038)
 *
 *****************************************************************************/
/* Slice: BLS_A_MEASURED:*/
/* Measured black level for A pixels */
#ifdef MRV_BLS_BLS_A_MEASURED
#endif /* MRV_BLS_BLS_A_MEASURED */
/*****************************************************************************/
/**
 * register: isp_bls_b_measured: measured black level B (0x0000003c)
 *
 *****************************************************************************/
/* Slice: BLS_B_MEASURED:*/
/* Measured black level for B pixels */
#ifdef MRV_BLS_BLS_B_MEASURED
#endif /* MRV_BLS_BLS_B_MEASURED */
/*****************************************************************************/
/**
 * register: isp_bls_c_measured: measured black level C (0x00000040)
 *
 *****************************************************************************/
/* Slice: BLS_C_MEASURED:*/
/* Measured black level for C pixels */
#ifdef MRV_BLS_BLS_C_MEASURED
#endif /* MRV_BLS_BLS_C_MEASURED */
/*****************************************************************************/
/**
 * register: isp_bls_d_measured: measured black level D (0x00000044)
 *
 *****************************************************************************/
/* Slice: BLS_D_MEASURED:*/
/* Measured black level for D pixels */
#ifdef MRV_BLS_BLS_D_MEASURED
#endif /* MRV_BLS_BLS_D_MEASURED */
/*****************************************************************************/
/* ISP Denoising Pre-Filter Registers                                        */
/*****************************************************************************/
/*****************************************************************************/
/**
 * register: isp_dpf_mode: Mode control for Denoising Pre-Filter block
 *           (0x00000000)
 *
 *****************************************************************************/
/* Slice: USE_NF_GAIN:*/
/* 1: dpf_nf_gain's will be used */
/* 0: external AWB gains will be used  *Default**/
#ifdef MRV_DPF_USE_NF_GAIN
#endif /* MRV_DPF_USE_NF_GAIN */
/* Slice: LSC_GAIN_COMP:*/
/* 1: LSC gain will be processed */
/* 0: LSC gain will not be processed  *Default**/
#ifdef MRV_DPF_LSC_GAIN_COMP
#endif /* MRV_DPF_LSC_GAIN_COMP */
/* Slice: AWB_GAIN_COMP:*/
/* 1: AWB gain or internal dpf_nf_gain will be processed */
/* 0: AWB gain or internal dpf_nf_gain will not be processed  *Default**/
#ifdef MRV_DPF_AWB_GAIN_COMP
#endif /* MRV_DPF_AWB_GAIN_COMP */
/* Slice: NLL_SEGMENTATION:*/
/* 1: optimized logarithmic like segmentation for Noise Level Lookup (NLL)*/
/* 0: equidistant segmentation for NLL  *Default**/
#ifdef MRV_DPF_NLL_SEGMENTATION
#endif /* MRV_DPF_NLL_SEGMENTATION */
/* Slice: RB_FILTER_SIZE:*/
/* 1: Red and Blue filter kernel size of 9x9 (5x5 active) pixels */
/* 0: Wide Red and Blue filter kernel size of 13x9 (7x5 active) pixels  *Default**/
#ifdef MRV_DPF_RB_FILTER_SIZE
#endif /* MRV_DPF_RB_FILTER_SIZE */
/* Slice: R_FILTER_OFF:*/
/* 1: disable filter processing for red pixels (R)*/
/* 0: filter R pixels  *Default**/
#ifdef MRV_DPF_R_FILTER_OFF
#endif /* MRV_DPF_R_FILTER_OFF */
/* Slice: GR_FILTER_OFF:*/
/* 1: disable filter processing for green pixels in green/red lines (GR)*/
/* 0: filter GR pixels  *Default**/
#ifdef MRV_DPF_GR_FILTER_OFF
#endif /* MRV_DPF_GR_FILTER_OFF */
/* Slice: GB_FILTER_OFF:*/
/* 1: disable filter processing for green pixels in green/blue lines (GB)*/
/* 0: filter GB pixels  *Default**/
#ifdef MRV_DPF_GB_FILTER_OFF
#endif /* MRV_DPF_GB_FILTER_OFF */
/* Slice: B_FILTER_OFF:*/
/* 1: disable filter processing for blue pixels (B)*/
/* 0: filter B pixels  *Default**/
#ifdef MRV_DPF_B_FILTER_OFF
#endif /* MRV_DPF_B_FILTER_OFF */
/* Slice: DPF_ENABLE:*/
/* 1: enable dpf */
/* 0: bypass dpf  *Default**/
#ifdef MRV_DPF_DPF_ENABLE
#endif /* MRV_DPF_DPF_ENABLE */
/*****************************************************************************/
/**
 * register: isp_dpf_strength_r: filter strength of the RED filter (0x00000004)
 *
 *****************************************************************************/
/* Slice: INV_WEIGHT_R:*/
/* Filter strength of the filter is determined by weight. Default is a */
/* weight of 1. A higher weight increases the filter strength. In this */
/* register the unsigned 8 bit value 64/weight is stored.*/
     /**/
/* The following values show examples:*/
/*  weight=0.251    -> 255, weight=0.5 -> 128,*/
/*  weight=1        -> 64 *default**/
/*  weight=1.25     -> 51, weight=1.5 -> 42,*/
/*  weight=1.75     -> 37, weight=2 -> 32 */
#ifdef MRV_DPF_INV_WEIGHT_R
#endif /* MRV_DPF_INV_WEIGHT_R */
/*****************************************************************************/
/**
 * register: isp_dpf_strength_g: filter strength of the GREEN filter (0x00000008)
 *
 *****************************************************************************/
/* Slice: INV_WEIGHT_G:*/
/* Filter strength of the filter is determined by weight. Default is a */
/* weight of 1. A higher weight increases the filter strength. In this */
/* register the unsigned 8 bit value 64/weight is stored.*/
     /**/
/* The following values show examples:*/
/*  weight=0.251    -> 255, weight=0.5 -> 128,*/
/*  weight=1        -> 64 *default**/
/*  weight=1.25     -> 51, weight=1.5 -> 42,*/
/*  weight=1.75     -> 37, weight=2 -> 32 */
#ifdef MRV_DPF_INV_WEIGHT_G
#endif /* MRV_DPF_INV_WEIGHT_G */
/*****************************************************************************/
/**
 * register: isp_dpf_strength_b: filter strength of the BLUE filter (0x0000000c)
 *
 *****************************************************************************/
/* Slice: INV_WEIGHT_B:*/
/* Filter strength of the filter is determined by weight. Default is a */
/* weight of 1. A higher weight increases the filter strength. In this */
/* register the unsigned 8 bit value 64/weight is stored.*/
     /**/
/* The following values show examples:*/
/*  weight=0.251    -> 255, weight=0.5 -> 128,*/
/*  weight=1        -> 64 *default**/
/*  weight=1.25     -> 51, weight=1.5 -> 42,*/
/*  weight=1.75     -> 37, weight=2 -> 32 */
#ifdef MRV_DPF_INV_WEIGHT_B
#endif /* MRV_DPF_INV_WEIGHT_B */
/*****************************************************************************/
/**
 * register: isp_dpf_s_weight_g_1_4: Spatial Weights green channel 1 2 3 4
 *           (0x00000010)
 *
 *****************************************************************************/
/* Slice: S_WEIGHT_G4:*/
/* Filter Coefficient green channel S_WEIGHT_G4 */
/* 5 bit unsigned, value range 1/16 to 16/16 */
/* Default value is 16/16 (*Default*)*/
#ifdef MRV_DPF_S_WEIGHT_G4
#endif /* MRV_DPF_S_WEIGHT_G4 */
/* Slice: S_WEIGHT_G3:*/
/* Filter Coefficient green channel S_WEIGHT_G3 */
/* 5 bit unsigned, value range 1/16 to 16/16 */
/* Default value is 16/16 (*Default*)*/
#ifdef MRV_DPF_S_WEIGHT_G3
#endif /* MRV_DPF_S_WEIGHT_G3 */
/* Slice: S_WEIGHT_G2:*/
/* Filter Coefficient green channel S_WEIGHT_G2 */
/* 5 bit unsigned, value range 1/16 to 16/16 */
/* Default value is 16/16 (*Default*)*/
#ifdef MRV_DPF_S_WEIGHT_G2
#endif /* MRV_DPF_S_WEIGHT_G2 */
/* Slice: S_WEIGHT_G1:*/
/* Filter Coefficient green channel S_WEIGHT_G1 */
/* 5 bit unsigned, value range 1/16 to 16/16 */
/* Default value is 16/16 (*Default*)*/
#ifdef MRV_DPF_S_WEIGHT_G1
#endif /* MRV_DPF_S_WEIGHT_G1 */
/*****************************************************************************/
/**
 * register: isp_dpf_s_weight_g_5_6: Spatial Weights green channel 5 6
 *           (0x00000014)
 *
 *****************************************************************************/
/* Slice: S_WEIGHT_G6:*/
/* Filter Coefficient green channel S_WEIGHT_G6 */
/* 5 bit unsigned, value range 1/16 to 16/16 */
/* Default value is 16/16 (*Default*)*/
#ifdef MRV_DPF_S_WEIGHT_G6
#endif /* MRV_DPF_S_WEIGHT_G6 */
/* Slice: S_WEIGHT_G5:*/
/* Filter Coefficient green channel S_WEIGHT_G5 */
/* 5 bit unsigned, value range 1/16 to 16/16 */
/* Default value is 16/16 (*Default*)*/
#ifdef MRV_DPF_S_WEIGHT_G5
#endif /* MRV_DPF_S_WEIGHT_G5 */
/*****************************************************************************/
/**
 * register: isp_dpf_s_weight_rb_1_4: Spatial Weights red/blue channels 1 2 3 4
 *           (0x00000018)
 *
 *****************************************************************************/
/* Slice: S_WEIGHT_RB4:*/
/* Filter Coefficient red/blue channels S_WEIGHT_RB4 */
/* 5 bit unsigned, value range 1/16 to 16/16 */
/* Default value is 16/16 (*Default*)*/
#ifdef MRV_DPF_S_WEIGHT_RB4
#endif /* MRV_DPF_S_WEIGHT_RB4 */
/* Slice: S_WEIGHT_RB3:*/
/* Filter Coefficient red/blue channels S_WEIGHT_RB3 */
/* 5 bit unsigned, value range 1/16 to 16/16 */
/* Default value is 16/16 (*Default*)*/
#ifdef MRV_DPF_S_WEIGHT_RB3
#endif /* MRV_DPF_S_WEIGHT_RB3 */
/* Slice: S_WEIGHT_RB2:*/
/* Filter Coefficient red/blue channels S_WEIGHT_RB2 */
/* 5 bit unsigned, value range 1/16 to 16/16 */
/* Default value is 16/16 (*Default*)*/
#ifdef MRV_DPF_S_WEIGHT_RB2
#endif /* MRV_DPF_S_WEIGHT_RB2 */
/* Slice: S_WEIGHT_RB1:*/
/* Filter Coefficient red/blue channels S_WEIGHT_RB1 */
/* 5 bit unsigned, value range 1/16 to 16/16 */
/* Default value is 16/16 (*Default*)*/
#ifdef MRV_DPF_S_WEIGHT_RB1
#endif /* MRV_DPF_S_WEIGHT_RB1 */
/*****************************************************************************/
/**
 * register: isp_dpf_s_weight_rb_5_6: Spatial Weights red/blue channels 5 6
 *           (0x0000001c)
 *
 *****************************************************************************/
/* Slice: S_WEIGHT_RB6:*/
/* Filter Coefficient red/blue channels S_WEIGHT_RB6 */
/* 5 bit unsigned, value range 1/16 to 16/16 */
/* Default value is 16/16 (*Default*)*/
#ifdef MRV_DPF_S_WEIGHT_RB6
#endif /* MRV_DPF_S_WEIGHT_RB6 */
/* Slice: S_WEIGHT_RB5:*/
/* Filter Coefficient red/blue channels S_WEIGHT_RB5 */
/* 5 bit unsigned, value range 1/16 to 16/16 */
/* Default value is 16/16 (*Default*)*/
#ifdef MRV_DPF_S_WEIGHT_RB5
#endif /* MRV_DPF_S_WEIGHT_RB5 */
/*****************************************************************************/
/**
 * register array: isp_dpf_nll_coeff: Noise Level Lookup Coefficient
 *                 (0x0040 + n*0x4 (n=0..16))
 *
 *****************************************************************************/
/* Slice: nll_coeff_n:*/
/* Noise Level Lookup Table Coefficient nll_coeff_n */
/* 10 bit unsigned, value range 1/1024 to 1023/1024 (*Default*)*/
#ifdef MRV_DPF_NLL_COEFF_N
#endif /* MRV_DPF_NLL_COEFF_N */
/*****************************************************************************/
/**
 * register: isp_dpf_nf_gain_r: noise function gain for red pixels (0x00000064)
 *
 *****************************************************************************/
/* Slice: DPF_NF_GAIN_R:*/
/* Noise Function (NF) Gain that replaces the AWB gain for red pixels.*/
/* 12 bit unsigned integer format: gain=1 -> 0x100 */
#ifdef MRV_DPF_DPF_NF_GAIN_R
#endif /* MRV_DPF_DPF_NF_GAIN_R */
/*****************************************************************************/
/**
 * register: isp_dpf_nf_gain_gr: noise function gain for green in red pixels
 *           (0x00000068)
 *
 *****************************************************************************/
/* Slice: DPF_NF_GAIN_GR:*/
/* Noise Function (NF) Gain that replaces the AWB gain for green pixels in a */
/* red line.*/
/* 12 bit unsigned integer format: gain=1 -> 0x100 */
#ifdef MRV_DPF_DPF_NF_GAIN_GR
#endif /* MRV_DPF_DPF_NF_GAIN_GR */
/*****************************************************************************/
/**
 * register: isp_dpf_nf_gain_gb: noise function gain for green in blue pixels
 *           (0x0000006c)
 *
 *****************************************************************************/
/* Slice: DPF_NF_GAIN_GB:*/
/* Noise Function (NF) Gain that replaces the AWB gain for green pixels in a */
/* blue line.*/
/* 12 bit unsigned integer format: gain=1 -> 0x100 */
#ifdef MRV_DPF_DPF_NF_GAIN_GB
#endif /* MRV_DPF_DPF_NF_GAIN_GB */
/*****************************************************************************/
/**
 * register: isp_dpf_nf_gain_b: noise function gain for blue pixels (0x00000070)
 *
 *****************************************************************************/
/* Slice: DPF_NF_GAIN_B:*/
/* Noise Function (NF) Gain that replaces the AWB gain for blue pixels.*/
/* 12 bit unsigned integer format: gain=1 -> 0x100 */
#ifdef MRV_DPF_DPF_NF_GAIN_B
#endif /* MRV_DPF_DPF_NF_GAIN_B */
/*****************************************************************************/
/* ISP Defect Pixel Cluster Correction Registers                             */
/*****************************************************************************/
/*****************************************************************************/
/**
 * register: isp_dpcc_mode: mode control for DPCC block (0x0000)
 *
 *****************************************************************************/
/* Slice: STAGE1_ENABLE:*/
/* 1: enable  stage1 *Default**/
/* 0: bypass  stage1 */
#ifdef MRV_DPCC_STAGE1_ENABLE
#endif /* MRV_DPCC_STAGE1_ENABLE */
/* Slice: GRAYSCALE_MODE:*/
/* 1: enable gray scale data input from black and white sensors (without color filter array)*/
/* 0: BAYER DATA INPUT  *Default**/
#ifdef MRV_DPCC_GRAYSCALE_MODE
#endif /* MRV_DPCC_GRAYSCALE_MODE */
/* Slice: ISP_DPCC_enable:*/
/* 1: enable DPCC */
/* 0: bypass DPCC  *Default**/
#ifdef MRV_DPCC_ISP_DPCC_ENABLE
#endif /* MRV_DPCC_ISP_DPCC_ENABLE */
/*****************************************************************************/
/**
 * register: isp_dpcc_output_mode: interpolation mode for correction unit
 *           (0x00000004)
 *
 *****************************************************************************/
/* Slice: STAGE1_RB_3x3:*/
/* 1: stage1 red/blue 9 pixel (3x3) output median */
/* 0: stage1 red/blue 4 or 5 pixel output median  *Default**/
#ifdef MRV_DPCC_STAGE1_RB_3X3
#endif /* MRV_DPCC_STAGE1_RB_3X3 */
/* Slice: STAGE1_G_3x3:*/
/* 1: stage1 green 9 pixel (3x3) output median */
/* 0: stage1 green 4 or 5 pixel output median  *Default**/
#ifdef MRV_DPCC_STAGE1_G_3X3
#endif /* MRV_DPCC_STAGE1_G_3X3 */
/* Slice: STAGE1_INCL_RB_CENTER:*/
/* 1: stage1 include center pixel for red/blue output median 2x2+1 */
/* *Default* 0: stage1 do not include center pixel for red/blue output median 2x2 */
#ifdef MRV_DPCC_STAGE1_INCL_RB_CENTER
#endif /* MRV_DPCC_STAGE1_INCL_RB_CENTER */
/* Slice: STAGE1_INCL_GREEN_CENTER:*/
/* 1: stage1 include center pixel for green output median 2x2+1 *Default**/
/* 0: stage1 do not include center pixel for green output median 2x2 */
#ifdef MRV_DPCC_STAGE1_INCL_GREEN_CENTER
#endif /* MRV_DPCC_STAGE1_INCL_GREEN_CENTER */
/*****************************************************************************/
/**
 * register: isp_dpcc_set_use: DPCC methods set usage for detection
 *           (0x00000008)
 *
 *****************************************************************************/
/* Slice: STAGE1_USE_FIX_SET:*/
/* 1: stage1 use hard coded methods set *Default**/
/* 0: stage1 do not use hard coded methods set */
#ifdef MRV_DPCC_STAGE1_USE_FIX_SET
#endif /* MRV_DPCC_STAGE1_USE_FIX_SET */
/* Slice: STAGE1_USE_SET_3:*/
/* 1: stage1 use methods set 3 */
/* 0: stage1 do not use methods set 3 *Default**/
#ifdef MRV_DPCC_STAGE1_USE_SET_3
#endif /* MRV_DPCC_STAGE1_USE_SET_3 */
/* Slice: STAGE1_USE_SET_2:*/
/* 1: stage1 use methods set 2 */
/* 0: stage1 do not use methods set 2 *Default**/
#ifdef MRV_DPCC_STAGE1_USE_SET_2
#endif /* MRV_DPCC_STAGE1_USE_SET_2 */
/* Slice: STAGE1_USE_SET_1:*/
/* 1: stage1 use methods set 1  *Default**/
/* 0: stage1 do not use methods set 1 */
#ifdef MRV_DPCC_STAGE1_USE_SET_1
#endif /* MRV_DPCC_STAGE1_USE_SET_1 */
/*****************************************************************************/
/**
 * register: isp_dpcc_methods_set_1: Methods enable bits for SET_1
 *           (0x0000000c)
 *
 *****************************************************************************/
/* Slice: RG_RED_BLUE1_ENABLE:*/
/* 1: enable Rank Gradient check for red_blue  *Default**/
/* 0: bypass Rank Gradient check for red_blue */
#ifdef MRV_DPCC_RG_RED_BLUE1_ENABLE
#endif /* MRV_DPCC_RG_RED_BLUE1_ENABLE */
/* Slice: RND_RED_BLUE1_ENABLE:*/
/* 1: enable Rank Neighbor Difference check for red_blue  *Default**/
/* 0: bypass Rank Neighbor Difference check for red_blue */
#ifdef MRV_DPCC_RND_RED_BLUE1_ENABLE
#endif /* MRV_DPCC_RND_RED_BLUE1_ENABLE */
/* Slice: RO_RED_BLUE1_ENABLE:*/
/* 1: enable Rank Order check for red_blue  *Default**/
/* 0: bypass Rank Order check for red_blue */
#ifdef MRV_DPCC_RO_RED_BLUE1_ENABLE
#endif /* MRV_DPCC_RO_RED_BLUE1_ENABLE */
/* Slice: LC_RED_BLUE1_ENABLE:*/
/* 1: enable Line check for red_blue *Default**/
/* 0: bypass Line check for red_blue */
#ifdef MRV_DPCC_LC_RED_BLUE1_ENABLE
#endif /* MRV_DPCC_LC_RED_BLUE1_ENABLE */
/* Slice: PG_RED_BLUE1_ENABLE:*/
/* 1: enable Peak Gradient check for red_blue  *Default**/
/* 0: bypass Peak Gradient check for red_blue */
#ifdef MRV_DPCC_PG_RED_BLUE1_ENABLE
#endif /* MRV_DPCC_PG_RED_BLUE1_ENABLE */
/* Slice: RG_GREEN1_ENABLE:*/
/* 1: enable Rank Gradient check for green  *Default**/
/* 0: bypass Rank Gradient check for green */
#ifdef MRV_DPCC_RG_GREEN1_ENABLE
#endif /* MRV_DPCC_RG_GREEN1_ENABLE */
/* Slice: RND_GREEN1_ENABLE:*/
/* 1: enable Rank Neighbor Difference check for green  *Default**/
/* 0: bypass Rank Neighbor Difference check for green */
#ifdef MRV_DPCC_RND_GREEN1_ENABLE
#endif /* MRV_DPCC_RND_GREEN1_ENABLE */
/* Slice: RO_GREEN1_ENABLE:*/
/* 1: enable Rank Order check for green  *Default**/
/* 0: bypass Rank Order check for green */
#ifdef MRV_DPCC_RO_GREEN1_ENABLE
#endif /* MRV_DPCC_RO_GREEN1_ENABLE */
/* Slice: LC_GREEN1_ENABLE:*/
/* 1: enable Line check for green *Default**/
/* 0: bypass Line check for green */
#ifdef MRV_DPCC_LC_GREEN1_ENABLE
#endif /* MRV_DPCC_LC_GREEN1_ENABLE */
/* Slice: PG_GREEN1_ENABLE:*/
/* 1: enable Peak Gradient check for green  *Default**/
/* 0: bypass Peak Gradient check for green */
#ifdef MRV_DPCC_PG_GREEN1_ENABLE
#endif /* MRV_DPCC_PG_GREEN1_ENABLE */
/*****************************************************************************/
/**
 * register: isp_dpcc_methods_set_2: Methods enable bits for SET_2
 *           (0x00000010)
 *
 *****************************************************************************/
/* Slice: RG_RED_BLUE2_ENABLE:*/
/* 1: enable Rank Gradient check for red_blue  *Default**/
/* 0: bypass Rank Gradient check for red_blue */
#ifdef MRV_DPCC_RG_RED_BLUE2_ENABLE
#endif /* MRV_DPCC_RG_RED_BLUE2_ENABLE */
/* Slice: RND_RED_BLUE2_ENABLE:*/
/* 1: enable Rank Neighbor Difference check for red_blue  *Default**/
/* 0: bypass Rank Neighbor Difference check for red_blue */
#ifdef MRV_DPCC_RND_RED_BLUE2_ENABLE
#endif /* MRV_DPCC_RND_RED_BLUE2_ENABLE */
/* Slice: RO_RED_BLUE2_ENABLE:*/
/* 1: enable Rank Order check for red_blue  *Default**/
/* 0: bypass Rank Order check for red_blue */
#ifdef MRV_DPCC_RO_RED_BLUE2_ENABLE
#endif /* MRV_DPCC_RO_RED_BLUE2_ENABLE */
/* Slice: LC_RED_BLUE2_ENABLE:*/
/* 1: enable Line check for red_blue *Default**/
/* 0: bypass Line check for red_blue */
#ifdef MRV_DPCC_LC_RED_BLUE2_ENABLE
#endif /* MRV_DPCC_LC_RED_BLUE2_ENABLE */
/* Slice: PG_RED_BLUE2_ENABLE:*/
/* 1: enable Peak Gradient check for red_blue  *Default**/
/* 0: bypass Peak Gradient check for red_blue */
#ifdef MRV_DPCC_PG_RED_BLUE2_ENABLE
#endif /* MRV_DPCC_PG_RED_BLUE2_ENABLE */
/* Slice: RG_GREEN2_ENABLE:*/
/* 1: enable Rank Gradient check for green  *Default**/
/* 0: bypass Rank Gradient check for green */
#ifdef MRV_DPCC_RG_GREEN2_ENABLE
#endif /* MRV_DPCC_RG_GREEN2_ENABLE */
/* Slice: RND_GREEN2_ENABLE:*/
/* 1: enable Rank Neighbor Difference check for green  *Default**/
/* 0: bypass Rank Neighbor Difference check for green */
#ifdef MRV_DPCC_RND_GREEN2_ENABLE
#endif /* MRV_DPCC_RND_GREEN2_ENABLE */
/* Slice: RO_GREEN2_ENABLE:*/
/* 1: enable Rank Order check for green  *Default**/
/* 0: bypass Rank Order check for green */
#ifdef MRV_DPCC_RO_GREEN2_ENABLE
#endif /* MRV_DPCC_RO_GREEN2_ENABLE */
/* Slice: LC_GREEN2_ENABLE:*/
/* 1: enable Line check for green *Default**/
/* 0: bypass Line check for green */
#ifdef MRV_DPCC_LC_GREEN2_ENABLE
#endif /* MRV_DPCC_LC_GREEN2_ENABLE */
/* Slice: PG_GREEN2_ENABLE:*/
/* 1: enable Peak Gradient check for green  *Default**/
/* 0: bypass Peak Gradient check for green */
#ifdef MRV_DPCC_PG_GREEN2_ENABLE
#endif /* MRV_DPCC_PG_GREEN2_ENABLE */
/*****************************************************************************/
/**
 * register: isp_dpcc_methods_set_3: Methods enable bits for SET_3
 *           (0x00000014)
 *
 *****************************************************************************/
/* Slice: RG_RED_BLUE3_ENABLE:*/
/* 1: enable Rank Gradient check for red_blue  *Default**/
/* 0: bypass Rank Gradient check for red_blue */
#ifdef MRV_DPCC_RG_RED_BLUE3_ENABLE
#endif /* MRV_DPCC_RG_RED_BLUE3_ENABLE */
/* Slice: RND_RED_BLUE3_ENABLE:*/
/* 1: enable Rank Neighbor Difference check for red_blue  *Default**/
/* 0: bypass Rank Neighbor Difference check for red_blue */
#ifdef MRV_DPCC_RND_RED_BLUE3_ENABLE
#endif /* MRV_DPCC_RND_RED_BLUE3_ENABLE */
/* Slice: RO_RED_BLUE3_ENABLE:*/
/* 1: enable Rank Order check for red_blue  *Default**/
/* 0: bypass Rank Order check for red_blue */
#ifdef MRV_DPCC_RO_RED_BLUE3_ENABLE
#endif /* MRV_DPCC_RO_RED_BLUE3_ENABLE */
/* Slice: LC_RED_BLUE3_ENABLE:*/
/* 1: enable Line check for red_blue *Default**/
/* 0: bypass Line check for red_blue */
#ifdef MRV_DPCC_LC_RED_BLUE3_ENABLE
#endif /* MRV_DPCC_LC_RED_BLUE3_ENABLE */
/* Slice: PG_RED_BLUE3_ENABLE:*/
/* 1: enable Peak Gradient check for red_blue  *Default**/
/* 0: bypass Peak Gradient check for red_blue */
#ifdef MRV_DPCC_PG_RED_BLUE3_ENABLE
#endif /* MRV_DPCC_PG_RED_BLUE3_ENABLE */
/* Slice: RG_GREEN3_ENABLE:*/
/* 1: enable Rank Gradient check for green  *Default**/
/* 0: bypass Rank Gradient check for green */
#ifdef MRV_DPCC_RG_GREEN3_ENABLE
#endif /* MRV_DPCC_RG_GREEN3_ENABLE */
/* Slice: RND_GREEN3_ENABLE:*/
/* 1: enable Rank Neighbor Difference check for green  *Default**/
/* 0: bypass Rank Neighbor Difference check for green */
#ifdef MRV_DPCC_RND_GREEN3_ENABLE
#endif /* MRV_DPCC_RND_GREEN3_ENABLE */
/* Slice: RO_GREEN3_ENABLE:*/
/* 1: enable Rank Order check for green  *Default**/
/* 0: bypass Rank Order check for green */
#ifdef MRV_DPCC_RO_GREEN3_ENABLE
#endif /* MRV_DPCC_RO_GREEN3_ENABLE */
/* Slice: LC_GREEN3_ENABLE:*/
/* 1: enable Line check for green *Default**/
/* 0: bypass Line check for green */
#ifdef MRV_DPCC_LC_GREEN3_ENABLE
#endif /* MRV_DPCC_LC_GREEN3_ENABLE */
/* Slice: PG_GREEN3_ENABLE:*/
/* 1: enable Peak Gradient check for green  *Default**/
/* 0: bypass Peak Gradient check for green */
#ifdef MRV_DPCC_PG_GREEN3_ENABLE
#endif /* MRV_DPCC_PG_GREEN3_ENABLE */
/*****************************************************************************/
/**
 * register: isp_dpcc_line_thresh_1: Line threshold SET_1 (0x00000018)
 *
 *****************************************************************************/
/* Slice: LINE_THR_1_RB:*/
/* line threshold for set 1 red/blue */
#ifdef MRV_DPCC_LINE_THR_1_RB
#endif /* MRV_DPCC_LINE_THR_1_RB */
/* Slice: LINE_THR_1_G:*/
/* line threshold for set 1 green */
#ifdef MRV_DPCC_LINE_THR_1_G
#endif /* MRV_DPCC_LINE_THR_1_G */
/*****************************************************************************/
/**
 * register: isp_dpcc_line_mad_fac_1: Mean Absolute Difference (MAD) factor
 *           for Line check set 1 (0x0000001c)
 *
 *****************************************************************************/
/* Slice: LINE_MAD_FAC_1_RB:*/
/* line MAD factor for set 1 red/blue */
#ifdef MRV_DPCC_LINE_MAD_FAC_1_RB
#endif /* MRV_DPCC_LINE_MAD_FAC_1_RB */
/* Slice: LINE_MAD_FAC_1_G:*/
/* line MAD factor for set 1 green */
#ifdef MRV_DPCC_LINE_MAD_FAC_1_G
#endif /* MRV_DPCC_LINE_MAD_FAC_1_G */
/*****************************************************************************/
/**
 * register: isp_dpcc_pg_fac_1: Peak gradient factor for set 1 (0x00000020)
 *
 *****************************************************************************/
/* Slice: PG_FAC_1_RB:*/
/* Peak gradient factor for set 1 red/blue */
#ifdef MRV_DPCC_PG_FAC_1_RB
#endif /* MRV_DPCC_PG_FAC_1_RB */
/* Slice: PG_FAC_1_G:*/
/* Peak gradient factor for set 1 green */
#ifdef MRV_DPCC_PG_FAC_1_G
#endif /* MRV_DPCC_PG_FAC_1_G */
/*****************************************************************************/
/**
 * register: isp_dpcc_rnd_thresh_1: Rank Neighbor Difference threshold for
 *           set 1 (0x00000024)
 *
 *****************************************************************************/
/* Slice: RND_THR_1_RB:*/
/* Rank Neighbor Difference threshold for set 1 red/blue */
#ifdef MRV_DPCC_RND_THR_1_RB
#endif /* MRV_DPCC_RND_THR_1_RB */
/* Slice: RND_THR_1_G:*/
/* Rank Neighbor Difference threshold for set 1 green */
#ifdef MRV_DPCC_RND_THR_1_G
#endif /* MRV_DPCC_RND_THR_1_G */
/*****************************************************************************/
/**
 * register: isp_dpcc_rg_fac_1: Rank gradient factor for set 1 (0x00000028)
 *
 *****************************************************************************/
/* Slice: RG_FAC_1_RB:*/
/* Rank gradient factor for set 1 red/blue */
#ifdef MRV_DPCC_RG_FAC_1_RB
#endif /* MRV_DPCC_RG_FAC_1_RB */
/* Slice: RG_FAC_1_G:*/
/* Rank gradient factor for set 1 green */
#ifdef MRV_DPCC_RG_FAC_1_G
#endif /* MRV_DPCC_RG_FAC_1_G */
/*****************************************************************************/
/**
 * register: isp_dpcc_line_thresh_2: Line threshold SET_2 (0x0000002C)
 *
 *****************************************************************************/
/* Slice: LINE_THR_2_RB:*/
/* line threshold for set 1 red/blue */
#ifdef MRV_DPCC_LINE_THR_2_RB
#endif /* MRV_DPCC_LINE_THR_2_RB */
/* Slice: LINE_THR_2_G:*/
/* line threshold for set 1 green */
#ifdef MRV_DPCC_LINE_THR_2_G
#endif /* MRV_DPCC_LINE_THR_2_G */
/*****************************************************************************/
/**
 * register: isp_dpcc_line_mad_fac_2: Mean Absolute Difference (MAD) factor
 *           for Line check set 1 (0x00000030)
 *
 *****************************************************************************/
/* Slice: LINE_MAD_FAC_2_RB:*/
/* line MAD factor for set 1 red/blue */
#ifdef MRV_DPCC_LINE_MAD_FAC_2_RB
#endif /* MRV_DPCC_LINE_MAD_FAC_2_RB */
/* Slice: LINE_MAD_FAC_2_G:*/
/* line MAD factor for set 1 green */
#ifdef MRV_DPCC_LINE_MAD_FAC_2_G
#endif /* MRV_DPCC_LINE_MAD_FAC_2_G */
/*****************************************************************************/
/**
 * register: isp_dpcc_pg_fac_2: Peak gradient factor for set 1 (0x00000034)
 *
 *****************************************************************************/
/* Slice: PG_FAC_2_RB:*/
/* Peak gradient factor for set 1 red/blue */
#ifdef MRV_DPCC_PG_FAC_2_RB
#endif /* MRV_DPCC_PG_FAC_2_RB */
/* Slice: PG_FAC_2_G:*/
/* Peak gradient factor for set 1 green */
#ifdef MRV_DPCC_PG_FAC_2_G
#endif /* MRV_DPCC_PG_FAC_2_G */
/*****************************************************************************/
/**
 * register: isp_dpcc_rnd_thresh_2: Rank Neighbor Difference threshold for
 *           set 1 (0x00000038)
 *
 *****************************************************************************/
/* Slice: RND_THR_2_RB:*/
/* Rank Neighbor Difference threshold for set 1 red/blue */
#ifdef MRV_DPCC_RND_THR_2_RB
#endif /* MRV_DPCC_RND_THR_2_RB */
/* Slice: RND_THR_2_G:*/
/* Rank Neighbor Difference threshold for set 1 green */
#ifdef MRV_DPCC_RND_THR_2_G
#endif /* MRV_DPCC_RND_THR_2_G */
/*****************************************************************************/
/**
 * register: isp_dpcc_rg_fac_2: Rank gradient factor for set 1 (0x0000003C)
 *
 *****************************************************************************/
/* Slice: RG_FAC_2_RB:*/
/* Rank gradient factor for set 1 red/blue */
#ifdef MRV_DPCC_RG_FAC_2_RB
#endif /* MRV_DPCC_RG_FAC_2_RB */
/* Slice: RG_FAC_2_G:*/
/* Rank gradient factor for set 1 green */
#ifdef MRV_DPCC_RG_FAC_2_G
#endif /* MRV_DPCC_RG_FAC_2_G */
/*****************************************************************************/
/**
 * register: isp_dpcc_line_thresh_3: Line threshold SET_3 (0x00000040)
 *
 *****************************************************************************/
/* Slice: LINE_THR_3_RB:*/
/* line threshold for set 1 red/blue */
#ifdef MRV_DPCC_LINE_THR_3_RB
#endif /* MRV_DPCC_LINE_THR_3_RB */
/* Slice: LINE_THR_3_G:*/
/* line threshold for set 1 green */
#ifdef MRV_DPCC_LINE_THR_3_G
#endif /* MRV_DPCC_LINE_THR_3_G */
/*****************************************************************************/
/**
 * register: isp_dpcc_line_mad_fac_3: Mean Absolute Difference (MAD) factor
 *           for Line check set 1 (0x00000044)
 *
 *****************************************************************************/
/* Slice: LINE_MAD_FAC_3_RB:*/
/* line MAD factor for set 1 red/blue */
#ifdef MRV_DPCC_LINE_MAD_FAC_3_RB
#endif /* MRV_DPCC_LINE_MAD_FAC_3_RB */
/* Slice: LINE_MAD_FAC_3_G:*/
/* line MAD factor for set 1 green */
#ifdef MRV_DPCC_LINE_MAD_FAC_3_G
#endif /* MRV_DPCC_LINE_MAD_FAC_3_G */
/*****************************************************************************/
/**
 * register: isp_dpcc_pg_fac_3: Peak gradient factor for set 1 (0x00000048)
 *
 *****************************************************************************/
/* Slice: PG_FAC_3_RB:*/
/* Peak gradient factor for set 1 red/blue */
#ifdef MRV_DPCC_PG_FAC_3_RB
#endif /* MRV_DPCC_PG_FAC_3_RB */
/* Slice: PG_FAC_3_G:*/
/* Peak gradient factor for set 1 green */
#ifdef MRV_DPCC_PG_FAC_3_G
#endif /* MRV_DPCC_PG_FAC_3_G */
/*****************************************************************************/
/**
 * register: isp_dpcc_rnd_thresh_3: Rank Neighbor Difference threshold for
 *           set 1 (0x0000004C)
 *
 *****************************************************************************/
/* Slice: RND_THR_3_RB:*/
/* Rank Neighbor Difference threshold for set 1 red/blue */
#ifdef MRV_DPCC_RND_THR_3_RB
#endif /* MRV_DPCC_RND_THR_3_RB */
/* Slice: RND_THR_3_G:*/
/* Rank Neighbor Difference threshold for set 1 green */
#ifdef MRV_DPCC_RND_THR_3_G
#endif /* MRV_DPCC_RND_THR_3_G */
/*****************************************************************************/
/**
 * register: isp_dpcc_rg_fac_3: Rank gradient factor for set 1 (0x00000050)
 *
 *****************************************************************************/
/* Slice: RG_FAC_3_RB:*/
/* Rank gradient factor for set 1 red/blue */
#ifdef MRV_DPCC_RG_FAC_3_RB
#endif /* MRV_DPCC_RG_FAC_3_RB */
/* Slice: RG_FAC_3_G:*/
/* Rank gradient factor for set 1 green */
#ifdef MRV_DPCC_RG_FAC_3_G
#endif /* MRV_DPCC_RG_FAC_3_G */
/*****************************************************************************/
/**
 * register: isp_dpcc_ro_limits: Rank Order Limits (0x00000054)
 *
 *****************************************************************************/
/* Slice: RO_LIM_3_RB:*/
/* Rank order limit for set 3 red/blue */
#ifdef MRV_DPCC_RO_LIM_3_RB
#endif /* MRV_DPCC_RO_LIM_3_RB */
/* Slice: RO_LIM_3_G:*/
/* Rank order limit for set 3 green */
#ifdef MRV_DPCC_RO_LIM_3_G
#endif /* MRV_DPCC_RO_LIM_3_G */
/* Slice: RO_LIM_2_RB:*/
/* Rank order limit for set 2 red/blue */
#ifdef MRV_DPCC_RO_LIM_2_RB
#endif /* MRV_DPCC_RO_LIM_2_RB */
/* Slice: RO_LIM_2_G:*/
/* Rank order limit for set 2 green */
#ifdef MRV_DPCC_RO_LIM_2_G
#endif /* MRV_DPCC_RO_LIM_2_G */
/* Slice: RO_LIM_1_RB:*/
/* Rank order limit for set 1 red/blue */
#ifdef MRV_DPCC_RO_LIM_1_RB
#endif /* MRV_DPCC_RO_LIM_1_RB */
/* Slice: RO_LIM_1_G:*/
/* Rank order limit for set 1 green */
#ifdef MRV_DPCC_RO_LIM_1_G
#endif /* MRV_DPCC_RO_LIM_1_G */
/*****************************************************************************/
/**
 * register: isp_dpcc_rnd_offs: Differential Rank Offsets for Rank Neighbor
 *           Difference (0x00000058)
 *
 *****************************************************************************/
/* Slice: RND_OFFS_3_RB:*/
/* Rank Offset to Neighbor for set 3 red/blue */
#ifdef MRV_DPCC_RND_OFFS_3_RB
#endif /* MRV_DPCC_RND_OFFS_3_RB */
/* Slice: RND_OFFS_3_G:*/
/* Rank Offset to Neighbor for set 3 green */
#ifdef MRV_DPCC_RND_OFFS_3_G
#endif /* MRV_DPCC_RND_OFFS_3_G */
/* Slice: RND_OFFS_2_RB:*/
/* Rank Offset to Neighbor for set 2 red/blue */
#ifdef MRV_DPCC_RND_OFFS_2_RB
#endif /* MRV_DPCC_RND_OFFS_2_RB */
/* Slice: RND_OFFS_2_G:*/
/* Rank Offset to Neighbor for set 2 green */
#ifdef MRV_DPCC_RND_OFFS_2_G
#endif /* MRV_DPCC_RND_OFFS_2_G */
/* Slice: RND_OFFS_1_RB:*/
/* Rank Offset to Neighbor for set 1 red/blue */
#ifdef MRV_DPCC_RND_OFFS_1_RB
#endif /* MRV_DPCC_RND_OFFS_1_RB */
/* Slice: RND_OFFS_1_G:*/
/* Rank Offset to Neighbor for set 1 green */
#ifdef MRV_DPCC_RND_OFFS_1_G
#endif /* MRV_DPCC_RND_OFFS_1_G */
/*****************************************************************************/
/**
 * register: isp_dpcc_bpt_ctrl: bad pixel table settings (0x0000005c)
 *
 *****************************************************************************/
/* Slice: BPT_RB_3x3:*/
/* 1: if BPT active red/blue 9 pixel (3x3) output median */
/* 0: if BPT active red/blue 4 or 5 pixel output median  *Default**/
#ifdef MRV_DPCC_BPT_RB_3X3
#endif /* MRV_DPCC_BPT_RB_3X3 */
/* Slice: BPT_G_3x3:*/
/* 1: if BPT active green 9 pixel (3x3) output median */
/* 0: if BPT active green 4 or 5 pixel output median  *Default**/
#ifdef MRV_DPCC_BPT_G_3X3
#endif /* MRV_DPCC_BPT_G_3X3 */
/* Slice: BPT_INCL_RB_CENTER:*/
/* 1: if BPT active include center pixel for red/blue output median 2x2+1 */
/* 0: if BPT active do not include center pixel for red/blue output median 2x2 *Default**/
#ifdef MRV_DPCC_BPT_INCL_RB_CENTER
#endif /* MRV_DPCC_BPT_INCL_RB_CENTER */
/* Slice: BPT_INCL_GREEN_CENTER:*/
/* 1: if BPT active include center pixel for green output median 2x2+1 */
/* 0: if BPT active do not include center pixel for green output median 2x2 *Default**/
#ifdef MRV_DPCC_BPT_INCL_GREEN_CENTER
#endif /* MRV_DPCC_BPT_INCL_GREEN_CENTER */
/* Slice: BPT_USE_FIX_SET:*/
/* 1: for BPT write use hard coded methods set */
/* 0: for BPT write do not use hard coded methods set *Default**/
#ifdef MRV_DPCC_BPT_USE_FIX_SET
#endif /* MRV_DPCC_BPT_USE_FIX_SET */
/* Slice: BPT_USE_SET_3:*/
/* 1: for BPT write use methods set 3 */
/* 0: for BPT write do not use methods set 3 *Default**/
#ifdef MRV_DPCC_BPT_USE_SET_3
#endif /* MRV_DPCC_BPT_USE_SET_3 */
/* Slice: BPT_USE_SET_2:*/
/* 1: for BPT write use methods set 2 */
/* 0: for BPT write do not use methods set 2 *Default**/
#ifdef MRV_DPCC_BPT_USE_SET_2
#endif /* MRV_DPCC_BPT_USE_SET_2 */
/* Slice: BPT_USE_SET_1:*/
/* 1: for BPT write use methods set 1 */
/* 0: for BPT write do not use methods set 1 *Default**/
#ifdef MRV_DPCC_BPT_USE_SET_1
#endif /* MRV_DPCC_BPT_USE_SET_1 */
/* Slice: bpt_cor_en:*/
/* table based correction enable */
/* 1: table based correction is enabled */
/* 0: table based correction is disabled */
#ifdef MRV_DPCC_BPT_COR_EN
#endif /* MRV_DPCC_BPT_COR_EN */
/* Slice: bpt_det_en:*/
/* Bad pixel detection write enable */
/* 1: bad pixel detection write to memory is enabled */
/* 0: bad pixel detection write to memory is disabled */
#ifdef MRV_DPCC_BPT_DET_EN
#endif /* MRV_DPCC_BPT_DET_EN */
/*****************************************************************************/
/**
 * register: isp_dpcc_bpt_addr: TABLE Start Address for table-based correction
 *           algorithm (0x00000064)
 *
 *****************************************************************************/
/* Slice: bp_table_addr:*/
/* Table RAM start address for read or write operations. The address counter */
/* is incremented at each read or write access to the data register (auto-*/
/* increment mechanism).*/
#ifdef MRV_DPCC_BP_TABLE_ADDR
#endif /* MRV_DPCC_BP_TABLE_ADDR */
/*****************************************************************************/
/**
 * register: isp_dpcc_bpt_data: TABLE DATA register for read and write access
 *           of table RAM (0x00000068)
 *
 *****************************************************************************/
/* Slice: bpt_v_addr:*/
/* Bad Pixel vertical address (pixel position)*/
#ifdef MRV_DPCC_BPT_V_ADDR
#endif /* MRV_DPCC_BPT_V_ADDR */
/* Slice: bpt_h_addr:*/
/* Bad Pixel horizontal address (pixel position)*/
#ifdef MRV_DPCC_BPT_H_ADDR
#endif /* MRV_DPCC_BPT_H_ADDR */
/*****************************************************************************/
/* ISP Wide Dynamic Range                                                    */
/*****************************************************************************/
/*****************************************************************************/
/**
 * register: isp_wdr_ctrl: Control Bits for Wide Dynamic Range Unit (0x00000000)
 *
 *****************************************************************************/
/* Slice: WDR_RGB_FACTOR:*/
/* rgb_factor defines how much influence the RGBmax approach has in comparison */
/* to Y. The illumination reference Iref is calculated according to the following */
/* formula:*/
     /**/
/* Iref = (WDR_RGB_FACTOR * RGBYmax_tr + (8 - WDR_RGB_FACTOR) * Y) / 8 */
     /**/
/* So, rgb_factor = 0 means that the standard approach is used. Use of this */
/* factor requires that Iref has been selected, see WDR_USE_IREF.*/
     /**/
/* Value range of rgb_factor: 0...8 */
#ifdef MRV_WDR_RGB_FACTOR
#endif /* MRV_WDR_RGB_FACTOR */
/* Slice: WDR_DISABLE_TRANSIENT:*/
/* 1: disable transient between Y and RGBY_max */
/* 0: calculate transient between Y and RGBY_max (for noise reduction) *Default**/
/* Use of this bit requires that Iref has been selected, see WDR_USE_IREF.*/
#ifdef MRV_WDR_DISABLE_TRANSIENT
#endif /* MRV_WDR_DISABLE_TRANSIENT */
/* Slice: WDR_USE_RGB7_8:*/
/* 1: decrease RGBmax by 7/8 (for noise reduction)*/
/* 0: do not modify RGBmax *Default**/
/* Use of this bit requires that Iref has been selected, see WDR_USE_IREF.*/
#ifdef MRV_WDR_USE_RGB7_8
#endif /* MRV_WDR_USE_RGB7_8 */
/* Slice: WDR_USE_Y9_8:*/
/* 1: use R G B and Y*9/8 for maximum value calculation (for noise reduction)*/
/* 0: only use R G B for maximum value calculation (RGBYmax approach)  *Default**/
/* Use of this bit requires that Iref has been selected, see WDR_USE_IREF.*/
#ifdef MRV_WDR_USE_Y9_8
#endif /* MRV_WDR_USE_Y9_8 */
/* Slice: WDR_USE_IREF:*/
/* 1: use Iref (Illumination reference) instead of Y for ToneMapping and Gain calculation */
/* 0: use Y for ToneMapping and Gain calculation  *Default**/
/* Iref is calculated according to the following formula:*/
/* Iref = (WDR_RGB_FACTOR * RGBmax_tr + (8 - WDR_RGB_FACTOR) * Y) / 8 */
#ifdef MRV_WDR_USE_IREF
#endif /* MRV_WDR_USE_IREF */
/* Slice: WDR_CR_MAPPING_DISABLE:*/
/* 1: disable (bypass) Chrominance Mapping */
/* 0: enable Chrominance Mapping  *Default**/
/* requires that Luminance/chrominance color space has been selected */
#ifdef MRV_WDR_CR_MAPPING_DISABLE
#endif /* MRV_WDR_CR_MAPPING_DISABLE */
/* Slice: WDR_COLOR_SPACE_SELECT:*/
/* 1: R, G, B color space */
/* 0: Luminance/Chrominance color space  *Default**/
#ifdef MRV_WDR_COLOR_SPACE_SELECT
#endif /* MRV_WDR_COLOR_SPACE_SELECT */
/* Slice: WDR_ENABLE:*/
/* 1: enable WDR */
/* 0: bypass WDR  *Default**/
#ifdef MRV_WDR_ENABLE
#endif /* MRV_WDR_ENABLE */
/*****************************************************************************/
/**
 * register: isp_wdr_tonecurve_1: Tone Curve sample points dYn definition
 *           (part 1) (0x00000004)
 *
 *           isp_wdr_tonecurve_1_shd: Tone Curve sample points dYn definition
 *           shadow register (part 1) (0x000000a0)
 *
 *****************************************************************************/
/* Slice: WDR_dY8:*/
/* Tone curve sample point definition dY8 on the horizontal axis (input)*/
#ifdef MRV_WDR_DY8
#endif /* MRV_WDR_DY8 */
/* Slice: WDR_dY7:*/
/* Tone curve sample point definition dY7 on the horizontal axis (input)*/
#ifdef MRV_WDR_DY7
#endif /* MRV_WDR_DY7 */
/* Slice: WDR_dY6:*/
/* Tone curve sample point definition dY6 on the horizontal axis (input)*/
#ifdef MRV_WDR_DY6
#endif /* MRV_WDR_DY6 */
/* Slice: WDR_dY5:*/
/* Tone curve sample point definition dY5 on the horizontal axis (input)*/
#ifdef MRV_WDR_DY5
#endif /* MRV_WDR_DY5 */
/* Slice: WDR_dY4:*/
/* Tone curve sample point definition dY4 on the horizontal axis (input)*/
#ifdef MRV_WDR_DY4
#endif /* MRV_WDR_DY4 */
/* Slice: WDR_dY3:*/
/* Tone curve sample point definition dY3 on the horizontal axis (input)*/
#ifdef MRV_WDR_DY3
#endif /* MRV_WDR_DY3 */
/* Slice: WDR_dY2:*/
/* Tone curve sample point definition dY2 on the horizontal axis (input)*/
#ifdef MRV_WDR_DY2
#endif /* MRV_WDR_DY2 */
/* Slice: WDR_dY1:*/
/* Tone curve sample point definition dY1 on the horizontal axis (input)*/
#ifdef MRV_WDR_DY1
#endif /* MRV_WDR_DY1 */
/*****************************************************************************/
/**
 * register: isp_wdr_tonecurve_2: Tone Curve sample points dYn definition
 *           (part 2) (0x00000008)
 *
 *           isp_wdr_tonecurve_2_shd: Tone Curve sample points dYn definition
 *           shadow register (part 2) (0x000000a4)
 *
 *****************************************************************************/
/* Slice: WDR_dY16:*/
/* Tone curve sample point definition dY16 on the horizontal axis (input)*/
#ifdef MRV_WDR_DY16
#endif /* MRV_WDR_DY16 */
/* Slice: WDR_dY15:*/
/* Tone curve sample point definition dY15 on the horizontal axis (input)*/
#ifdef MRV_WDR_DY15
#endif /* MRV_WDR_DY15 */
/* Slice: WDR_dY14:*/
/* Tone curve sample point definition dY14 on the horizontal axis (input)*/
#ifdef MRV_WDR_DY14
#endif /* MRV_WDR_DY14 */
/* Slice: WDR_dY13:*/
/* Tone curve sample point definition dY13 on the horizontal axis (input)*/
#ifdef MRV_WDR_DY13
#endif /* MRV_WDR_DY13 */
/* Slice: WDR_dY12:*/
/* Tone curve sample point definition dY12 on the horizontal axis (input)*/
#ifdef MRV_WDR_DY12
#endif /* MRV_WDR_DY12 */
/* Slice: WDR_dY11:*/
/* Tone curve sample point definition dY11 on the horizontal axis (input)*/
#ifdef MRV_WDR_DY11
#endif /* MRV_WDR_DY11 */
/* Slice: WDR_dY10:*/
/* Tone curve sample point definition dY10 on the horizontal axis (input)*/
#ifdef MRV_WDR_DY10
#endif /* MRV_WDR_DY10 */
/* Slice: WDR_dY9:*/
/* Tone curve sample point definition dY9 on the horizontal axis (input)*/
#ifdef MRV_WDR_DY9
#endif /* MRV_WDR_DY9 */
/*****************************************************************************/
/**
 * register: isp_wdr_tonecurve_3: Tone Curve sample points dYn definition
 *           (part 3) (0x0000000c)
 *
 *           isp_wdr_tonecurve_3_shd: Tone Curve sample points dYn definition
 *           shadow register (part 3) (0x000000a8)
 *
 *****************************************************************************/
/* Slice: WDR_dY24:*/
/* Tone curve sample point definition dY24 on the horizontal axis (input)*/
#ifdef MRV_WDR_DY24
#endif /* MRV_WDR_DY24 */
/* Slice: WDR_dY23:*/
/* Tone curve sample point definition dY23 on the horizontal axis (input)*/
#ifdef MRV_WDR_DY23
#endif /* MRV_WDR_DY23 */
/* Slice: WDR_dY22:*/
/* Tone curve sample point definition dY22 on the horizontal axis (input)*/
#ifdef MRV_WDR_DY22
#endif /* MRV_WDR_DY22 */
/* Slice: WDR_dY21:*/
/* Tone curve sample point definition dY21 on the horizontal axis (input)*/
#ifdef MRV_WDR_DY21
#endif /* MRV_WDR_DY21 */
/* Slice: WDR_dY20:*/
/* Tone curve sample point definition dY20 on the horizontal axis (input)*/
#ifdef MRV_WDR_DY20
#endif /* MRV_WDR_DY20 */
/* Slice: WDR_dY19:*/
/* Tone curve sample point definition dY19 on the horizontal axis (input)*/
#ifdef MRV_WDR_DY19
#endif /* MRV_WDR_DY19 */
/* Slice: WDR_dY18:*/
/* Tone curve sample point definition dY18 on the horizontal axis (input)*/
#ifdef MRV_WDR_DY18
#endif /* MRV_WDR_DY18 */
/* Slice: WDR_dY17:*/
/* Tone curve sample point definition dY17 on the horizontal axis (input)*/
#ifdef MRV_WDR_DY17
#endif /* MRV_WDR_DY17 */
/*****************************************************************************/
/**
 * register: isp_wdr_tonecurve_4: Tone Curve sample points dYn definition
 *           (part 4) (0x00000010)
 *
 *           isp_wdr_tonecurve_4_shd: Tone Curve sample points dYn definition
 *           shadow register(part 4) (0x000000ac)
 *
 *****************************************************************************/
/* Slice: WDR_dY32:*/
/* Tone curve sample point definition dY32 on the horizontal axis (input)*/
#ifdef MRV_WDR_DY32
#endif /* MRV_WDR_DY32 */
/* Slice: WDR_dY31:*/
/* Tone curve sample point definition dY31 on the horizontal axis (input)*/
#ifdef MRV_WDR_DY31
#endif /* MRV_WDR_DY31 */
/* Slice: WDR_dY30:*/
/* Tone curve sample point definition dY30 on the horizontal axis (input)*/
#ifdef MRV_WDR_DY30
#endif /* MRV_WDR_DY30 */
/* Slice: WDR_dY29:*/
/* Tone curve sample point definition dY29 on the horizontal axis (input)*/
#ifdef MRV_WDR_DY29
#endif /* MRV_WDR_DY29 */
/* Slice: WDR_dY28:*/
/* Tone curve sample point definition dY28 on the horizontal axis (input)*/
#ifdef MRV_WDR_DY28
#endif /* MRV_WDR_DY28 */
/* Slice: WDR_dY27:*/
/* Tone curve sample point definition dY27 on the horizontal axis (input)*/
#ifdef MRV_WDR_DY27
#endif /* MRV_WDR_DY27 */
/* Slice: WDR_dY26:*/
/* Tone curve sample point definition dY26 on the horizontal axis (input)*/
#ifdef MRV_WDR_DY26
#endif /* MRV_WDR_DY26 */
/* Slice: WDR_dY25:*/
/* Tone curve sample point definition dY25 on the horizontal axis (input)*/
#ifdef MRV_WDR_DY25
#endif /* MRV_WDR_DY25 */
/*****************************************************************************/
/**
 * register array: isp_wdr_tonecurve_ym: Tonemapping curve coefficient Ym_
 *                 (0x0028 + n*0x4 (n=0..32))
 *
 *****************************************************************************/
/* Slice: tonecurve_ym_n:*/
/* Tone curve value definition y-axis (output) of WDR unit */
#ifdef MRV_WDR_TONECURVE_YM_N
#endif /* MRV_WDR_TONECURVE_YM_N */
/*****************************************************************************/
/**
 * register: isp_wdr_offset: Offset values for RGB path (0x00000098)
 *
 *****************************************************************************/
/* Slice: LUM_OFFSET:*/
/* Luminance Offset value (a) for RGB operation mode */
/* unsigned 12 bit value */
#ifdef MRV_WDR_LUM_OFFSET
#endif /* MRV_WDR_LUM_OFFSET */
/* Slice: RGB_OFFSET:*/
/* RGB Offset value (b) for RGB operation mode */
/* unsigned 12 bit value */
#ifdef MRV_WDR_RGB_OFFSET
#endif /* MRV_WDR_RGB_OFFSET */
/*****************************************************************************/
/**
 * register: isp_wdr_deltamin: DeltaMin Threshold and Strength factor (0x0000009c)
 *
 *****************************************************************************/
/* Slice: DMIN_STRENGTH:*/
/* strength factor for DMIN */
/* unsigned 5 bit value, range 0x00...0x10 */
#ifdef MRV_WDR_DMIN_STRENGTH
#endif /* MRV_WDR_DMIN_STRENGTH */
/* Slice: DMIN_THRESH:*/
/* Lower threshold for deltaMin value */
/* unsigned 12 bit value */
#ifdef MRV_WDR_DMIN_THRESH
#endif /* MRV_WDR_DMIN_THRESH */
/*****************************************************************************/
/**
 * register array: isp_wdr_tonecurve_ym_shd: Tonemapping curve coefficient
 *                 shadow register (0x0160 + n*0x4 (n=0..32))
 *
 *****************************************************************************/
/* Slice: tonecurve_ym_n_shd:*/
/* Tone curve value definition y-axis (output) of WDR unit */
/* shadow register.*/
#ifdef MRV_WDR_TONECURVE_YM_N_SHD
#endif /* MRV_WDR_TONECURVE_YM_N_SHD */
/*****************************************************************************/
/* ISP Elliptic Auto White Balance Registers                                 */
/*****************************************************************************/
/*****************************************************************************/
/**
 * register: awb_meas_mode: AWB Measure Mode (0x00000000)
 *
 *****************************************************************************/
/*! Register: awb_meas_mode: AWB Measure Mode (0x00000000)*/
/*! Slice: AWB_union_e5_and_e8:*/
/*! unite ellipse 5 with ellipse 8. Accu and count for ellipse 8.*/
#ifdef ISP_AWB_UNION_E5_AND_E8
#define ISP_AWB_UNION_E5_AND_E8_ON              1	/* 1: enable unite ellipse 5 with ellipse 8 */
#define ISP_AWB_UNION_E5_AND_E8_OFF             0	/* 0: disable unite ellipse 5 with ellipse 8 */
#endif /* ISP_AWB_UNION_E5_AND_E8 */
/*! Slice: AWB_union_e5_and_e7:*/
/*! unite ellipse 5 with ellipse 7. Accu and count for ellipse 7.*/
#ifdef ISP_AWB_UNION_E5_AND_E7
#define ISP_AWB_UNION_E5_AND_E7_ON              1	/* 1: enable unite ellipse 5 with ellipse 7 */
#define ISP_AWB_UNION_E5_AND_E7_OFF             0	/* 0: disable unite ellipse 5 with ellipse 7 */
#endif /* ISP_AWB_UNION_E5_AND_E7 */
/*! Slice: AWB_union_e5_and_e6:*/
/*! unite ellipse 5 with ellipse 6. Accu and count for ellipse 6.*/
#ifdef ISP_AWB_UNION_E5_AND_E6
#define ISP_AWB_UNION_E5_AND_E6_ON              1	/* 1: enable unite ellipse 5 with ellipse 6 */
#define ISP_AWB_UNION_E5_AND_E6_OFF             0	/* 0: disable unite ellipse 5 with ellipse 6 */
#endif /* ISP_AWB_UNION_E5_AND_E6 */
/*! Slice: AWB_union_e1_and_e4:*/
/*! unite ellipse 1 with ellipse 4. Accu and count for ellipse 4.*/
#ifdef ISP_AWB_UNION_E1_AND_E4
#define ISP_AWB_UNION_E1_AND_E4_ON              1	/* 1: enable unite ellipse 1 with ellipse 4 */
#define ISP_AWB_UNION_E1_AND_E4_OFF             0	/* 0: disable unite ellipse 1 with ellipse 4 */
#endif /* ISP_AWB_UNION_E1_AND_E4 */
/*! Slice: AWB_union_e1_and_e3:*/
/*! unite ellipse 1 with ellipse 3. Accu and count for ellipse 3.*/
#ifdef ISP_AWB_UNION_E1_AND_E3
#define ISP_AWB_UNION_E1_AND_E3_ON              1	/* 1: enable unite ellipse 1 with ellipse 3 */
#define ISP_AWB_UNION_E1_AND_E3_OFF             0	/* 0: disable unite ellipse 1 with ellipse 3 */
#endif /* ISP_AWB_UNION_E1_AND_E3 */
/*! Slice: AWB_union_e1_and_e2:*/
/*! unite ellipse 1 with ellipse 2. Accu and count for ellipse 2.*/
#ifdef ISP_AWB_UNION_E1_AND_E2
#define ISP_AWB_UNION_E1_AND_E2_ON              1	/* 1: enable unite ellipse 1 with ellipse 2 */
#define ISP_AWB_UNION_E1_AND_E2_OFF             0	/* 0: disable unite ellipse 1 with ellipse 2 */
#endif /* ISP_AWB_UNION_E1_AND_E2 */
/*! Slice: AWB_meas_chrom_switch:*/
/*! Accumulates Q1 and Q2 chromaticies instead of R, G, B color signals. Results are written on AWB_ACCU registers as well.*/
#ifdef ISP_AWB_MEAS_CHROM_SWITCH
#define ISP_AWB_MEAS_CHROM_SWITCH_ON            1	/* 1: accumulates Q1 and Q2 chromaticies */
#define ISP_AWB_MEAS_CHROM_SWITCH_OFF           0	/* 0: accumulates R, G, B color signals */
#endif /* ISP_AWB_MEAS_CHROM_SWITCH */
/* Slice: AWB_meas_irq_enable:*/
/* AWB measure done IRQ enable.*/
#ifdef ISP_AWB_MEAS_IRQ_ENABLE
#define ISP_AWB_MEAS_IRQ_ENABLE_ON              1	/* 1: enable measuring done irq */
#define ISP_AWB_MEAS_IRQ_ENABLE_OFF             0	/* 0: enable measuring done irq */
#endif /* ISP_AWB_MEAS_IRQ_ENABLE */
/* Slice: AWB_pre_filt_en:*/
/* median pre filter enable.*/
#ifdef ISP_AWB_PRE_FILT_EN
#define ISP_AWB_PRE_FILT_EN_ON                  1	/* 1: enable median pre filter */
#define ISP_AWB_PRE_FILT_EN_OFF                 0	/* 0: disable median pre filter */
#endif /* ISP_AWB_PRE_FILT_EN */
/* Slice: AWB_meas_en:*/
/* enable measure.*/
#ifdef ISP_AWB_MEAS_EN
#define ISP_AWB_MEAS_EN_ON                      1	/* 1: enable measuring */
#define ISP_AWB_MEAS_EN_OFF                     0	/* 0: disable measuring */
#endif /* ISP_AWB_MEAS_EN */
/*****************************************************************************/
/**
 * register: awb_meas_h_offs: AWB window horizontal offset (0x00000004)
 *
 *****************************************************************************/
/* Slice: AWB_h_offset:*/
/* Horizontal offset in pixels.*/
#ifdef ISP_AWB_H_OFFSET
#define ISP_AWB_H_OFFSET_MIN                    0U
#define ISP_AWB_H_OFFSET_MAX                    (ISP_AWB_H_OFFSET_MASK >> ISP_AWB_H_OFFSET_SHIFT)
#endif /* ISP_AWB_H_OFFSET */
/*****************************************************************************/
/**
 * register: awb_meas_v_offs: AWB window vertical offset (0x00000008)
 *
 *****************************************************************************/
/* Slice: AWB_v_offset:*/
/* Vertical offset in pixels.*/
#ifdef ISP_AWB_V_OFFSET
#define ISP_AWB_V_OFFSET_MIN                    0U
#define ISP_AWB_V_OFFSET_MAX                    (ISP_AWB_V_OFFSET_MASK >> ISP_AWB_V_OFFSET_SHIFT)
#endif /* ISP_AWB_V_OFFSET */
/*****************************************************************************/
/**
 * register: awb_meas_h_size: Horizontal window size (0x0000000c)
 *
 *****************************************************************************/
/* Slice: AWB_h_size:*/
/* Horizontal size in pixels.*/
#ifdef ISP_AWB_H_SIZE
#define ISP_AWB_H_SIZE_MIN                      0U
#define ISP_AWB_H_SIZE_MAX                      (ISP_AWB_H_SIZE_MASK >> ISP_AWB_H_SIZE_SHIFT)
#endif /* ISP_AWB_H_SIZE */
/*****************************************************************************/
/**
 * register: awb_meas_v_size: Vertical window size (0x00000010)
 *
 *****************************************************************************/
/* Slice: AWB_v_size:*/
/* Vertical size.*/
#ifdef ISP_AWB_V_SIZE
#define ISP_AWB_V_SIZE_MIN                      0U
#define ISP_AWB_V_SIZE_MAX                      (ISP_AWB_V_SIZE_MASK >> ISP_AWB_V_SIZE_SHIFT)
#endif /* ISP_AWB_V_SIZE */
/*****************************************************************************/
/**
 * register: awb_meas_r_min_max: Min Max Compare Red (0x00000014)
 *
 *****************************************************************************/
/* Slice: r_max:*/
/* max red value */
#ifdef ISP_AWB_R_MAX
#endif /* ISP_AWB_R_MAX */
/* Slice: r_min:*/
/* min red value */
#ifdef ISP_AWB_R_MIN
#endif /* ISP_AWB_R_MIN */
/*****************************************************************************/
/**
 * register: awb_meas_g_min_max: Min Max Compare Green (0x00000018)
 *
 *****************************************************************************/
/* Slice: g_max:*/
/* max green value */
#ifdef ISP_AWB_G_MAX
#endif /* ISP_AWB_G_MAX */
/* Slice: g_min:*/
/* min green value */
#ifdef ISP_AWB_G_MIN
#endif /* ISP_AWB_G_MIN */
/*****************************************************************************/
/**
 * register: awb_meas_b_min_max: Min Max Compare Blue (0x0000001c)
 *
 *****************************************************************************/
/* Slice: b_max:*/
/* max blue value */
#ifdef ISP_AWB_B_MAX
#endif /* ISP_AWB_B_MAX */
/*! Slice: b_min:*/
/*! min blue value */
#ifdef ISP_AWB_B_MIN
#endif /* ISP_AWB_B_MIN */
/*****************************************************************************/
/**
 * register: awb_meas_divider_min: Min Compare Divider (0x00000020)
 *
 *****************************************************************************/
/* Slice: div_min:*/
/* min divider value unsigned integer with 10 fractional Bits range 0 to 0.999 */
#ifdef ISP_AWB_DIV_MIN
#endif /* ISP_AWB_DIV_MIN */
/*****************************************************************************/
/**
 * register: awb_meas_csc_coeff_0: Color conversion coefficient 0 (0x00000024)
 *
 *****************************************************************************/
/* Slice: cc_coeff_0:*/
/* coefficient 0 for color space conversion */
#ifdef ISP_AWB_CC_COEFF_0
#endif /* ISP_AWB_CC_COEFF_0 */
/*****************************************************************************/
/**
 * register: awb_meas_csc_coeff_1: Color conversion coefficient 1 (0x00000028)
 *
 *****************************************************************************/
/* Slice: cc_coeff_1:*/
/* coefficient 1 for color space conversion */
#ifdef ISP_AWB_CC_COEFF_1
#endif /* ISP_AWB_CC_COEFF_1 */
/*****************************************************************************/
/**
 * register: awb_meas_csc_coeff_2: Color conversion coefficient 2 (0x0000002c)
 *
 *****************************************************************************/
/* Slice: cc_coeff_2:*/
/* coefficient 2 for color space conversion */
#ifdef ISP_AWB_CC_COEFF_2
#endif /* ISP_AWB_CC_COEFF_2 */
/*****************************************************************************/
/**
 * register: awb_meas_csc_coeff_3: Color conversion coefficient 3 (0x00000030)
 *
 *****************************************************************************/
/* Slice: cc_coeff_3:*/
/* coefficient 3 for color space conversion */
#ifdef ISP_AWB_CC_COEFF_3
#endif /* ISP_AWB_CC_COEFF_3 */
/*****************************************************************************/
/**
 * register: awb_meas_csc_coeff_4: Color conversion coefficient 4 (0x00000034)
 *
 *****************************************************************************/
/* Slice: cc_coeff_4:*/
/* coefficient 4 for color space conversion */
#ifdef ISP_AWB_CC_COEFF_4
#endif /* ISP_AWB_CC_COEFF_4 */
/*****************************************************************************/
/**
 * register: awb_meas_csc_coeff_5: Color conversion coefficient 5 (0x00000038)
 *
 *****************************************************************************/
/* Slice: cc_coeff_5:*/
/* coefficient 5 for color space conversion */
#ifdef ISP_AWB_CC_COEFF_5
#endif /* ISP_AWB_CC_COEFF_5 */
/*****************************************************************************/
/**
 * register: awb_meas_csc_coeff_6: Color conversion coefficient 6 (0x0000003c)
 *
 *****************************************************************************/
/* Slice: cc_coeff_6:*/
/* coefficient 6 for color space conversion */
#ifdef ISP_AWB_CC_COEFF_6
#endif /* ISP_AWB_CC_COEFF_6 */
/*****************************************************************************/
/**
 * register: awb_meas_csc_coeff_7: Color conversion coefficient 7 (0x00000040)
 *
 *****************************************************************************/
/* Slice: cc_coeff_7:*/
/* coefficient 7 for color space conversion */
#ifdef ISP_AWB_CC_COEFF_7
#endif /* ISP_AWB_CC_COEFF_7 */
/*****************************************************************************/
/**
 * register: awb_meas_csc_coeff_8: Color conversion coefficient 8 (0x00000044)
 *
 *****************************************************************************/
/* Slice: cc_coeff_8:*/
/* coefficient 8 for color space conversion */
#ifdef ISP_AWB_CC_COEFF_8
#endif /* ISP_AWB_CC_COEFF_8 */
/*****************************************************************************/
/**
 * register: awb_meas_ellip1_cen_x: Ellipse 1 Center X (0x00000048)
 *
 *****************************************************************************/
/* Slice: ellip1_cen_x:*/
/* Ellipse 1 Center X signed integer value with 9 bit fractional part, range -1 to 0.998 */
#ifdef ISP_AWB_ELLIP1_CEN_X
#endif /* ISP_AWB_ELLIP1_CEN_X */
/*****************************************************************************/
/**
 * register: awb_meas_ellip1_cen_y: Ellipse 1 Center Y (0x0000004c)
 *
 *****************************************************************************/
/* Slice: ellip1_cen_y:*/
/* Ellipse 1 Center Y signed integer value with 9 bit fractional part, range -1 to 0.998 */
#ifdef ISP_AWB_ELLIP1_CEN_Y
#endif /* ISP_AWB_ELLIP1_CEN_Y */
/*****************************************************************************/
/**
 * register: awb_meas_ellip2_cen_x: Ellipse 2 Center X (0x00000050)
 *
 *****************************************************************************/
/* Slice: ellip2_cen_x:*/
/* Ellipse 2 Center X signed integer value with 9 bit fractional part, range -1 to 0.998 */
#ifdef ISP_AWB_ELLIP2_CEN_X
#endif /* ISP_AWB_ELLIP2_CEN_X */
/*****************************************************************************/
/**
 * register: awb_meas_ellip2_cen_y: Ellipse 2 Center Y (0x00000054)
 *
 *****************************************************************************/
/* Slice: ellip2_cen_y:*/
/* Ellipse 2 Center Y signed integer value with 9 bit fractional part, range -1 to 0.998 */
#ifdef ISP_AWB_ELLIP2_CEN_Y
#endif /* ISP_AWB_ELLIP2_CEN_Y */
/*****************************************************************************/
/**
 * register: awb_meas_ellip3_cen_x: Ellipse 3 Center X (0x00000058)
 *
 *****************************************************************************/
/* Slice: ellip3_cen_x:*/
/* Ellipse 3 Center X signed integer value with 9 bit fractional part, range -1 to 0.998 */
#ifdef ISP_AWB_ELLIP3_CEN_X
#endif /* ISP_AWB_ELLIP3_CEN_X */
/*****************************************************************************/
/**
 * register: awb_meas_ellip3_cen_y: Ellipse 3 Center Y (0x0000005c)
 *
 *****************************************************************************/
/* Slice: ellip3_cen_y:*/
/* Ellipse 3 Center Y signed integer value with 9 bit fractional part, range -1 to 0.998 */
#ifdef ISP_AWB_ELLIP3_CEN_Y
#endif /* ISP_AWB_ELLIP3_CEN_Y */
/*****************************************************************************/
/**
 * register: awb_meas_ellip4_cen_x: Ellipse 4 Center X (0x00000060)
 *
 *****************************************************************************/
/* Slice: ellip4_cen_x:*/
/* Ellipse 4 Center X signed integer value with 9 bit fractional part, range -1 to 0.998 */
#ifdef ISP_AWB_ELLIP4_CEN_X
#endif /* ISP_AWB_ELLIP4_CEN_X */
/*****************************************************************************/
/**
 * register: awb_meas_ellip4_cen_y: Ellipse 4 Center Y (0x00000064)
 *
 *****************************************************************************/
/* Register: awb_meas_ellip4_cen_y: Ellipse 4 Center Y (0x00000064)*/
/* Slice: ellip4_cen_y:*/
/* Ellipse 4 Center Y signed integer value with 9 bit fractional part, range -1 to 0.998 */
#ifdef ISP_AWB_ELLIP4_CEN_Y
#endif /* ISP_AWB_ELLIP4_CEN_Y */
/*****************************************************************************/
/**
 * register: awb_meas_ellip5_cen_x: Ellipse 5 Center X (0x00000068)
 *
 *****************************************************************************/
/* Slice: ellip5_cen_x:*/
/* Ellipse 5 Center X signed integer value with 9 bit fractional part, range -1 to 0.998 */
#ifdef ISP_AWB_ELLIP5_CEN_X
#endif /* ISP_AWB_ELLIP5_CEN_X */
/*****************************************************************************/
/**
 * register: awb_meas_ellip5_cen_y: Ellipse 5 Center Y (0x0000006c)
 *
 *****************************************************************************/
/* Slice: ellip5_cen_y:*/
/* Ellipse 5 Center Y signed integer value with 9 bit fractional part, range -1 to 0.998 */
#ifdef ISP_AWB_ELLIP5_CEN_Y
#endif /* ISP_AWB_ELLIP5_CEN_Y */
/*****************************************************************************/
/**
 * register: awb_meas_ellip6_cen_x: Ellipse 6 Center X (0x00000070)
 *
 *****************************************************************************/
/* Slice: ellip6_cen_x:*/
/* Ellipse 6 Center X signed integer value with 9 bit fractional part, range -1 to 0.998 */
#ifdef ISP_AWB_ELLIP6_CEN_X
#endif /* ISP_AWB_ELLIP6_CEN_X */
/*****************************************************************************/
/**
 * register: awb_meas_ellip6_cen_y: Ellipse 6 Center Y (0x00000074)
 *
 *****************************************************************************/
/* Slice: ellip6_cen_y:*/
/* Ellipse 6 Center Y signed integer value with 9 bit fractional part, range -1 to 0.998 */
#ifdef ISP_AWB_ELLIP6_CEN_Y
#endif /* ISP_AWB_ELLIP6_CEN_Y */
/*****************************************************************************/
/**
 * register: awb_meas_ellip7_cen_x: Ellipse 7 Center X (0x00000078)
 *
 *****************************************************************************/
/* Slice: ellip7_cen_x:*/
/* Ellipse 7 Center X signed integer value with 9 bit fractional part, range -1 to 0.998 */
#ifdef ISP_AWB_ELLIP7_CEN_X
#endif /* ISP_AWB_ELLIP7_CEN_X */
/*****************************************************************************/
/**
 * register: awb_meas_ellip7_cen_y: Ellipse 7 Center Y (0x0000007c)
 *
 *****************************************************************************/
/* Slice: ellip7_cen_y:*/
/* Ellipse 7 Center Y signed integer value with 9 bit fractional part, range -1 to 0.998 */
#ifdef ISP_AWB_ELLIP7_CEN_Y
#endif /* ISP_AWB_ELLIP7_CEN_Y */
/*****************************************************************************/
/**
 * register: awb_meas_ellip8_cen_x: Ellipse 8 Center X (0x00000080)
 *
 *****************************************************************************/
/* Slice: ellip8_cen_x:*/
/* Ellipse 8 Center X signed integer value with 9 bit fractional part, range -1 to 0.998 */
#ifdef ISP_AWB_ELLIP8_CEN_X
#endif /* ISP_AWB_ELLIP8_CEN_X */
/*****************************************************************************/
/**
 * register: awb_meas_ellip8_cen_y: Ellipse 8 Center Y (0x00000084)
 *
 *****************************************************************************/
/* Slice: ellip8_cen_y:*/
/* Ellipse 8 Center Y signed integer value with 9 bit fractional part, range -1 to 0.998 */
#ifdef ISP_AWB_ELLIP8_CEN_Y
#endif /* ISP_AWB_ELLIP8_CEN_Y */
/*****************************************************************************/
/**
 * register: awb_meas_ellip1_a1: Ellipse 1 coefficient a1 (0x00000088)
 *
 *****************************************************************************/
/* Slice: ellip1_a1:*/
/* Ellipse 1 Coefficient a1 signed integer value with 8 bit fractional part, range -7.996 to 7.996 */
#ifdef ISP_AWB_ELLIP1_A1
#endif /* ISP_AWB_ELLIP1_A1 */
/*****************************************************************************/
/**
 * register: awb_meas_ellip1_a2: Ellipse 1 coefficient a2 (0x0000008c)
 *
 *****************************************************************************/
/* Slice: ellip1_a2:*/
/* Ellipse 1 Coefficient a2 signed integer value with 8 bit fractional part, range -1 to 0.996 */
#ifdef ISP_AWB_ELLIP1_A2
#endif /* ISP_AWB_ELLIP1_A2 */
/*****************************************************************************/
/**
 * register: awb_meas_ellip1_a3: Ellipse 1 coefficient a3 (0x00000090)
 *
 *****************************************************************************/
/* Slice: ellip1_a3:*/
/* Ellipse 1 Coefficient a3 signed integer value with 8 bit fractional part, range -7.996 to 7.996 */
#ifdef ISP_AWB_ELLIP1_A3
#endif /* ISP_AWB_ELLIP1_A3 */
/*****************************************************************************/
/**
 * register: awb_meas_ellip1_a4: Ellipse 1 coefficient a4 (0x00000094)
 *
 *****************************************************************************/
/* Slice: ellip1_a4:*/
/* Ellipse 1 Coefficient a4 signed integer value with 8 bit fractional part, range -1 to 0.996 */
#ifdef ISP_AWB_ELLIP1_A4
#endif /* ISP_AWB_ELLIP1_A4 */
/*****************************************************************************/
/**
 * register: awb_meas_ellip2_a1: Ellipse 2 coefficient a1 (0x00000098)
 *
 *****************************************************************************/
/* Slice: ellip2_a1:*/
/* Ellipse 2 Coefficient a1 signed integer value with 8 bit fractional part, range -7.996 to 7.996 */
#ifdef ISP_AWB_ELLIP2_A1
#endif /* ISP_AWB_ELLIP2_A1 */
/*****************************************************************************/
/**
 * register: awb_meas_ellip2_a2: Ellipse 2 coefficient a2 (0x0000009c)
 *
 *****************************************************************************/
/* Slice: ellip2_a2:*/
/* Ellipse 2 Coefficient a2 signed integer value with 8 bit fractional part, range -1 to 0.996 */
#ifdef ISP_AWB_ELLIP2_A2
#endif /* ISP_AWB_ELLIP2_A2 */
/*****************************************************************************/
/**
 * register: awb_meas_ellip2_a3: Ellipse 2 coefficient a3 (0x000000a0)
 *
 *****************************************************************************/
/* Slice: ellip2_a3:*/
/* Ellipse 2 Coefficient a3 signed integer value with 8 bit fractional part, range -7.996 to 7.996 */
#ifdef ISP_AWB_ELLIP2_A3
#endif /* ISP_AWB_ELLIP2_A3 */
/*****************************************************************************/
/**
 * register: awb_meas_ellip2_a4: Ellipse 2 coefficient a4 (0x000000a4)
 *
 *****************************************************************************/
/* Slice: ellip2_a4:*/
/* Ellipse 2 Coefficient a4 signed integer value with 8 bit fractional part, range -1 to 0.996 */
#ifdef ISP_AWB_ELLIP2_A4
#endif /* ISP_AWB_ELLIP2_A4 */
/*****************************************************************************/
/**
 * register: awb_meas_ellip3_a1: Ellipse 3 coefficient a1 (0x000000a8)
 *
 *****************************************************************************/
/* Slice: ellip3_a1:*/
/* Ellipse 2 Coefficient a1 signed integer value with 8 bit fractional part, range -7.996 to 7.996 */
#ifdef ISP_AWB_ELLIP3_A1
#endif /* ISP_AWB_ELLIP3_A1 */
/*****************************************************************************/
/**
 * register: awb_meas_ellip3_a2: Ellipse 3 coefficient a2 (0x000000ac)
 *
 *****************************************************************************/
/* Slice: ellip3_a2:*/
/* Ellipse 2 Coefficient a2 signed integer value with 8 bit fractional part, range -1 to 0.996 */
#ifdef ISP_AWB_ELLIP3_A2
#endif /* ISP_AWB_ELLIP3_A2 */
/*****************************************************************************/
/**
 * register: awb_meas_ellip3_a3: Ellipse 3 coefficient a3 (0x000000b0)
 *
 *****************************************************************************/
/* Slice: ellip3_a3:*/
/* Ellipse 2 Coefficient a3 signed integer value with 8 bit fractional part, range -7.996 to 7.996 */
#ifdef ISP_AWB_ELLIP3_A3
#endif /* ISP_AWB_ELLIP3_A3 */
/*****************************************************************************/
/**
 * register: awb_meas_ellip3_a4: Ellipse 3 coefficient a4 (0x000000b4)
 *
 *****************************************************************************/
/* Slice: ellip3_a4:*/
/* Ellipse 2 Coefficient a4 signed integer value with 8 bit fractional part, range -1 to 0.996 */
#ifdef ISP_AWB_ELLIP3_A4
#endif /* ISP_AWB_ELLIP3_A4 */
/*****************************************************************************/
/**
 * register: awb_meas_ellip4_a1: Ellipse 4 coefficient a1 (0x000000b8)
 *
 *****************************************************************************/
/* Slice: ellip4_a1:*/
/* Ellipse 2 Coefficient a1 signed integer value with 8 bit fractional part, range -7.996 to 7.996 */
#ifdef ISP_AWB_ELLIP4_A1
#endif /* ISP_AWB_ELLIP4_A1 */
/*****************************************************************************/
/**
 * register: awb_meas_ellip4_a2: Ellipse 4 coefficient a2 (0x000000bc)
 *
 *****************************************************************************/
/* Slice: ellip4_a2:*/
/* Ellipse 2 Coefficient a2 signed integer value with 8 bit fractional part, range -1 to 0.996 */
#ifdef ISP_AWB_ELLIP4_A2
#endif /* ISP_AWB_ELLIP4_A2 */
/*****************************************************************************/
/**
 * register: awb_meas_ellip4_a3: Ellipse 4 coefficient a3 (0x000000c0)
 *
 *****************************************************************************/
/* Slice: ellip4_a3:*/
/* Ellipse 2 Coefficient a3 signed integer value with 8 bit fractional part, range -7.996 to 7.996 */
#ifdef ISP_AWB_ELLIP4_A3
#endif /* ISP_AWB_ELLIP4_A3 */
/*****************************************************************************/
/**
 * register: awb_meas_ellip4_a4: Ellipse 4 coefficient a4 (0x000000c4)
 *
 *****************************************************************************/
/* Slice: ellip4_a4:*/
/* Ellipse 2 Coefficient a4 signed integer value with 8 bit fractional part, range -1 to 0.996 */
#ifdef ISP_AWB_ELLIP4_A4
#endif /* ISP_AWB_ELLIP4_A4 */
/*****************************************************************************/
/**
 * register: awb_meas_ellip5_a1: Ellipse 5 coefficient a1 (0x000000c8)
 *
 *****************************************************************************/
/* Slice: ellip5_a1:*/
/* Ellipse 2 Coefficient a1 signed integer value with 8 bit fractional part, range -7.996 to 7.996 */
#ifdef ISP_AWB_ELLIP5_A1
#endif /* ISP_AWB_ELLIP5_A1 */
/*****************************************************************************/
/**
 * register: awb_meas_ellip5_a2: Ellipse 5 coefficient a2 (0x000000cc)
 *
 *****************************************************************************/
/* Slice: ellip5_a2:*/
/* Ellipse 2 Coefficient a2 signed integer value with 8 bit fractional part, range -1 to 0.996 */
#ifdef ISP_AWB_ELLIP5_A2
#endif /* ISP_AWB_ELLIP5_A2 */
/*****************************************************************************/
/**
 * register: awb_meas_ellip5_a3: Ellipse 5 coefficient a3 (0x000000d0)
 *
 *****************************************************************************/
/* Slice: ellip5_a3:*/
/* Ellipse 2 Coefficient a3 signed integer value with 8 bit fractional part, range -7.996 to 7.996 */
#ifdef ISP_AWB_ELLIP5_A3
#endif /* ISP_AWB_ELLIP5_A3 */
/*****************************************************************************/
/**
 * register: awb_meas_ellip5_a4: Ellipse 5 coefficient a4 (0x000000d4)
 *
 *****************************************************************************/
/* Slice: ellip5_a4:*/
/* Ellipse 2 Coefficient a4 signed integer value with 8 bit fractional part, range -1 to 0.996 */
#ifdef ISP_AWB_ELLIP5_A4
#endif /* ISP_AWB_ELLIP5_A4 */
/*****************************************************************************/
/**
 * register: awb_meas_ellip6_a1: Ellipse 6 coefficient a1 (0x000000d8)
 *
 *****************************************************************************/
/* Slice: ellip6_a1:*/
/* Ellipse 2 Coefficient a1 signed integer value with 8 bit fractional part, range -7.996 to 7.996 */
#ifdef ISP_AWB_ELLIP6_A1
#endif /* ISP_AWB_ELLIP6_A1 */
/*****************************************************************************/
/**
 * register: awb_meas_ellip6_a2: Ellipse 6 coefficient a2 (0x000000dc)
 *
 *****************************************************************************/
/* Slice: ellip6_a2:*/
/* Ellipse 2 Coefficient a2 signed integer value with 8 bit fractional part, range -1 to 0.996 */
#ifdef ISP_AWB_ELLIP6_A2
#endif /* ISP_AWB_ELLIP6_A2 */
/*****************************************************************************/
/**
 * register: awb_meas_ellip6_a3: Ellipse 6 coefficient a3 (0x000000e0)
 *
 *****************************************************************************/
/* Slice: ellip6_a3:*/
/* Ellipse 2 Coefficient a3 signed integer value with 8 bit fractional part, range -7.996 to 7.996 */
#ifdef ISP_AWB_ELLIP6_A3
#endif /* ISP_AWB_ELLIP6_A3 */
/*****************************************************************************/
/**
 * register: awb_meas_ellip6_a4: Ellipse 6 coefficient a4 (0x000000e4)
 *
 *****************************************************************************/
/* Slice: ellip6_a4:*/
/* Ellipse 2 Coefficient a4 signed integer value with 8 bit fractional part, range -1 to 0.996 */
#ifdef ISP_AWB_ELLIP6_A4
#endif /* ISP_AWB_ELLIP6_A4 */
/*****************************************************************************/
/**
 * register: awb_meas_ellip7_a1: Ellipse 7 coefficient a1 (0x000000e8)
 *
 *****************************************************************************/
/* Slice: ellip7_a1:*/
/* Ellipse 2 Coefficient a1 signed integer value with 8 bit fractional part, range -7.996 to 7.996 */
#ifdef ISP_AWB_ELLIP7_A1
#endif /* ISP_AWB_ELLIP7_A1 */
/*****************************************************************************/
/**
 * register: awb_meas_ellip7_a2: Ellipse 7 coefficient a2 (0x000000ec)
 *
 *****************************************************************************/
/* Slice: ellip7_a2:*/
/* Ellipse 2 Coefficient a2 signed integer value with 8 bit fractional part, range -1 to 0.996 */
#ifdef ISP_AWB_ELLIP7_A2
#endif /* ISP_AWB_ELLIP7_A2 */
/*****************************************************************************/
/**
 * register: awb_meas_ellip7_a3: Ellipse 7 coefficient a3 (0x000000f0)
 *
 *****************************************************************************/
/* Slice: ellip7_a3:*/
/* Ellipse 2 Coefficient a3 signed integer value with 8 bit fractional part, range -7.996 to 7.996 */
#ifdef ISP_AWB_ELLIP7_A3
#endif /* ISP_AWB_ELLIP7_A3 */
/*****************************************************************************/
/**
 * register: awb_meas_ellip7_a4: Ellipse 7 coefficient a4 (0x000000f4)
 *
 *****************************************************************************/
/* Slice: ellip7_a4:*/
/* Ellipse 2 Coefficient a4 signed integer value with 8 bit fractional part, range -1 to 0.996 */
#ifdef ISP_AWB_ELLIP7_A4
#endif /* ISP_AWB_ELLIP7_A4 */
/*****************************************************************************/
/**
 * register: awb_meas_ellip8_a1: Ellipse 8 coefficient a1 (0x000000f8)
 *
 *****************************************************************************/
/* Slice: ellip8_a1:*/
/* Ellipse 2 Coefficient a1 signed integer value with 8 bit fractional part, range -7.996 to 7.996 */
#ifdef ISP_AWB_ELLIP8_A1
#endif /* ISP_AWB_ELLIP8_A1 */
/*****************************************************************************/
/**
 * register: awb_meas_ellip8_a2: Ellipse 8 coefficient a2 (0x000000fc)
 *
 *****************************************************************************/
/* Slice: ellip8_a2:*/
/* Ellipse 2 Coefficient a2 signed integer value with 8 bit fractional part, range -1 to 0.996 */
#ifdef ISP_AWB_ELLIP8_A2
#endif /* ISP_AWB_ELLIP8_A2 */
/*****************************************************************************/
/**
 * register: awb_meas_ellip8_a3: Ellipse 8 coefficient a3 (0x00000100)
 *
 *****************************************************************************/
/* Slice: ellip8_a3:*/
/* Ellipse 2 Coefficient a3 signed integer value with 8 bit fractional part, range -7.996 to 7.996 */
#ifdef ISP_AWB_ELLIP8_A3
#endif /* ISP_AWB_ELLIP8_A3 */
/*****************************************************************************/
/**
 * register: awb_meas_ellip8_a4: Ellipse 8 coefficient a4 (0x00000104)
 *
 *****************************************************************************/
/* Slice: ellip8_a4:*/
/* Ellipse 2 Coefficient a4 signed integer value with 8 bit fractional part, range -1 to 0.996 */
#ifdef ISP_AWB_ELLIP8_A4
#endif /* ISP_AWB_ELLIP8_A4 */
/*****************************************************************************/
/**
 * register: awb_meas_ellip1_rmax: Ellipse 1 r_max (0x00000108)
 *
 *****************************************************************************/
/* Slice: ellip1_rmax:*/
/* Ellipse 1 max radius square compare value */
#ifdef ISP_AWB_ELLIP1_RMAX
#endif /* ISP_AWB_ELLIP1_RMAX */
/*****************************************************************************/
/**
 * register: awb_meas_ellip2_rmax: Ellipse 2 r_max (0x0000010c)
 *
 *****************************************************************************/
/* Slice: ellip2_rmax:*/
/* Ellipse 2 max radius square compare value */
#ifdef ISP_AWB_ELLIP2_RMAX
#endif /* ISP_AWB_ELLIP2_RMAX */
/*****************************************************************************/
/**
 * register: awb_meas_ellip3_rmax: Ellipse 3 r_max (0x00000110)
 *
 *****************************************************************************/
/* Slice: ellip3_rmax:*/
/* Ellipse 3 max radius square compare value */
#ifdef ISP_AWB_ELLIP3_RMAX
#endif /* ISP_AWB_ELLIP3_RMAX */
/*****************************************************************************/
/**
 * register: awb_meas_ellip4_rmax: Ellipse 4 r_max (0x00000114)
 *
 *****************************************************************************/
/* Slice: ellip4_rmax:*/
/* Ellipse 4 max radius square compare value */
#ifdef ISP_AWB_ELLIP4_RMAX
#endif /* ISP_AWB_ELLIP4_RMAX */
/*****************************************************************************/
/**
 * register: awb_meas_ellip5_rmax: Ellipse 5 r_max (0x00000118)
 *
 *****************************************************************************/
/* Slice: ellip5_rmax:*/
/* Ellipse 5 max radius square compare value */
#ifdef ISP_AWB_ELLIP5_RMAX
#endif /* ISP_AWB_ELLIP5_RMAX */
/*****************************************************************************/
/**
 * register: awb_meas_ellip6_rmax: Ellipse 6 r_max (0x0000011c)
 *
 *****************************************************************************/
/* Slice: ellip6_rmax:*/
/* Ellipse 6 max radius square compare value */
#ifdef ISP_AWB_ELLIP6_RMAX
#endif /* ISP_AWB_ELLIP6_RMAX */
/*****************************************************************************/
/**
 * register: awb_meas_ellip7_rmax: Ellipse 7 r_max (0x00000120)
 *
 *****************************************************************************/
/* Slice: ellip7_rmax:*/
/* Ellipse 7 max radius square compare value */
#ifdef ISP_AWB_ELLIP7_RMAX
#endif /* ISP_AWB_ELLIP7_RMAX */
/*****************************************************************************/
/**
 * register: awb_meas_ellip8_rmax: Ellipse 8 r_max (0x00000124)
 *
 *****************************************************************************/
/* Slice: ellip8_rmax:*/
/* Ellipse 8 max radius square compare value */
#ifdef ISP_AWB_ELLIP8_RMAX
#endif /* ISP_AWB_ELLIP8_RMAX */
/*****************************************************************************/
/**
 * register: awb_meas_counter_1: AWB Counter 1 (0x00000128)
 *
 *****************************************************************************/
/* Slice: count_1:*/
/* counted Pixels of Ellipse 1 */
#ifdef ISP_AWB_COUNT_1
#endif /* ISP_AWB_COUNT_1 */
/*****************************************************************************/
/**
 * register: awb_meas_counter_2: AWB Counter 2 (0x0000012c)
 *
 *****************************************************************************/
/* Slice: count_2:*/
/* counted Pixels of Ellipse 2 */
#ifdef ISP_AWB_COUNT_2
#endif /* ISP_AWB_COUNT_2 */
/*****************************************************************************/
/**
 * register: awb_meas_counter_3: AWB Counter 3 (0x00000130)
 *
 *****************************************************************************/
/* Slice: count_3:*/
/* counted Pixels of Ellipse 3 */
#ifdef ISP_AWB_COUNT_3
#endif /* ISP_AWB_COUNT_3 */
/*****************************************************************************/
/**
 * register: awb_meas_counter_4: AWB Counter 4 (0x00000134)
 *
 *****************************************************************************/
/* Slice: count_4:*/
/* counted Pixels of Ellipse 4 */
#ifdef ISP_AWB_COUNT_4
#endif /* ISP_AWB_COUNT_4 */
/*****************************************************************************/
/**
 * register: awb_meas_counter_5: AWB Counter 5 (0x00000138)
 *
 *****************************************************************************/
/* Slice: count_5:*/
/* counted Pixels of Ellipse 5 */
#ifdef ISP_AWB_COUNT_5
#endif /* ISP_AWB_COUNT_5 */
/*****************************************************************************/
/**
 * register: awb_meas_counter_6: AWB Counter 6 (0x0000013c)
 *
 *****************************************************************************/
/* Slice: count_6:*/
/* counted Pixels of Ellipse 6 */
#ifdef ISP_AWB_COUNT_6
#endif /* ISP_AWB_COUNT_6 */
/*****************************************************************************/
/**
 * register: awb_meas_counter_7: AWB Counter 7 (0x00000140)
 *
 *****************************************************************************/
/* Slice: count_7:*/
/* counted Pixels of Ellipse 7 */
#ifdef ISP_AWB_COUNT_7
#endif /* ISP_AWB_COUNT_7 */
/*****************************************************************************/
/**
 * register: awb_meas_counter_8: AWB Counter 8 (0x00000144)
 *
 *****************************************************************************/
/* Slice: count_8:*/
/* counted Pixels of Ellipse 8 */
#ifdef ISP_AWB_COUNT_8
#endif /* ISP_AWB_COUNT_8 */
/*****************************************************************************/
/**
 * register array: awb_meas_accu: AWB Accu Read (0x298 + n*0x4 (n=0..23))
 *
 *****************************************************************************/
/* Slice: read_accu:*/
/* measured sum[34:3] of RGB values.*/
#ifdef ISP_AWB_READ_ACCU
#endif /* ISP_AWB_READ_ACCU */
#ifdef EE_CTRL_ENABLE
#define EE_CTRL_ENABLE_SET 1
#define EE_CTRL_ENABLE_CLEAR 0
#endif
/*****************************************************************************/
/**
 * register array: awb_meas_accu: AWB Accu Read (0x298 + n*0x4 (n=0..23))
 *
 *****************************************************************************/
/* Slice: read_accu:*/
/* measured sum[34:3] of RGB values.*/
#ifdef ISP_VSM_DELTA_H
#endif /* ISP_AWB_READ_ACCU */
/*****************************************************************************/
/**
 * register: isp_vsm_h_offs: VSM window horizontal offset
 *
 *****************************************************************************/
/* Slice: vsm_h_offset:*/
/* Horizontal offset in pixels.*/
#ifdef ISP_VSM_H_OFFSET
#define ISP_VSM_H_OFFSET_MAX (ISP_VSM_H_OFFSET_MASK >> ISP_VSM_H_OFFSET_SHIFT)
#endif /* ISP_VSM_H_OFFSET */
/*****************************************************************************/
/**
 * register: isp_vsm_v_offs: VSM window vertical offset
 *
 *****************************************************************************/
/* Slice: vsm_v_offset:*/
/* Vertical offset in pixels.*/
#ifdef ISP_VSM_V_OFFSET
#define ISP_VSM_V_OFFSET_MAX (ISP_VSM_V_OFFSET_MASK >> ISP_VSM_V_OFFSET_SHIFT)
#endif /* ISP_VSM_V_OFFSET */
/*****************************************************************************/
/**
 * register: isp_vsm_h_size: Horizontal measure window size
 *
 *****************************************************************************/
/* Slice: vsm_h_size:*/
/* Horizontal size in pixels..*/
#ifdef ISP_VSM_H_SIZE
/* note: do not apply shift, since bit 0 is only excluded to get even values */
#define ISP_VSM_H_SIZE_MAX ISP_VSM_H_SIZE_MASK
#endif /* ISP_VSM_H_SIZE */
/*****************************************************************************/
/**
 * register: isp_vsm_v_size: Vertical measure window size
 *
 *****************************************************************************/
/* Slice: vsm_v_size:*/
/* Vertical size in pixels.*/
#ifdef ISP_VSM_V_SIZE
/* note: do not apply shift, since bit 0 is only excluded to get even values */
#define ISP_VSM_V_SIZE_MAX ISP_VSM_V_SIZE_MASK
#endif /* ISP_VSM_V_SIZE */
/*****************************************************************************/
/**
 * register: isp_vsm_h_segments: Iteration 1 horizontal segments
 *
 *****************************************************************************/
/* Slice: vsm_h_segments:*/
/* number of 16 point wide segments enclosed by the first iteration sample */
/* points in horizontal direction. Range: 1 ... 128 */
#ifdef ISP_VSM_H_SEGMENTS
#define ISP_VSM_H_SEGMENTS_MIN   1
#define ISP_VSM_H_SEGMENTS_MAX 128
#endif /* ISP_VSM_H_SEGMENTS */
/*****************************************************************************/
/**
 * register: isp_vsm_v_segments: Iteration 1 vertical segments
 *
 *****************************************************************************/
/* Slice: vsm_v_segments:*/
/* number of 16 point wide segments enclosed by the first iteration sample */
/* points in vertical direction. Range: 1 ... 128 */
/* Note: number of 1st iteration sample points = vsm_v_segments + 1.*/
/* vsm_v_segments must be equal or smaller than vsm_h_segments.*/
#ifdef ISP_VSM_V_SEGMENTS
#define ISP_VSM_V_SEGMENTS_MIN   1
#define ISP_VSM_V_SEGMENTS_MAX 128
#endif /* ISP_VSM_V_SEGMENTS */
#ifdef ISP_GCMONO
/*****************************************************************************/
/**
 * register: isp_gcmono_ctrl: gcmono enable and lut table cfg
 *
 *****************************************************************************/
/*! Slice: mono_gc_enable */
/*! Control of gamma correction for mono sensor RAW data */
/*! 1'b0: disable GC and enter bypass mode */
/*! 1'b1: enable GC mode */
#ifdef ISP_GCMONO_SWITCH
#define ISP_GCMONO_SWITCH_DISABLE 0	/* 0: disable GC */
#define ISP_GCMONO_SWITCH_ENABLE  1	/* 1: enable GC */
#endif
/*! Slice: mono_gc_cfg_done */
/*! To notify the ISP HW the LUT configuration is done, ready to use, active high.*/
/*! Writing ZERO reset teh internal read/write pointer and also indicates that the LUT can be configured or read from CPU.*/
#ifdef ISP_GCMONO_CFG_DONE
#define ISP_GCMONO_CFG_DONE_CURVE_READY     1	/* 1: notify ISP HW LUT configuration is done */
#define ISP_GCMONO_CFG_DONE_SET_CURVE       0	/* 0: Write ZERO reset the internal pointer and can cfg LUT. */
#endif
#ifdef ISP_GCMONO_PARA_BASE
#endif
#endif
/*****************************************************************************/
/* MIV2 Registers                                                            */
/*****************************************************************************/
/*****************************************************************************/
/**
 * register: miv2_mp_fmt: main path pixel format control register (0x1314)
 *
 *****************************************************************************/
/* Slice: MP_WR_JDP_FMT */
/* 1: JPEG */
/* 0: DPCC */
#ifdef MP_WR_JDP_FMT
#define MIV2_MP_WRITE_FORMAT_DPCC	    0	/* DPCC */
#define MIV2_MP_WRITE_FORMAT_JPEG	    1	/* JPEG */
#endif /* MP_WR_JDP_FMT */
/* Slice: MP_WR_YUV_BIT: */
/* 1: 10bit YUV/RGB */
/* 0: 8bit YUV/RGB */
#ifdef MP_WR_YUV_BIT
#define MIV2_MP_WRITE_FORMAT_8BIT	    0	/* 8bit YUV/RGB */
#define MIV2_MP_WRITE_FORMAT_10BIT	    1	/* 10bit YUV/RGB */
#endif /* MP_WR_YUV_BIT */
/* Slice: MP_WR_YUV_FMT: */
#ifdef MP_WR_YUV_FMT
#define MIV2_MP_WRITE_FORMAT_YUV420         0	/* 00: YUV420 */
#define MIV2_MP_WRITE_FORMAT_YUV422         1	/* 01: YUV422 */
#define MIV2_MP_WRITE_FORMAT_YUV444         2	/* 10: YUV444 */
#endif /* MP_WR_YUV_FMT */
/* Slice: MP_WR_YUV_STR: */
#ifdef MP_WR_YUV_STR
#define MIV2_MP_WRITE_STRIDE_SEMIPLANAR     0	/* 00: YUV/RGB SemiPlanar */
#define MIV2_MP_WRITE_STRIDE_INTERLEAVE     1	/* 01: YUV Interleave, RGB Raster */
#define MIV2_MP_WRITE_STRIDE_PLANAR         2	/* 10: YUV/RGB Planar */
#endif /* MP_WR_YUV_STR */
/* Slice: MP_WR_RAW_BIT: */
#ifdef MP_WR_RAW_BIT
#define MIV2_MP_WRITE_FORMAT_RAW8           0	/* 000: RAW8 */
#define MIV2_MP_WRITE_FORMAT_RAW10          1	/* 001: RAW10 */
#define MIV2_MP_WRITE_FORMAT_RAW12          2	/* 010: RAW12 */
#define MIV2_MP_WRITE_FORMAT_RAW14          3	/* 011: RAW14 */
#define MIV2_MP_WRITE_FORMAT_RAW16          4	/* 100: RAW16 */
#define MIV2_MP_WRITE_FORMAT_RAW20          5	/* 101: RAW20 */
#endif /* MP_WR_RAW_BIT */
/* Slice: MP_WR_YUV_ALIGNED */
/* 1: aligned */
/* 0: unaligned */
#ifdef MP_WR_YUV_ALIGNED
#define MIV2_MP_WRITE_YUV_UNALIGNED	    0	/* unaligned */
#define MIV2_MP_WRITE_YUV_ALIGNED	    1	/* aligned */
#endif /* MP_WR_YUV_ALIGNED */
/* Slice: MP_WR_RAW_ALIGNED: */
#ifdef MP_WR_RAW_ALIGNED
#define MIV2_MP_WRITE_RAW_UNALIGNED         0	/* 00: unaligned */
#define MIV2_MP_WRITE_RAW_ALIGNED_MODE1     1	/* 01: aligned mode1 */
#define MIV2_MP_WRITE_RAW_ALIGNED_MODE2     2	/* 10: aligned mode2 */
#endif /* MP_WR_RAW_ALIGNED */
/* Slice: MP_WR_YUV_NV21 */
/* 1: Put U before V */
/* 0: Put V before U */
#ifdef MP_WR_YUV_NV21
#define MIV2_MP_WRITE_YUV_NV21_UV           0	/* Put U before V */
#define MIV2_MP_WRITE_YUV_NV21_VU           1	/* Put V before U */
#endif /* MP_WR_YUV_NV21 */
/* Slice: MP_WR_YUV_NVY: */
#ifdef MP_WR_YUV_NVY
#define MIV2_MP_WRITE_YUV_NVY_YC1C2         0	/* 00: Put Y first => YC1C2 */
#define MIV2_MP_WRITE_YUV_NVY_C1YC2         1	/* 01: Put Y second => C1YC2 */
#define MIV2_MP_WRITE_YUV_NVY_C1C2Y	    2	/* 10: Put Y Third => C1C2Y */
#endif /* MP_WR_YUV_NVY */
/* ========================================================================================= */
#ifdef ISP_DEMOSAIC_DENOISE_STRENGTH
#define ISP_DEMOSAIC_DENOISE_STRENGTH_MIN   0
#define ISP_DEMOSAIC_DENOISE_STRENGTH_MAX   32
#endif
#ifdef ISP_DEMOSAIC_SHARPEN_SIZE
#define ISP_DEMOSAIC_SHARPEN_SIZE_MIN       0
#define ISP_DEMOSAIC_SHARPEN_SIZE_MAX       16
#endif
#ifdef ISP_DMSC_DEMOIRE_AREA_THR
#define ISP_DMSC_DEMOIRE_AREA_THR_MIN       0
#define ISP_DMSC_DEMOIRE_AREA_THR_MAX       32
#endif
#ifdef ISP_DMSC_DEMOIRE_SAT_SHRINK
#define ISP_DMSC_DEMOIRE_SAT_SHRINK_MIN     0
#define ISP_DMSC_DEMOIRE_SAT_SHRINK_MAX     32
#endif
#ifdef ISP_DMSC_SHARPEN_T4_SHIFT
#define ISP_DMSC_SHARPEN_SHIFT_MIN          0
#define ISP_DMSC_SHARPEN_SHIFT_MAX          11
#endif
#ifdef ISP_DMSC_SHARPEN_LINE_SHIFT1
#define ISP_DMSC_SHARPEN_LINE_SHIFT1_MIN    0
#define ISP_DMSC_SHARPEN_LINE_SHIFT1_MAX    10
#endif
#ifdef ISP_DMSC_HF_FILT_00
#define ISP_DMSC_HF_FILT_MIN                0
#define ISP_DMSC_HF_FILT_MAX                34
#endif
#ifdef ISP_DMSC_CBCR_MODE
#define ISP_DMSC_CBCR_MODE_MIN   0
#define ISP_DMSC_CBCR_MODE_MAX 3
#endif
#ifdef ISP_DMSC_DEPURPLE_SAT_SHRINK
#define ISP_DMSC_DEPURPLE_SAT_SHRINK_MIN 0
#define ISP_DMSC_DEPURPLE_SAT_SHRINK_MAX 8
#endif
#ifdef ISP_DMSC_X_NF
#define ISP_DMSC_X_NF_MIN   0
#define ISP_DMSC_X_NF_MAX 31
#endif
#ifdef ISP_DMSC_X_NS
#define ISP_DMSC_X_NS_MIN   0
#define ISP_DMSC_X_NS_MAX 15
#endif
#ifdef ISP_DMSC_Y_NF
#define ISP_DMSC_Y_NF_MIN   0
#define ISP_DMSC_Y_NF_MAX 31
#endif
#ifdef ISP_DMSC_Y_NS
#define ISP_DMSC_Y_NS_MIN   0
#define ISP_DMSC_Y_NS_MAX 15
#endif
/* =========================================================================================*/
/*! returns the value of slice \a name from register or variable \a reg
 * \note "parameter" \a reg could be a hardware register or a (32bit) variable, but not a pointer! \n
 *       each slice (specified as "parameter" \a name) requires two \#defines: \n
 *        - <tt>\<name\>_MASK  </tt>: defines the mask to use on register side
 *        - <tt>\<name\>_SHIFT </tt>: defines the shift value to use (left on write, right on read)
 */
#define REG_GET_SLICE(reg, name) \
    (((reg) & (name##_MASK)) >> (name##_SHIFT))
/* =========================================================================================*/
/*! writes the value \a value into slice \a name of register or variable \a reg
 * \note "parameter" \a reg could be a hardware register or a (32bit) variable, but not a pointer! \n
 *       each slice (specified as "parameter" \a name) requires two \#defines: \n
 *        - <tt>\<name\>_MASK  </tt>: defines the mask to use on register side
 *        - <tt>\<name\>_SHIFT </tt>: defines the shift value to use (left on write, right on read)
 */
#define REG_SET_SLICE(reg, name, value) \
    { \
	((reg) = (((reg) & ~(name##_MASK)) | (((value) << (name##_SHIFT)) & (name##_MASK))));\
    }
#endif /* __MRV_ALL_BITS_H__ */
